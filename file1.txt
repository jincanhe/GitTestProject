#include "WSManager.h"
#include "Common.h"
#include "Player.h"
#include "MainGame.h"
#include "rapidjson/document.h"
#include "Item.h"
#include "ItemProvider.h"
#include "Backpack.h"
#include "DropItem.h"
#include "Building.h"
#include "CropDataProvider.h"
#include "CharacterSystem.h"
#include "MissionSystem.h"
#include "Poultry.h"
#include "Livestock.h"
#include "LivestockHouse.h"
#include "PoultryHouse.h"
#include "House.h"
#include "ClothesStand.h"
#include "Museum.h"
#include "Hotel.h"
#include "VisitSystem.h"
#include "ShopSystem.h"
#include "SkillSystem.h"
#include "AccessoriesManager.h"
#include "common/EventMgr.h"
#include "ScriptSystem.h"
#include "Sign.h"
#include "piervisit/PierVisitView.h"
#include "Common/UIViewMgr.h"
#include "common/MsgMgr.h"
#include "noviceGuide/NoviceGuideMgr.h"
#include "Authentication/AntiAddictionView.h"
#include "LuaNetMgr.h"
#include "behavior/BehaviorController.h"
#include "recharge/RechargeBuyMonthCard.h"
#include "mainUI/MainView.h"
#include "table/PlaceableTable.h"
#include "bed/Bed.h"
#include "weather/WeatherController.h"
#include "recharge/RechargeBuyPop.h"
#include "stage/StageController.h"
#include "MineSystemController.h"
#include "SocializeSystem.h"
#include "GatheringPlace.h"
#include "MapUnlockManager.h"
#include "LightSystemController.h"
#include "socializeTeam/TeamNoticeView.h"
#include "MailBoxSystem.h"
#include "login/LoginPhoneView.h"
#include "CollectionSystem.h"
#include "guideMrg/GuideSystemController.h"
#include "buildview/GetBuildControll.h"
#include "friend/FriendView.h"
#include "RecycleManager.h"
#include "AchievementManager.h"
#include "SleepManager.h"
#include "MovieShowMgr.h"
#include "SignInSystem.h"

#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>
#include "licheng/LiChengDataMrg.h"
#include "common/ComponentMgr.h"
#include "animal/AnimalModel.h"

using namespace std;
using namespace rapidjson;

Document g_MapAllDataJsonDoc;
int g_MapAllDataJsonDoc_cnt;
vector<int> g_mapIdVtr;

std::unordered_map<int, std::string> commandNames = {
	{ 0, "PING" },
	{ 1, "MOVE" },
	{ 2, "GET_MAP" },
	{ 3, "USE_TOOL" },
	{ 4, "PICK_UP" },
	{ 5, "REFRESH" },
	{ 6, "THE_TREE_FELL" },
	{ 7, "HARVEST" },
	{ 8, "MAKE" },
	{ 9, "MAKE_FINISH" },
	{ 10, "ASSEMBLE" },
	{ 11, "FINISH_FISHING" },
	{ 12, "FINISH_CATCHING" },
	{ 13, "SEND_NPC_GIFTS" },
	{ 14, "MOVE_ITEM" },
	{ 15, "GET_CITY" },
	{ 16, "GET_CHARACTER_CARD_LIST" },
	{ 17, "GET_CHARACTER_CARD_QUEUE" },
	{ 18, "SET_CHARACTER_CARD_QUEUE" },
	{ 19, "CLEAR_BUILDING" },
	{ 20, "MOVE_BUILDING" },
	{ 21, "UPGRADE_BUILDING" },
	{ 22, "UPGRADE_BUILDING_FINISH" },
	{ 23, "MAKE_CANCEL" },
	{ 24, "GET_BACKPACK" },
	{ 25, "GET_POSITION" },
	{ 26, "GET_TREE_LIST" },
	{ 27, "GET_GRASS_LIST" },
	{ 28, "GET_MULTI_BLOCK_RESOURCE_LIST" },
	{ 29, "GET_FARM_LIST" },
	{ 30, "GET_PICKABLE_LIST" },
	{ 31, "ITEM_DROP" },
	{ 32, "FISHING_CALLBACK" },
	{ 33, "CATCH_CRABS_CALLBACK" },
	{ 34, "GET_CATCH_CRABS_TASK_LIST" },
	{ 35, "GET_MAKE_TASK_LIST" },
	{ 36, "GET_BUILDING_LIST" },
	{ 37, "GET_NPC_LIST" },
	{ 38, "TALK" },
	{ 39, "BUILDING_BUILD_CALLBACK" },
	{ 40, "GET_TREE_STUMP_LIST" },
	{ 41, "SEND_CHARACTER_CARD_GIFTS" },
	{ 42, "REQUEST_CHARACTER_CARD_GIFTS" },
	{ 43, "REQUEST_NPC_GIFTS" },
	{ 44, "BUY_ITEM" },
	{ 45, "SELL_ITEM" },
	{ 46, "BUY_ANIMAL" },
	{ 47, "PLACE_ANIMAL" },
	{ 48, "HARVEST_ANIMAL" },
	{ 49, "ADD_FEED" },
	{ 50, "SWITCH_PRODUCT" },
	{ 51, "HATCH" },
	{ 52, "FINISH_HATCH" },
	{ 53, "ACCEPT_MISSION" },
	{ 54, "FINISH_MISSION" },
	{ 55, "GET_FINISH_MISSION_LIST" },
	{ 56, "HARVEST_EGG" },
	{ 57, "GET_MISSION_LIST" },
	{ 58, "CHECK_IN" },
	{ 59, "ADD_FEED_BIN" },
	{ 60, "DESTROY_ITEM" },
	{ 61, "DESTROY_BOX_ITEM" },
	{ 62, "TASK_DIALOGUE" },
	{ 63, "SUBMIT_ITEM" },
	{ 64, "CLEAR_HANGING_DECORATION" },
	{ 65, "CLEAR_COAT_HANGER" },
	{ 66, "SUBMIT_TREASURES" },
	{ 67, "GET_TREASURES" },
	{ 68, "GET_MAP_ID_LIST" },
	{ 69, "GET_PORTAL_LIST" },
	{ 70, "CARD_UPGRADE_CALLBACK" },
	{ 71, "INIT_MAP" },
	{ 72, "ECHO" },
	{ 73, "GET_HANGING_DECORATION_LIST" },
	{ 74, "GET_CURRENT_CARD" },
	{ 75, "SET_CURRENT_CARD" },
	{ 76, "GET_FOLLOW_LIST" },
	{ 77, "GET_TROUGH" },
	{ 78, "GET_ANIMAL_LIST" },
	{ 79, "GET_HATCH_TASK_LIST" },
	{ 80, "GET_FEED_BIN" },
	{ 81, "GET_TRADE_LIST" },
	{ 82, "GET_ROOM" },
	{ 83, "NEW_NPC_CALLBACK" },
	{ 84, "NPC_CHECK_IN_CALLBACK" },
	{ 85, "CARD_CHECK_OUT" },
	{ 86, "BULLETIN_BOARD_CONVERSION" },
	{ 87, "GET_BULLETIN_BOARD_ITEM_LIST" },
	{ 88, "INVITED_EAT" },
	{ 89, "REWARD_CALLBACK" },
	{ 90, "CHANGE_NPC_TALK_PROGRESS" },
	{ 91, "CHANGE_CARD_TALK_PROGRESS" },
	{ 92, "TALK_CARD" },
	{ 93, "REFRESH_BULLETIN_BOARD" },
	{ 94, "GET_SIGN_BOARD" },
	{ 95, "SET_SIGN_BOARD" },
	{ 96, "TASK_DIALOGUE_PROGRESS" },
	{ 97, "BIRDS_TROUBLE_UPDATE" },
	{ 98, "BIRDS_TROUBLE_UPDATE_CALLBACK" },
	{ 99, "UPDATE_TROUGH" },
	{ 100, "SLEEP" },
	{ 101, "WAKE_UP" },
	{ 102, "GET_SLEEP_TASK_LIST" },
	{ 103, "GET_SEED_COUNT" },
	{ 104, "GET_POST_RANDOM_CHARACTER" },
	{ 105, "TREE_CALLBACK" },
	{ 106, "RESOURCE_CALLBACK" },
	{ 107, "SET_MISSION_TRACKING_LIST" },
	{ 108, "GET_MISSION_TRACKING_LIST" },
	{ 109, "RENEWAL_POST_ROOM" },
	{ 110, "CANCEL_FISHING" },
	{ 111, "GET_HANGER_MAP" },
	{ 112, "GET_MAP_SIZE" },
	{ 113, "GET_VISITING_USER_INFORMATION" },
	{ 114, "START_VISITING_TASK" },
	{ 115, "GET_VISITING_TASK_LIST" },
	{ 116, "START_VISITING" },
	{ 117, "STOP_VISITING" },
	{ 118, "FINISH_VISITING_TASK" },
	{ 119, "GET_LIMIT_ROOM" },
	{ 120, "GET_FRIEND_LIST"}, //获取好友列表
	{ 121, "REQUEST_FRIEND"},
	{ 122, "REQUEST_FRIEND_CALLBACK"},
	{ 123, "CHANGE_USERNAME" },
	{ 124, "GET_AVATAR_LIST" },
	{ 125, "CHANGE_AVATAR" },
	{ 126, "ACCEPT_FRIEND_REQUEST" },
	{ 127, "GET_PENDING_FRIEND_LIST" }, //获取好友申请列表
	{ 128, "REMOVE_FRIEND" },
	{ 129, "GET_TALK_LIST" },
	{ 130, "GET_MESSAGE_LIST" },
	{ 131, "SEND_MESSAGE" },
	{ 132, "MESSAGE_CALLBACK" },
	{ 133, "GET_NIGHT_MARKET_GOODS_LIST" },
	{ 134, "BUY_NIGHT_MARKET_GOODS" },
	{ 135, "BUY_NIGHT_MARKET_GOODS_CALLBACK" },
	{ 136, "SEND_FRIEND_COIN" },
	{ 137, "COLLECT_SINGLE_FRIEND_COIN" },
	{ 138, "COLLECT_ALL_FRIEND_COIN"},
	{ 139, "UPLOAD_MUTUAL_MARKET_GOODS" },
	{ 140, "GET_MUTUAL_MARKET_GOODS_LIST" },
	{ 141, "BUY_MUTUAL_MARKET_GOODS" },
	{ 142, "ID_INFO_CALLBACK"},
	{ 143, "GET_ALL_CHARACTER_CARD_POOL" },
	{ 144, "CHARACTER_CARD_POOL_LOTTERY" },
	{ 145, "DE_LISTING_MUTUAL_MARKET_GOODS" },
	{ 146, "BUY_MUTUAL_MARKET_GOODS_CALLBACK" },
	{ 147, "DE_LISTING_MUTUAL_MARKET_GOODS_CALLBACK" },
	{ 148, "BUY_PRODUCT" },
	{ 149, "GET_PENDING_REWARD_LIST" },
	{ 150, "RECEIVE_PENDING_REWARD" },
	{ 151, "GET_PRODUCT_LIST" },
	{ 152, "BUY_PRODUCT_SUCCESS_CALLBACK" },
	{ 153, "CANCEL_ORDER" },
	{ 154, "GET_MAIL_LIST" },
	{ 155, "READ_MAIL" },
	{ 156, "RECEIVE_MAIL_ITEMS"},
	{ 157, "DELETE_MAIL" },
	{ 158, "RECEIVE_MAIL_CALLBACK" },
	{ 159, "SAVE_ITEM_INBOX" },
	{ 160, "FETCH_ITEM_INBOX" },
	{ 161, "GET_ITEM_INBOX" },
	{ 162, "GET_CARPET_POSITION_LIST" },
	{ 163, "CHANGE_MAP_BLOCK" },
	{ 164, "GET_ACHIEVEMENT_LIST" },
	{ 165, "RECEIVE_ACHIEVEMENT_ITEMS" },
	{ 166, "WEAR_TREASURES" },
	{ 167, "UNLOAD_TREASURES" },
	{ 168, "CARD_UPGRADE" },
	{ 169, "TREASURE_UPGRADE" },
	{ 170, "GET_TREASURE_LIST" },
	{ 171, "USE_ITEM_WITH_CARD" },
	{ 172, "GET_BOX_POSITION_LIST" },
	{ 173, "GET_VISITING_FRIEND_INFORMATION" },
	{ 174, "MAKE_ACCELERATION" },
	{ 175, "GET_VISITING_HISTORY_LIST" },
	{ 176, "GET_MAKE_LIMIT_LIST" },
	{ 177, "GET_WALLPAPER_LIST" },
	{ 178, "CLEAR_WALLPAPER" },
	{ 179, "GET_FLOWER_LIST" },
	{ 180, "GET_LAST_VISITING_TIME" },
	{ 181, "ADD_FODDER_PET_HOUSE" },
	{ 182, "PET_EAT_ITEM" },
	{ 183, "GET_PET_HOUSE_LIST" },
	{ 184, "GET_PET_LIST" },
	{ 185, "CARESS_PET" },
	{ 186, "BUY_PET" },
	{ 187, "PLACE_PET" },
	{ 188, "BEAST_TROUBLE_UPDATE" },
	{ 189, "BEAST_TROUBLE_UPDATE_CALLBACK" },
	{ 190, "PET_FOLLOW" },
	{ 191, "PET_GIFT" },
	{ 192, "GET_PET_FOLLOW_LIST" },
	{ 193, "SEARCH_USER" },
	{ 194, "STAGE_CARD_SING" },
	{ 195, "GET_SING_CARD_LIST" },
	{ 196, "GET_STAGE_LIST" },
	{ 197, "GET_RECIPE_ID_LIST" },
	{ 198, "CLIENT_TOAST_CALLBACK" },
	{ 199, "CARD_GET_SPA_BUFF" },
	{ 200, "GET_CARD_BUFF_LIST" },
	{ 201, "CARD_GET_PRAY_BUFF" },
	{ 202, "GET_BATH_HOUSE_LIST" },
	{ 203, "GET_FAIRY_CAVE_LIST" },
	{ 204, "REJECT_FRIEND_APPLICATION" },
	{ 205, "ADD_FRIEND_CALLBACK" },
	{ 206, "PETTING_ANIMALS" },
	{ 207, "DISASSEMBLE" },
	{ 208, "GET_MAKE_HISTORY" },
	{ 209, "FLOWER_CALLBACK" },
	{ 210, "GET_USER_INFO" },
	{ 211, "FLOWER_BIRDS_TROUBLE_CALLBACK" },
	{ 212, "GET_LOTTERY_CONTEXT"},
	{ 213, "FINISH_ENTRUST" },
	{ 214, "REFRESH_ENTRUST" },
	{ 215, "GET_DISPATCH_CENTER_ENTRUST" },
	{ 216, "GET_PENDING_FRIEND_COIN"},
	{ 217, "GET_PET_HOUSE_DATA"},
	{ 218, "GET_PET_DATA"},
	{ 219, "REFRESH_PET_PET_HOUSE_CALLBACK"},
	{ 220, "REFRESH_PET_HOUSE_CALLBACK" },
	{ 221, "UPDATE_PET_NAME"},
	{ 222, "NEW_CHARACTER_CARD_POOL_LOTTERY"},
	{ 223, "DISPATCH_CENTER_CALLBACK"},
	{ 224, "CARD_GET_DOJO_PRAY_BUFF" },
	{ 225, "USER_STATE_CALLBACK" },
	{ 226, "JEWELRY_BOX" },
	{ 227, "ENTER_GAMEBOX_CALLBACK" },
	{ 228, "GET_FAIRY_DOJO" },
	{ 229, "GAMEBOX_MOVE_CALLBACK"},
	{ 230, "EXIT_GAMEBOX_CALLBACK"},
	{ 231, "KNOCK_ANIMAL"},
	{ 232, "GET_PRODUCT_LIMIT" },
	{ 233, "GET_GAMEBOX_PLAYER_LIST"},
	{ 234, "UNLOCK_BACKPACK_GRID" },
	{ 235, "BACKPACK_ONE_KEY_SORT" },
	{ 236, "STATE_SYNC"},
	{ 237, "TRANSMITTING_CALLBACK"},
	{ 238, "REDEEM_ANIMAL_MEAT" },
	{ 239, "TABLE" },
	{ 240, "TREE_DIE_CALLBACK" },
	{ 241, "RESOURCE_DIE_CALLBACK" },
	{ 242, "GET_TABLE_DATA" },
	{ 243, "GET_JEWELRY_BOX_LIST" },
	{ 244, "JEWELRY_BOX_SWITCH" },
	{ 245, "USE_TOOL_CALLBACK" },
	{ 246, "FORCE_POS" },
	{ 247, "TREE_STUMP_DIE_CALLBACK" },
	{ 248, "POUR_WATER_CALLBACK" },
	{ 249, "PLANT_CALLBACK" },
	{ 250, "GAMEBOX_CARDCHANGE_CALLBACK" },
	{ 251, "ANTIADDICT_CALLBACK" },
	{ 252, "CANCEL_FISH_CALLBACK" },
	{ 253, "HARVEST_BROADCAST_CALLBACK" },
	{ 254, "GET_HUNTER_TASK_LIST" },
	{ 255, "FINISH_HUNTER_TASK" },
	{ 257, "HUNTING_CALLBACK" },
	{ 258, "GET_MAP_SCOPE_LIST" },
	{ 259, "READ_ALL_MAIL" },
	{ 260, "GET_COLLECTION_MAP" },
	{ 261, "GET_TEAM_DATA" },
	{ 262, "TEAM_INVITATION" },
	{ 263, "TEAM_DATA_CALLBACK" },
	{ 264, "HANDLE_TEAM_INVITATION" },
	{ 265, "REMOVE_TEAM_MEMBER" },
	{ 266, "HANDLE_TEAM_VOTE" },
	{ 267, "MISSION_DATA_CALLBACK" },
	{ 268, "MINE_ELEVATOR" },
	{ 269, "SET_TEAM_PERMISSION" },
	{ 270, "GET_PERMISSIONS" },
	{ 272, "VISIT_SHUWUJIA_MEMBER" },
	{ 273, "ENTER_SHUWUJIA" },
	{ 274, "SHUWUJIA_POSITION_CALLBACK" },
	{ 275, "GET_SHUWUJIA_POSITION" },
	{ 276, "EXIT_SHUWUJIA" },
	{ 277, "GET_SHUWUJIA_MEMBER" },
	{ 278, "TEAM_TRANSFER" },
	{ 279, "SET_TEAM_NAME" },
	{ 280, "GET_RECYCLE_LIST" },
	{ 281, "RECYCLE_CALLBACK" },
	{ 282, "RECYCLE_ALL" },
	{ 284, "ENTER_MINE_CAVES" },
	{ 285, "GET_MINE_CAVES_MAP" },
	{ 286, "UNLOCK" },
	{ 287, "MINE_CAVES_MAP_BLOCK_DATA_CALLBACK" },
	{ 288, "EXIT_MINE_MAP" },
	{ 291, "GET_TEAM_INVITATION" },
	{ 292, "GET_VOTE_RESULT" },
	{ 293, "GET_DAILY_MISSION" },
	{ 294, "GET_MEMBER_PERMISSION" },
	{ 295, "SET_SHUWUJIA_SIGNATURE" },
	{ 298, "LIGHT_THE_LAMP" },
	{ 299, "GET_UNLOCKED_SCOPE" },
	{ 300, "UNLOCK_SCOPE" },
	{ 301, "UNLOCK_SCOPE_CALLBACK" },
	{ 302, "GET_TEAM_LOG" },
	{ 303, "GET_LIGHT_STATE" },
	{ 304, "OPEN_ORE_CHESTS" },
	{ 305, "MINE_CAVES_PUSH_STONES" },
	{ 306, "GET_OWNER_PERMISSIONS" },
	{ 307, "RECYCLE_VISITING_RECYCLE" },
	{ 308, "GET_MINE_CAVES_DATE" },
	{ 309, "RECEIVE_COLLECTION_MISSION_REWARD" },
	{ 310, "GET_COLLECTION_MISSION_STATE_LIST" },
	{ 311, "GET_COLLECTION_MISSION_DATA_LIST" },
	{ 312, "REMOVE_TREE_CALLBACK" },
	{ 314, "START_PARTY"},
	{ 315, "DELETE_READ_MAIL" },
	{ 316, "MINE_CAVES_CONFIG_DATA" },
	{ 317, "GET_NEW_STORE_NPC_NAMES" },
	{ 318, "USER_UPGRADE_CALLBACK" },
	{ 319, "SEND_TO_MAP" },
	{ 320, "SET_UNREAD" },
	{ 322, "REFRESH_DAILY_MISSIONS_CALLBACK" },
	{ 323, "GET_UPGRADE_UNLOCK_PROP_PROMPT" },
	{ 325, "GET_SINGLE_ITEM_COLLECTION_MISSION_LIST" },
	{ 326, "GET_SINGLE_ITEM_COLLECTION_MISSION_STATE" },
	{ 327, "RECEIVE_SINGLE_ITEM_COLLECTION_MISSION_REWARD" },
	{ 328 ,"SET_NOVICE_GUIDE"},
	{ 329 ,"GET_NOVICE_GUIDE"},
	{ 330 ,"TRANSFER_ARRAY_UNLOCK"},
	{ 331 ,"TRANSFER_ARRAY_TP"},
	{ 334 ,"GET_TRANSFER_ARRAY_DATA"},
	{ 338 ,"OPEN_TREASURE_BOX" },
	{ 339 ,"GET_TREASURE_BOX_LIST"},
	{ 346 ,"ARRIVE_MISSION_PLACE"},
	{ 347 ,"MAIL_BOX_UNLOCK"},
	{ 348 ,"GET_MAIl_BOX_DATA"},
	{ 349 ,"MINE_ORGAN_UNLCOK"},
	{ 350 ,"UNREAD_CALL_BACK"},
	{ 359 ,"GET_PROMPT_GUIDANCE_REWARDS"},
	{ 360 ,"OPEN_MINE_CAVES_DOOR"},
	{ 361 ,"MODIFY_STATS_CARD_SWITCH_LIST"},
	{ 362 ,"ITEM_ADD_TREASURES_LIST"},
	{ 363 ,"TREASURE_ADD_EXP"},
	{ 368 ,"GET_MUTUAL_MARKET_MONEY_BOX_DATA"},
	{ 370 ,"TAKE_MUTUAL_MARKET_MONEY_BOX"},
	{ 371 ,"GET_MINE_CAVES_MAO_ID_LIST"},
	{ 372 ,"RECEIVE_PROCESS_AWARD"},
	{ 374 ,"GET_MINE_ORGAN_LIST"},
	{ 375 ,"GET_MINE_DOOR_LIST"},
	{ 377 ,"GET_BED_DATA_LIST"},
	{ 378 ,"GET_CITY_MONEY_LIMIT"},
	{ 380 ,"GET_CARD_DISABLE"},
	{ 381 ,"CARD_REJOIN"},
	{ 383 ,"MINE_CAVES_BLOCK_CALLBACK"},
	{ 384 ,"GET_ALL_DATA"},
	{ 385 ,"GET_SHOP_SELL_MONEY_LIMIT"},
	{ 386 ,"GET_EVERY_DAY_SHOP_SELL_MONEY"},
	{ 387 ,"CHECK_BACKPACK"},
	{ 388 ,"CHECK_CITY"},
	{ 389 ,"GET_MUTUAL_MARKET_DATA"},
	{ 390 ,"GET_DOCK" },
	{ 391 ,"ACCELERATE_VISITING_TASK" },
	{ 392 ,"MAP_BLOCK_CHANGE_CALLBACK" },
	{ 393 ,"VISITING_LOCK_BUILDING_CALLBACK"},
	{ 394 ,"SEVEN_DAYS_SIGN_IN"},
	{ 395 ,"RE_DAILY_SIGN_IN"},
	{ 396 ,"CUMULATIVE_DAILY_SIGN_IN"},
	{ 397 ,"GET_SEVEN_DAYS_SIGN_IN_DATA"},
	{ 398 ,"GET_DAILY_SIGN_IN_DATA"},
	{ 1000, "AUTH" },

	{ 1001, "DEV_RESET" },
	{ 1002, "DEV_ADD_ITEM" },
	{ 1003, "DEV_ADD_ANIMAL" },
	{ 1004, "DEV_ACCELERATE_THE_HATCH" },
	{ 1005, "DEV_ACCELERATE_ANIMAL_GROWTH" },
	{ 1006, "DEV_CLOSE_WEBSOCKET" },
	{ 1007, "DEV_LOG" },
	{ 1008, "DEV_COMMAND" },
	{ 1009, "DEV_REWARD" },
	{ 1010, "DEV_TP" },
	{ 1011, "DEV_SEND_MAIL" },
	{ 1012, "DEV_MISSION" },
	{ 1013, "DEV_SET_BLOCK_DATA" },
	{ 1014, "DEV_LOG_ONLINE_USER" },
	{ 1015, "DEV_CHANGE_BUILDING" },
	{ 1016, "DEV_CLEAR_AREA" },
	{ 1017, "DEV_CLEAR_ACCOUNT" },
	{ 1018, "DEV_ACCEPT_MISSION" },
	{ 1019, "DEV_ADD_CROP" },
	{ 1020, "DEV_GET_ALL_USERINFO" },
	{ 1021, "DEV_ACCELERATE_VISITING_TASK" },
	{ 1022, "CLIENT_RESTART" },
	{ 1027, "DEV_REMOVE_MISSION" },
	{ 1028, "DEV_CHANGE_AESTHETIC_DEGREE" },
	{ 1030, "DEV_GET_CARD" },
	{ 1033, "REMOVE_FINISH_MISSION" },

};

std::unordered_set<int> needCacheList = {
	GAMEBOX_MOVE_CALLBACK,
	SHUWUJIA_POSITION_CALLBACK,
	GET_SHUWUJIA_POSITION,
	GET_TEAM_DATA,
	TEAM_DATA_CALLBACK,
	HARVEST_BROADCAST_CALLBACK,
	USE_TOOL_CALLBACK,
	TREE_DIE_CALLBACK,
	RESOURCE_DIE_CALLBACK,
	TREE_STUMP_DIE_CALLBACK,
	POUR_WATER_CALLBACK,
	PLANT_CALLBACK,
	EXIT_GAMEBOX_CALLBACK,
	MINE_CAVES_MAP_BLOCK_DATA_CALLBACK,
	BUILDING_BUILD_CALLBACK,
	MAP_BLOCK_CHANGE_CALLBACK,
	ENTER_GAMEBOX_CALLBACK,
};

std::vector<ItemCheck> backpackCheck;
TownCheck townCheck;
const int clientToServerDirection[4] = { 0, 3, 1, 2 };
const int serverToClientDirection[4] = { 0, 2, 3, 1 };
WSManager* WSManager::instance = nullptr;
bool skipIdInfoCallback = false;
uint64_t authTimer;

bool backpackChecking = false;

void WSManager::onOpen(cocos2d::network::WebSocket* ws)
{
	connOpened = true;
	if (resetGame)
	{
		GetMainGame()->finishConnect();
	}
}

void WSManager::bindCallbacks()
{
	callbackMap[CHECK_BACKPACK] = CC_CALLBACK_1(WSManager::processCheckBackpack, this);
	callbackMap[CHECK_CITY] = CC_CALLBACK_1(WSManager::processCheckCity, this);
	callbackMap[MOVE] = CC_CALLBACK_1(WSManager::processMove, this);
	callbackMap[INIT_MAP] = CC_CALLBACK_1(WSManager::processInitMap, this);
	callbackMap[GET_MAP] = CC_CALLBACK_1(WSManager::processGetMap, this);
	callbackMap[USE_TOOL] = [](std::string& data) { if (data == "ERROR") GetPlayer()->clearWaitForReply(); };
	//callbackMap[REFRESH] = CC_CALLBACK_1(WSManager::processRefresh, this);
	callbackMap[HARVEST] = CC_CALLBACK_1(WSManager::processHarvest, this);
	callbackMap[PICK_UP] = CC_CALLBACK_1(WSManager::processPickUp, this);
	callbackMap[MAKE] = CC_CALLBACK_1(WSManager::processMake, this);
	callbackMap[MAKE_FINISH] = CC_CALLBACK_1(WSManager::processMakeFinish, this);
	callbackMap[FINISH_FISHING] = CC_CALLBACK_1(WSManager::processFinishFishing, this);
	callbackMap[FINISH_CATCHING] = CC_CALLBACK_1(WSManager::processFinishCatching, this);
	callbackMap[GET_CITY] = CC_CALLBACK_1(WSManager::processGetCity, this);
	callbackMap[GET_CITY_MONEY_LIMIT] = CC_CALLBACK_1(WSManager::processGetLevelLimitMoney, this);
	callbackMap[GET_CHARACTER_CARD_LIST] = CC_CALLBACK_1(WSManager::processGetCharacterCardList, this);
	callbackMap[GET_CHARACTER_CARD_QUEUE] = CC_CALLBACK_1(WSManager::processGetCharacterCardQueue, this);
	callbackMap[UPGRADE_BUILDING] = CC_CALLBACK_1(WSManager::processUpgradeBuilding, this);
	callbackMap[UPGRADE_BUILDING_FINISH] = CC_CALLBACK_1(WSManager::processUpgradeBuildingFinish, this);
	callbackMap[GET_BACKPACK] = [this](std::string& data) { this->processGetBackpack(data, false); };
	callbackMap[GET_POSITION] = CC_CALLBACK_1(WSManager::processGetPosition, this);
	callbackMap[UNLOCK_BACKPACK_GRID] = [this](std::string& data) { this->processUnlockBackpackGrid(data); };
	callbackMap[GET_TREE_LIST] = [this](std::string& data) { this->processGetTreeList(data, true); };
	callbackMap[GET_GRASS_LIST] = CC_CALLBACK_1(WSManager::processGetGrassList, this);
	callbackMap[GET_MULTI_BLOCK_RESOURCE_LIST] = [this](std::string& data) { this->processGetMultiBlockResourceList(data); };
	callbackMap[GET_FARM_LIST] = CC_CALLBACK_1(WSManager::processGetFarmList, this);
	callbackMap[GET_PICKABLE_LIST] = CC_CALLBACK_1(WSManager::processGetPickableList, this);
	callbackMap[ITEM_DROP] = CC_CALLBACK_1(WSManager::processItemDrop, this);
	callbackMap[FISHING_CALLBACK] = CC_CALLBACK_1(WSManager::processFishingCallback, this);
	callbackMap[CATCH_CRABS_CALLBACK] = CC_CALLBACK_1(WSManager::processCatchCrabsCallback, this);
	callbackMap[GET_CATCH_CRABS_TASK_LIST] = CC_CALLBACK_1(WSManager::processGetCatchCrabsTaskList, this);
	callbackMap[GET_MAKE_TASK_LIST] = CC_CALLBACK_1(WSManager::processGetMakeTaskList, this);
	callbackMap[GET_BUILDING_LIST] = CC_CALLBACK_1(WSManager::processGetBuildingList, this);
	callbackMap[GET_NPC_LIST] = CC_CALLBACK_1(WSManager::processGetNpcList, this);
	callbackMap[BUILDING_BUILD_CALLBACK] = CC_CALLBACK_1(WSManager::processBuildingBuildCallback, this);
	callbackMap[VISITING_LOCK_BUILDING_CALLBACK] = CC_CALLBACK_1(WSManager::processVisitingLockBuildingCallback, this);
	callbackMap[GET_TREE_STUMP_LIST] = CC_CALLBACK_1(WSManager::processGetStumpList, this);
	callbackMap[SEND_CHARACTER_CARD_GIFTS] = CC_CALLBACK_1(WSManager::processSendCharacterCardGifts, this);
	callbackMap[REQUEST_CHARACTER_CARD_GIFTS] = CC_CALLBACK_1(WSManager::processRequestGifts, this);
	callbackMap[REQUEST_NPC_GIFTS] = CC_CALLBACK_1(WSManager::processRequestGifts, this);
	callbackMap[HATCH] = CC_CALLBACK_1(WSManager::processHatch, this);
	callbackMap[FINISH_MISSION] = CC_CALLBACK_1(WSManager::processFinishMission, this);
	callbackMap[GET_FINISH_MISSION_LIST] = CC_CALLBACK_1(WSManager::processGetFinishMissionList, this);
	callbackMap[GET_MISSION_LIST] = CC_CALLBACK_1(WSManager::processGetMissionList, this);
	callbackMap[CLEAR_COAT_HANGER] = CC_CALLBACK_1(WSManager::processHarvest, this);
	callbackMap[GET_TREASURES] = CC_CALLBACK_1(WSManager::processGetTreasures, this);
	callbackMap[GET_MAP_ID_LIST] = CC_CALLBACK_1(WSManager::processGetMapIdList, this);
	callbackMap[GET_PORTAL_LIST] = CC_CALLBACK_1(WSManager::processGetPortalList, this);
	callbackMap[CARD_UPGRADE_CALLBACK] = CC_CALLBACK_1(WSManager::processCardUpgradeCallback, this);
	callbackMap[ECHO] = CC_CALLBACK_1(WSManager::processEcho, this);
	callbackMap[GET_HANGING_DECORATION_LIST] = CC_CALLBACK_1(WSManager::processGetHangingDecorationList, this);
	callbackMap[GET_FOLLOW_LIST] = CC_CALLBACK_1(WSManager::processGetFollowList, this);
	callbackMap[GET_TROUGH] = CC_CALLBACK_1(WSManager::processGetTrough, this);
	callbackMap[GET_ANIMAL_LIST] = CC_CALLBACK_1(WSManager::processGetAnimalList, this);
	callbackMap[GET_HATCH_TASK_LIST] = CC_CALLBACK_1(WSManager::processGetHatchTaskList, this);
	callbackMap[GET_FEED_BIN] = CC_CALLBACK_1(WSManager::processGetFeedBin, this);
	callbackMap[ADD_FEED] = CC_CALLBACK_1(WSManager::processAddFeedBin, this);
	callbackMap[ADD_FEED_BIN] = CC_CALLBACK_1(WSManager::processAddFeedBin, this);
	callbackMap[SAVE_ITEM_INBOX] = CC_CALLBACK_1(WSManager::processSaveItemInBox, this);
	callbackMap[GET_TRADE_LIST] = CC_CALLBACK_1(WSManager::processGetTradeList, this);
	callbackMap[GET_ROOM] = CC_CALLBACK_1(WSManager::processGetRoom, this);
	callbackMap[CHECK_IN] = CC_CALLBACK_1(WSManager::processCheckIn, this);
	callbackMap[CARD_CHECK_OUT] = CC_CALLBACK_1(WSManager::processCheckOut, this);
	callbackMap[GET_CURRENT_CARD] = CC_CALLBACK_1(WSManager::processGetCurrentCard, this);
	callbackMap[NEW_NPC_CALLBACK] = CC_CALLBACK_1(WSManager::processNewNpcCallback, this);
	callbackMap[NPC_CHECK_IN_CALLBACK] = CC_CALLBACK_1(WSManager::processNpcCheckinCallback, this);
	callbackMap[GET_BULLETIN_BOARD_ITEM_LIST] = CC_CALLBACK_1(WSManager::processGetBulletinBoardItemList, this);
	callbackMap[INVITED_EAT] = CC_CALLBACK_1(WSManager::processInvitedEat, this);
	callbackMap[REWARD_CALLBACK] = CC_CALLBACK_1(WSManager::processRewardCallback, this);
	callbackMap[GET_SIGN_BOARD] = CC_CALLBACK_1(WSManager::processGetSignBoard, this);
	callbackMap[SET_SIGN_BOARD] = CC_CALLBACK_1(WSManager::processGetSignBoard, this);
	callbackMap[BIRDS_TROUBLE_UPDATE_CALLBACK] = CC_CALLBACK_1(WSManager::processBirdsTroubleUpdate, this);
	callbackMap[BEAST_TROUBLE_UPDATE_CALLBACK] = CC_CALLBACK_1(WSManager::processBeastTroubleUpdate, this);
	callbackMap[GET_SEED_COUNT] = [](std::string& data) { GetMainGame()->setCumulativeSeed(stoi(data)); };
	callbackMap[TREE_CALLBACK] = CC_CALLBACK_1(WSManager::processTreeCallback, this);
	callbackMap[RESOURCE_CALLBACK] = CC_CALLBACK_1(WSManager::processResourceCallback, this);
	callbackMap[GET_MISSION_TRACKING_LIST] = CC_CALLBACK_1(WSManager::processGetMissionTrackingList, this);
	callbackMap[GET_HANGER_MAP] = CC_CALLBACK_1(WSManager::processGetHangerMap, this);
	callbackMap[GET_VISITING_USER_INFORMATION] = CC_CALLBACK_1(WSManager::processGetVisitingUserInformation, this);
	callbackMap[GET_VISITING_FRIEND_INFORMATION] = CC_CALLBACK_1(WSManager::processGetVisitingUserInformation, this);
	callbackMap[START_VISITING_TASK] = CC_CALLBACK_1(WSManager::processStartVisitingTask, this);
	callbackMap[GET_VISITING_TASK_LIST] = CC_CALLBACK_1(WSManager::processGetVisitingTaskList, this);
	callbackMap[START_VISITING] = CC_CALLBACK_1(WSManager::processStartVisiting, this);
	callbackMap[STOP_VISITING] = CC_CALLBACK_1(WSManager::processStopVisiting, this);
	callbackMap[GET_LIMIT_ROOM] = CC_CALLBACK_1(WSManager::processGetLimitRoom, this);
	callbackMap[BUY_ITEM] = CC_CALLBACK_1(WSManager::processBuyItemCallback, this);
	callbackMap[SELL_ITEM] = CC_CALLBACK_1(WSManager::processSellItemCallback, this);
	callbackMap[BUY_ANIMAL] = CC_CALLBACK_1(WSManager::processBuyAnimalCallback, this);
	callbackMap[GET_SHOP_SELL_MONEY_LIMIT] = [](std::string& data) { GetShopSystem()->processGetShopSellMoneyLimit(data); };
	callbackMap[GET_EVERY_DAY_SHOP_SELL_MONEY] = [](std::string& data) { GetShopSystem()->processGetShopSellMoney(data); };
	callbackMap[GET_NIGHT_MARKET_GOODS_LIST] = CC_CALLBACK_1(WSManager::processGetNightMarketGoodsList, this);
	callbackMap[BUY_NIGHT_MARKET_GOODS_CALLBACK] = CC_CALLBACK_1(WSManager::processBuyNightMarketGoodsCallback, this);
	callbackMap[UPLOAD_MUTUAL_MARKET_GOODS] = CC_CALLBACK_1(WSManager::processUploadMutualMarketGoods, this);
	callbackMap[GET_MUTUAL_MARKET_GOODS_LIST] = CC_CALLBACK_1(WSManager::processGetMutualMarketGoodsList, this);
	callbackMap[GET_MUTUAL_MARKET_MONEY_BOX_DATA] = CC_CALLBACK_1(WSManager::processGetMutualMarketBoxMoney, this);
	callbackMap[GET_MUTUAL_MARKET_DATA] = CC_CALLBACK_1(WSManager::processGetFriendMutualMarketGoods, this);
	callbackMap[ID_INFO_CALLBACK] = CC_CALLBACK_1(WSManager::processIdInfoCallback, this);
	callbackMap[CHARACTER_CARD_POOL_LOTTERY] = CC_CALLBACK_1(WSManager::processCharacterCardPoolLottery, this);
	callbackMap[DE_LISTING_MUTUAL_MARKET_GOODS] = CC_CALLBACK_1(WSManager::processDelistMutualMarketGoods, this);
	callbackMap[BUY_MUTUAL_MARKET_GOODS_CALLBACK] = CC_CALLBACK_1(WSManager::processBuyMutualMarketGoodsCallback, this);
	callbackMap[DE_LISTING_MUTUAL_MARKET_GOODS_CALLBACK] = CC_CALLBACK_1(WSManager::processDelistingMutualMarketGoodsCallback, this);
	callbackMap[GET_CARPET_POSITION_LIST] = CC_CALLBACK_1(WSManager::processGetCarpetPositionList, this);
	callbackMap[BUY_PRODUCT] = CC_CALLBACK_1(WSManager::processBuyProduct, this);
	callbackMap[GET_PENDING_REWARD_LIST] = CC_CALLBACK_1(WSManager::processedHaveMonthCard, this);
	callbackMap[RECEIVE_PENDING_REWARD] = CC_CALLBACK_1(WSManager::processedMonthCardDaily, this);
	callbackMap[GET_ITEM_INBOX] = CC_CALLBACK_1(WSManager::processGetItemInbox, this);
	callbackMap[TREASURE_UPGRADE] = CC_CALLBACK_1(WSManager::processTreasureUpgrade, this);
	callbackMap[GET_TREASURE_LIST] = CC_CALLBACK_1(WSManager::processGetTreasureList, this);
	callbackMap[ITEM_ADD_TREASURES_LIST] = CC_CALLBACK_1(WSManager::processGetTreasureId, this);
	callbackMap[TREASURE_ADD_EXP] = CC_CALLBACK_1(WSManager::processGetUpgradeAccessoryLevel, this);
	callbackMap[GET_BOX_POSITION_LIST] = CC_CALLBACK_1(WSManager::processGetBoxPositionList, this);
	callbackMap[MAKE_ACCELERATION] = CC_CALLBACK_1(WSManager::processMakeAcceleration, this);
	callbackMap[GET_VISITING_HISTORY_LIST] = CC_CALLBACK_1(WSManager::processGetVisitingHistoryList, this);
	callbackMap[GET_MAKE_LIMIT_LIST] = CC_CALLBACK_1(WSManager::processGetMakeLimitList, this);
	callbackMap[GET_FLOWER_LIST] = [this](std::string& data) { processGetFlowerList(data, false); };
	callbackMap[GET_LAST_VISITING_TIME] = CC_CALLBACK_1(WSManager::processGetLastVisitingTime, this);
	callbackMap[ACCELERATE_VISITING_TASK] = [](std::string& data) { GetVisitSystem()->accelerateCallback(data); };
	callbackMap[GET_DOCK] = [](std::string& data) { GetVisitSystem()->setTradeCallback(data); };
	callbackMap[GET_RECIPE_ID_LIST] = CC_CALLBACK_1(WSManager::processGetRecipeIdList, this);
	callbackMap[CLIENT_TOAST_CALLBACK] = [](std::string& data) { MsgMgr::getInstance()->showMsg(data); };
	callbackMap[PETTING_ANIMALS] = CC_CALLBACK_1(WSManager::processedPettingAnimals, this);
	callbackMap[GET_MAKE_HISTORY] = CC_CALLBACK_1(WSManager::processGetMakeHistory, this);
	callbackMap[FLOWER_CALLBACK] = [this](std::string& data) { this->processGetFlowerList(data, true); };
	callbackMap[FLOWER_BIRDS_TROUBLE_CALLBACK] = CC_CALLBACK_1(WSManager::processFlowerBirdsTroubleCallback, this);
	//callbackMap[NEW_CHARACTER_CARD_POOL_LOTTERY] = CC_CALLBACK_1(WSManager::processNewCharacterCardPoolLottery, this);
	callbackMap[ENTER_GAMEBOX_CALLBACK] = CC_CALLBACK_1(WSManager::processEnterGameBox, this);
	callbackMap[GAMEBOX_MOVE_CALLBACK] = CC_CALLBACK_1(WSManager::processGameBoxMoveCallBack, this);
	callbackMap[EXIT_GAMEBOX_CALLBACK] = CC_CALLBACK_1(WSManager::processExitGameBoxCallBack, this);
	callbackMap[KNOCK_ANIMAL] = CC_CALLBACK_1(WSManager::processKnockAnimal, this);
	callbackMap[GET_PRODUCT_LIMIT] = CC_CALLBACK_1(WSManager::processGetProductLimit, this);
	callbackMap[GET_GAMEBOX_PLAYER_LIST] = CC_CALLBACK_1(WSManager::processGetGameBoxPlayerList, this);
	callbackMap[TRANSMITTING_CALLBACK] = CC_CALLBACK_1(WSManager::processTransmittingCallBack, this);
	callbackMap[TREE_DIE_CALLBACK] = CC_CALLBACK_1(WSManager::processTreeDieCallback, this);
	callbackMap[RESOURCE_DIE_CALLBACK] = CC_CALLBACK_1(WSManager::processResourceDieCallback, this);
	callbackMap[TREE_STUMP_DIE_CALLBACK] = CC_CALLBACK_1(WSManager::processTreeStumpDieCallback, this);
	callbackMap[POUR_WATER_CALLBACK] = CC_CALLBACK_1(WSManager::processPourWaterCallback, this);
	callbackMap[PLANT_CALLBACK] = CC_CALLBACK_1(WSManager::processPlantCallback, this);
	callbackMap[ANTIADDICT_CALLBACK] = CC_CALLBACK_1(WSManager::processAntiAddictCallback, this);
	callbackMap[USE_TOOL_CALLBACK] = CC_CALLBACK_1(WSManager::processUseToolCallback, this);
	callbackMap[CANCEL_FISH_CALLBACK] = CC_CALLBACK_1(WSManager::processCancelFishCallback, this);
	callbackMap[HARVEST_BROADCAST_CALLBACK] = CC_CALLBACK_1(WSManager::processHarvestBroadcastCallback, this);
	callbackMap[GET_TABLE_DATA] = CC_CALLBACK_1(WSManager::processGetTableList, this);
	callbackMap[GET_BED_DATA_LIST] = CC_CALLBACK_1(WSManager::processGetBedList, this);
	callbackMap[BACKPACK_ONE_KEY_SORT] = [this](std::string& data) { this->processGetBackpack(data, true); };
	callbackMap[GET_SLEEP_TASK_LIST] = [](std::string& data) { GetSleepManager()->processGetSleepData(data); };
	callbackMap[GET_HUNTER_TASK_LIST] = CC_CALLBACK_1(WSManager::processGetHuntingTrapTaskList, this);
	callbackMap[FINISH_HUNTER_TASK] = CC_CALLBACK_1(WSManager::processTakeHuntingTrapCallback, this);
	callbackMap[HUNTING_CALLBACK] = CC_CALLBACK_1(WSManager::processPutHuntingTrapCallback, this);
	callbackMap[REDEEM_ANIMAL_MEAT] = CC_CALLBACK_1(WSManager::processRedeemAnimalMeatCallback, this);
	callbackMap[GET_MAP_SCOPE_LIST] = CC_CALLBACK_1(WSManager::processGetMapScopeList, this);
	callbackMap[MISSION_DATA_CALLBACK] = CC_CALLBACK_1(WSManager::processMissionCallback, this);
	callbackMap[ENTER_SHUWUJIA] = CC_CALLBACK_1(WSManager::processPlayerGatheringPlacePosCallback, this);
	callbackMap[EXIT_SHUWUJIA] = CC_CALLBACK_1(WSManager::processPlayerGatheringPlacePosCallback, this);
	callbackMap[SHUWUJIA_POSITION_CALLBACK] = CC_CALLBACK_1(WSManager::processOtherMemberPosCallback, this);
	callbackMap[GET_SHUWUJIA_POSITION] = CC_CALLBACK_1(WSManager::processOtherMemberPos, this);
	callbackMap[GET_TEAM_DATA] = CC_CALLBACK_1(WSManager::processGetTeamData, this);
	callbackMap[GET_SHUWUJIA_MEMBER] = CC_CALLBACK_1(WSManager::processGetTeamMemberData, this);
	callbackMap[TEAM_DATA_CALLBACK] = CC_CALLBACK_1(WSManager::processTeamDataCallback, this);
	callbackMap[GET_TEAM_INVITATION] = CC_CALLBACK_1(WSManager::processGetInvitionList, this);
	callbackMap[GET_VOTE_RESULT] = CC_CALLBACK_1(WSManager::processGetVoteResultList, this);
	callbackMap[GET_MEMBER_PERMISSION] = CC_CALLBACK_1(WSManager::processGetMemberPermission, this);
	callbackMap[GET_RECYCLE_LIST] = [this](std::string& data) { this->processGetRecycleList(data, false); };
	callbackMap[RECYCLE_ALL] = [this](std::string& data) { this->processGetRecycleList(data, true); };
	callbackMap[RECYCLE_VISITING_RECYCLE] = CC_CALLBACK_1(WSManager::processRecycleSingle, this);
	callbackMap[GET_TEAM_LOG] = CC_CALLBACK_1(WSManager::processGetTeamLog, this);
	callbackMap[GET_OWNER_PERMISSIONS] = CC_CALLBACK_1(WSManager::processGetOwnerPermissions, this);
	callbackMap[AUTH] = CC_CALLBACK_1(WSManager::processAuth, this);
	callbackMap[DEV_COMMAND] = CC_CALLBACK_1(WSManager::processDevCommand, this);
	callbackMap[CLIENT_RESTART] = [this](std::string& data) { this->disconnect(); };
	callbackMap[GET_WEATHER_TIME] = CC_CALLBACK_1(WSManager::processWeatherTime, this);
	callbackMap[GET_SING_CARD_LIST] = CC_CALLBACK_1(WSManager::processGetCardList, this);
	callbackMap[GET_CARD_DISABLE] = CC_CALLBACK_1(WSManager::processGetDisableCardList, this);
	callbackMap[GET_STAGE_LIST] = CC_CALLBACK_1(WSManager::processGetStageAllData, this);
	callbackMap[VISIT_SHUWUJIA_MEMBER] = CC_CALLBACK_1(WSManager::processVisitShuwujiaMember, this);
	callbackMap[GET_PERMISSIONS] = CC_CALLBACK_1(WSManager::processGetShuwujiaPermissions, this);
	callbackMap[PERMISSIONS_CALLBACK] = CC_CALLBACK_1(WSManager::processUpdateShuwujiaPermissions, this);
	callbackMap[REMOVE_TREE_CALLBACK] = CC_CALLBACK_1(WSManager::processClearTree, this);
	callbackMap[MAP_BLOCK_CHANGE_CALLBACK] = CC_CALLBACK_1(WSManager::processEditMapBlock, this);
	//callbackMap[EXIT_SHUWUJIA] = CC_CALLBACK_1(WSManager::processExitShuwujia, this);
	callbackMap[ENTER_MINE_CAVES] = [](std::string& data) { GetMineController()->callBackEnterMine(data); };
	//	callbackMap[GET_MINE_CAVES_MAP] = [](std::string& data) { GetMineController()->callBackCreateMineMap(data); };
	callbackMap[GET_MINE_CAVES_MAP] = CC_CALLBACK_1(WSManager::processCreateMineData, this);

	callbackMap[MINE_CAVES_MAP_BLOCK_DATA_CALLBACK] = [](std::string& data) { GetMineController()->callBackUpdateMine(data); };
	callbackMap[GET_UNLOCKED_SCOPE] = CC_CALLBACK_1(WSManager::processGetUnlockedScope, this);
	callbackMap[UNLOCK_SCOPE_CALLBACK] = CC_CALLBACK_1(WSManager::processUnlockScopeCallback, this);
	callbackMap[LIGHT_THE_LAMP] = [](std::string& data) { GetLightController()->callBackLightOn(data); };
	callbackMap[GET_LIGHT_STATE] = [](std::string& data) { 	GetLightController()->callBackLightStateList(data); };

	callbackMap[UNLOCK] = [](std::string& data) { GetMineController()->callBackUnLock(data); };
	callbackMap[OPEN_ORE_CHESTS] = [](std::string& data) { GetMineController()->callBackopenChesh(data); };
	callbackMap[MINE_CAVES_PUSH_STONES] = [](std::string& data) { GetMineController()->callBackPushStone(data); };
	callbackMap[EXIT_MINE_MAP] = [](std::string& data) { GetMineController()->callBackExitMine(data); };
	callbackMap[MINE_ELEVATOR] = [](std::string& data) { GetMineController()->callBackEnterNextLayer(data); };
	callbackMap[GET_MINE_CAVES_DATE] = [](std::string& data) { GetMineController()->callBackMineData(data); };
	callbackMap[MINE_CAVES_CONFIG_DATA] = [](std::string& data) { GetMineController()->callBackGetReward(data); };
	callbackMap[GET_DAILY_MISSION] = [](std::string& data) { GetMailBoxSystem()->addMission(data); };
	//callbackMap[GET_NEW_STORE_NPC_NAMES] = [](std::string& data) { GetMailBoxSystem()->addNewArrival(data); };
	callbackMap[RECYCLE_CALLBACK] = [](std::string& data) { GetMailBoxSystem()->setRecycleItem(true); };
	callbackMap[REFRESH_DAILY_MISSIONS_CALLBACK] = [](std::string& data) { GetMailBoxSystem()->setDailyMission(true); };
	callbackMap[GET_UNREAD] = [](std::string& data) { GetCollectionSystem()->getUnreadList(data); };
	callbackMap[SLEEP] = CC_CALLBACK_1(WSManager::processSleep, this);
	callbackMap[GET_COLLECTION_MAP] = [](std::string& data) { GetCollectionSystem()->processGetCollectionData(data); };
	callbackMap[USER_UPGRADE_CALLBACK] = [](std::string& data) { GetCollectionSystem()->getPlayerLevel(data); };
	callbackMap[GET_UPGRADE_UNLOCK_PROP_PROMPT] = [](std::string& data) { GetCollectionSystem()->setPromptList(data); };
	callbackMap[GET_COLLECTION_MISSION_STATE_LIST] = [](std::string& data) { GetCollectionSystem()->processCollectionReceivedReward(data); };
	callbackMap[RECEIVE_COLLECTION_MISSION_REWARD] = [](std::string& data) { GetCollectionSystem()->processRewardCallback(data); };
	callbackMap[RECEIVE_SINGLE_ITEM_COLLECTION_MISSION_REWARD] = [](std::string& data) { GetCollectionSystem()->processSingleRewardCallback(data); };
	callbackMap[GET_SINGLE_ITEM_COLLECTION_MISSION_STATE] = [](std::string& data) { GetCollectionSystem()->processSingleReceiveReward(data); };
	callbackMap[GET_ACHIEVEMENT_LIST] = [](std::string& data) { GetAchievementManager()->processGetAchievementData(data); };
	callbackMap[RECEIVE_ACHIEVEMENT_ITEMS] = [](std::string& data) { GetAchievementManager()->processReceiveAchievement(data); };
	callbackMap[GET_NOVICE_GUIDE] = [](std::string& data) { GetGuideController()->callBackGuidingList(data); };
	callbackMap[TRANSFER_ARRAY_TP] = CC_CALLBACK_1(WSManager::processTp, this);
	callbackMap[GET_TRANSFER_ARRAY_DATA] = CC_CALLBACK_1(WSManager::processTpInfo, this);
	callbackMap[RECYCLE_BOX_ITEM] = [](std::string& data) { GetRecycleManager()->processGetRecycleData(data); };
	callbackMap[SET_CHARACTER_CARD_QUEUE] = [](std::string& data) { GetCharacterSystem()->processSetCurrentCard(data); };
	callbackMap[RECEIVE_DIALOGUE_APPROVE] = CC_CALLBACK_1(WSManager::processDialogueApprove, this);
	callbackMap[GET_ALL_DATA] = CC_CALLBACK_1(WSManager::processMapAllData, this);
	callbackMap[TRANSFER_ARRAY_UNLOCK] = CC_CALLBACK_1(WSManager::processUnLockTpCallbakk, this);

	callbackMap[ARRIVE_MISSION_PLACE] = CC_CALLBACK_1(WSManager::processMissionPlace, this);
	callbackMap[MAIL_BOX_UNLOCK] = CC_CALLBACK_1(WSManager::processMailUnlock, this);
	callbackMap[GET_MAIl_BOX_DATA] = CC_CALLBACK_1(WSManager::processMailInfo, this);
	callbackMap[GET_TREASURE_BOX_LIST] = CC_CALLBACK_1(WSManager::processGetTreasureInfo, this);
	callbackMap[UNREAD_CALL_BACK] = CC_CALLBACK_1(WSManager::processCustomRedPoint, this);
	callbackMap[GET_MINE_CAVES_MAO_ID_LIST] = CC_CALLBACK_1(WSManager::processGetMineMapIdList, this);
	callbackMap[GET_MINE_ORGAN_LIST] = [](std::string& data) { GetMineController()->callBackGetGearInfo(data); };
	callbackMap[GET_MINE_CAVES_UNLOCK_CONFIG] = [](std::string& data) { GetMineController()->callBackGetMineConfig(data); };
	callbackMap[GET_MINE_DOOR_LIST] = [](std::string& data) { GetMineController()->callBackGetDoorInfo(data); };
	callbackMap[OPEN_MINE_CAVES_DOOR] = [](std::string& data) { GetMineController()->callBackOpenDoor(data); };
	callbackMap[MINE_CAVES_BLOCK_CALLBACK] = [](std::string& data) { GetMineController()->callBackGetPushMineBlock_10(data); };
	callbackMap[ACCEPT_MISSION] = [](std::string& data) { GetMissionSystem()->callBackStartMission(data); };

	callbackMap[SUBMIT_TREASURES] = CC_CALLBACK_1(WSManager::processSubmitTreasures, this);

	callbackMap[GET_SEVEN_DAYS_SIGN_IN_DATA] = [](std::string& data) {GetSignInSystem()->processGetSevenDays(data, true); };
	callbackMap[GET_DAILY_SIGN_IN_DATA] = [](std::string& data) {GetSignInSystem()->processGetMonth(data, false); };
	callbackMap[RE_DAILY_SIGN_IN] = [](std::string& data) {GetSignInSystem()->processGetMonth(data, true); };
	callbackMap[SEVEN_DAYS_SIGN_IN] = [](std::string& data) {GetSignInSystem()->processGetSevenDays(data, false);  };

}

void WSManager::onMessage(cocos2d::network::WebSocket* ws, const cocos2d::network::WebSocket::Data& data)
{
	try {
		std::string wsStr;
		size_t dataLen = data.len;
		bool isGzip = ZipUtils::isGZipBuffer((unsigned char*)data.bytes, dataLen);
		unsigned char* unpackedData = nullptr;

		if (isGzip) {
			size_t unpackedLen = ZipUtils::inflateMemory((unsigned char*)data.bytes, dataLen, &unpackedData);
			wsStr.resize(unpackedLen);
			memcpy(const_cast<char*>(wsStr.data()), unpackedData, unpackedLen);
			free(unpackedData);
		}
		else {
			wsStr.resize(dataLen);
			memcpy(const_cast<char*>(wsStr.data()), data.bytes, dataLen);
		}

		WSCommand cmd;
		std::string cmdData;

		if (!wsStr.compare("ERROR")) {
			CCLOG("%s", wsStr.c_str());
			return;
		}

		cmd = (WSCommand)atoi(wsStr.substr(0, 4).c_str());
		int iiii = cmd;
		cmdData = wsStr.substr(5);

		if (GetMainGame()->isInMainGame() || needCacheList.count(cmd) == 0)
		{
			LuaNetMgr::getInstance()->dealMsg(cmd, cmdData);

			if (cmd != WSCommand::PING)
				CCLOG("%s %s", commandNames[cmd].c_str(), cmdData.c_str());

			EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_NET_COMMAND_DATA, (void*)wsStr.c_str(), wsStr.size() + 1);

			if (callbackMap.count(cmd) > 0)
				callbackMap[cmd](cmdData);
		}
		else
		{
			mCacheMsgQueue.push(wsStr);
		}
	}
	catch (exception ex) {
		CCLOG("%s", ex.what());
	}
}

void WSManager::onClose(cocos2d::network::WebSocket* ws)
{
	while (!craftQueue.empty())
		craftQueue.pop();

	if (connOpened)
	{
		GetMainGame()->showResetView();
	}

	connOpened = false;
	resetGame = false;
	initMapCallback = false;
	CCLOG("WSManager::closed()");

	dynamic_cast<MainView*>(UIViewMgr::getInstance()->getView(uiType::UI_MAIN_VIEW))->loadingSwitchTimer(0.12f, true);

}

void WSManager::onError(cocos2d::network::WebSocket* ws, const cocos2d::network::WebSocket::ErrorCode& error)
{
	CCLOG("WSManager::error()");
}

void WSManager::init()
{
	if (instance == nullptr) {
		instance = new WSManager();
		instance->bindCallbacks();
	}
}

cocos2d::network::WebSocket::State WSManager::getWSState()
{
	if (ws == nullptr) {
		return network::WebSocket::State::CLOSED;
	}

	return ws->getReadyState();
}

void WSManager::connect()
{
	if (ws != nullptr && ws->getReadyState() == cocos2d::network::WebSocket::State::OPEN) {
		disconnect();
	}

	if (ws == nullptr)
		ws = new network::WebSocket();

	ws->init(*this, targetServer, nullptr, "cacert.pem");
}

void WSManager::disconnect()
{
	return;
	if (ws != nullptr) {
		ws->close();
		delete ws;
		ws = nullptr;
	}
}

void WSManager::processCacheQueue()
{
	while (mCacheMsgQueue.size() > 0)
	{
		WSCommand cmd;
		std::string cmdData;

		std::string wsStr = mCacheMsgQueue.front();
		mCacheMsgQueue.pop();
		cmd = (WSCommand)atoi(wsStr.substr(0, 4).c_str());
		cmdData = wsStr.substr(5);

		LuaNetMgr::getInstance()->dealMsg(cmd, cmdData);

		if (cmd != WSCommand::PING)
			CCLOG("%s %s", commandNames[cmd].c_str(), cmdData.c_str());

		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_NET_COMMAND_DATA, (void*)wsStr.c_str(), wsStr.size() + 1);

		if (callbackMap.count(cmd) > 0)
			callbackMap[cmd](cmdData);
	}
}

void WSManager::send(const std::string& message)
{
	std::lock_guard<std::mutex> lock(wsMutex);

	if (ws == nullptr || ws->getReadyState() != cocos2d::network::WebSocket::State::OPEN)
		connect();//
	int command = atoi(message.substr(0, 4).c_str());
	while (ws->getReadyState() != cocos2d::network::WebSocket::State::OPEN);

	CCLOG("SEND %s %s", commandNames[command].c_str(), message.substr(5).c_str());
	ws->send(message);
}

void WSManager::auth(const std::string& token)
{
	char buf[256];
	sprintf(buf, "%04d %s", WSCommand::AUTH, token.c_str());
	send(buf);
	authTimer = currentTimeMillis();
}

void WSManager::ping()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::PING);
	ws->send(buf);
}

uint64_t s_pick_up = 1;

void WSManager::sendPlayerPos(float x, float y)
{
	if (!GetPlayer()->movedSinceCheck()) {
		return;
	}

	//uint64_t currentTs = currentTimeMillis();
	//if (currentTs - s_pick_up >= 400)
	//{
	//	s_pick_up = currentTs;
	GetPlayer()->setServerMoveTimer(0);
	//}
	//else
	//	return;
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::MOVE, (int)x, (int)y);
	send(buf);

	GetPlayer()->setLastCheckPos(x, y);
}

void WSManager::sendPlayerPosJumpMap(float x, float y)
{
	//s_pick_up = currentTimeMillis();
	GetPlayer()->setServerMoveTimer(0);

	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::MOVE, (int)x, (int)y);
	send(buf);

	GetPlayer()->setLastCheckPos(x, y);
}

void WSManager::getPosition()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_POSITION);
	send(buf);
}

void WSManager::getBackpack()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_BACKPACK);
	send(buf);
}

void WSManager::getMap(int index)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_MAP, index);
	send(buf);
}

void WSManager::useItem(int backpackPos, int x, int y, int direction)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::USE_TOOL, backpackPos + 1, x, y, clientToServerDirection[direction]);
	send(buf);
}

void WSManager::getTreeList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_TREE_LIST, mapId);
	send(buf);
}

void WSManager::getGrassList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_GRASS_LIST, mapId);
	send(buf);
}

void WSManager::getRockList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_MULTI_BLOCK_RESOURCE_LIST, mapId);
	send(buf);
}

void WSManager::getFarmList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_FARM_LIST, mapId);
	send(buf);
}

void WSManager::refresh(int x1, int y1, int x2, int y2)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::REFRESH, x1, y1, x2, y2);
	send(buf);
}

void WSManager::getPickableList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_PICKABLE_LIST, mapId);
	send(buf);
}

void WSManager::pickUp(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::PICK_UP, id);
	send(buf);
}

void WSManager::treeFell(int treeId, int fellDirection)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::THE_TREE_FELL, treeId, fellDirection ? 2 : 3);
	send(buf);
}

void WSManager::finishFishing(int taskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::FINISH_FISHING, taskId);
	send(buf);
}

void WSManager::getCatchCrabsTaskList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_CATCH_CRABS_TASK_LIST, mapId);
	send(buf);
}

void WSManager::finishCatching(int taskId, Crabcage* cage)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::FINISH_CATCHING, taskId);
	send(buf);

	crabcageDeleteQueue.push(cage);
}

void WSManager::make(int characterId, int recipeId, int amount, int mapIndex, int buildingId, CraftQueue* queue)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d,%d", WSCommand::MAKE, characterId, recipeId, amount, mapIndex, buildingId);
	send(buf);

	craftQueue.push(queue);
}

void WSManager::getMakeTaskList()
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_MAKE_TASK_LIST);
	send(buf);
}

void WSManager::makeFinish(int taskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::MAKE_FINISH, taskId);
	send(buf);
}

void WSManager::makeCancel(int taskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::MAKE_CANCEL, taskId);
	send(buf);
}

void WSManager::assemble(int slotIdSrc, int slotIdDst)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::ASSEMBLE, slotIdSrc, slotIdDst);
	send(buf);
}

void WSManager::getBuildingList(int mapId, ItemType type)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_BUILDING_LIST, mapId, type);
	send(buf);
}

void WSManager::getNpcList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_NPC_LIST);
	send(buf);
}

void WSManager::talk(int npcId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::TALK, npcId);
	send(buf);
}

void WSManager::talkCard(int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::TALK_CARD, cardId);
	send(buf);
}
void WSManager::tp(int mapIndex, int buildingId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::TRANSFER_ARRAY_TP, buildingId, mapIndex);
	send(buf);
}
void WSManager::getSortBackpack()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::BACKPACK_ONE_KEY_SORT);
	send(buf);
}

void WSManager::unlockBackpackGrid()
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::UNLOCK_BACKPACK_GRID, (int)GetMainGame()->getUid());//随便传个id
	send(buf);
}

void WSManager::harvest(int x, int y)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::HARVEST, x, y);
	send(buf);
}

void WSManager::getTreeStumpList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_TREE_STUMP_LIST, mapId);
	send(buf);
}

void WSManager::getMineList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_MINE_CAVES_MAP, mapId);
	send(buf);
}

void WSManager::clearData(int uid)
{
	NoviceGuideMgr::getInstance()->clearAllSavedInfo();
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::DEV_RESET, uid);
	send(buf);
}

void WSManager::getCity()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_CITY);
	send(buf);
}

void WSManager::getLevelLimitMoneyData(int level)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_CITY_MONEY_LIMIT, level);
	send(buf);
}

void WSManager::getCharacterCardList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_CHARACTER_CARD_LIST);
	send(buf);
}

void WSManager::getCharacterCardQueue()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_CHARACTER_CARD_QUEUE);
	send(buf);
}

void WSManager::buyItem(int itemId, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::BUY_ITEM, itemId, amount);
	send(buf);
}

void WSManager::sellItem(int uniqueId, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::SELL_ITEM, uniqueId, amount);
	send(buf);
}

void WSManager::buyAnimal(int animalId, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::BUY_ANIMAL, animalId, amount);
	send(buf);
}

void WSManager::placeAnimal(int mapIndex, int buildingId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::PLACE_ANIMAL, mapIndex, buildingId);
	send(buf);
}

void WSManager::harvestAnimal(int animalId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::HARVEST_ANIMAL, animalId);
	send(buf);
}

void WSManager::addFeed(int buildingId, int mapIndex, int itemId, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::ADD_FEED, buildingId, mapIndex, itemId, amount);
	send(buf);
}

void WSManager::sendCharacterCardGifts(int itemId, int characterCardId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::SEND_CHARACTER_CARD_GIFTS, itemId, characterCardId);
	send(buf);
}

void WSManager::switchProduct(int animalId, int product)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::SWITCH_PRODUCT, animalId, product);
	send(buf);
}

void WSManager::hatch(int itemId, int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d", WSCommand::HATCH, itemId, buildingId, mapIndex);
	send(buf);
}

void WSManager::finishHatch(int taskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::FINISH_HATCH, taskId);
	send(buf);
}

void WSManager::acceptMission(int missionId)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用 mingtest
		return;
	}

	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::ACCEPT_MISSION, missionId);
	send(buf);
}

void WSManager::finishMission(int missionId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::FINISH_MISSION, missionId);
	send(buf);
}

void WSManager::getFinishMissionList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_FINISH_MISSION_LIST);
	send(buf);
}

void WSManager::harvestEgg(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::HARVEST_EGG, buildingId, mapIndex);
	send(buf);
}

void WSManager::getMissionList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_MISSION_LIST);
	send(buf);
}

void WSManager::checkIn(int cardId, int buildingId, int mapIndex, int roomIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::CHECK_IN, cardId, buildingId, mapIndex, roomIndex);
	send(buf);
}

void WSManager::addFeedBin(int buildingId, int mapIndex, int itemId, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::ADD_FEED_BIN, buildingId, mapIndex, itemId, amount);
	send(buf);
}

void WSManager::destroyItem(int uniqueId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::DESTROY_ITEM, uniqueId + 1);
	send(buf);
}

void WSManager::destroyBoxItem(int boxId, int itemId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::DESTROY_BOX_ITEM, boxId, itemId + 1);
	send(buf);
}

void WSManager::taskDialogue(int type, int id, int missionId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d", WSCommand::TASK_DIALOGUE, type, id, missionId);
	send(buf);
}

void WSManager::submitItem(int itemId, int count, int type, int id, int missionId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d,%d", WSCommand::SUBMIT_ITEM, itemId, count, type, id, missionId);
	send(buf);
}

void WSManager::clearHangingDecoration(int hid)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::CLEAR_HANGING_DECORATION, hid);
	send(buf);
}

void WSManager::clearCoatHanger(int x, int y)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::CLEAR_COAT_HANGER, x, y);
	send(buf);
}

void WSManager::submitTreasures(int uniqueId, int treasureRoomIndex, int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::SUBMIT_TREASURES, uniqueId + 1, treasureRoomIndex - 1, buildingId, mapIndex);
	send(buf);
}

void WSManager::getTreasures(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_TREASURES, buildingId, mapIndex);
	send(buf);
}

void WSManager::getKnockAnimal(int animalId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::KNOCK_ANIMAL, animalId);
	send(buf);
}

void WSManager::getStateSync(int x, int y, int direction)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d", WSCommand::STATE_SYNC, x, y, direction);
	send(buf);
}

void WSManager::getGameBoxPlayerList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_GAMEBOX_PLAYER_LIST);
	send(buf);
}

void WSManager::setCharacterCardQueue(const std::string& data, int currentSquadIndex, int newCurrentCardId)
{
	char buf[512];
	sprintf(buf, "%04d %s,%d,%d", WSCommand::SET_CHARACTER_CARD_QUEUE, data.c_str(), currentSquadIndex, newCurrentCardId);
	send(buf);
}

void WSManager::getMapIdList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_MAP_ID_LIST);
	send(buf);
}

void WSManager::getPortalList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_PORTAL_LIST);
	send(buf);
}

void WSManager::initMap()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::INIT_MAP);
	send(buf);
}

void WSManager::sendEcho(WSEcho echo)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::ECHO, echo);
	send(buf);
}

void WSManager::getHangingDecorationList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_HANGING_DECORATION_LIST, mapId);
	send(buf);
}

void WSManager::getFollowList()
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_FOLLOW_LIST);
	send(buf);
}

void WSManager::getTrough(int troughId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_TROUGH, troughId, mapIndex);
	send(buf);
}

void WSManager::getAnimalList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_ANIMAL_LIST);
	send(buf);
}

void WSManager::getHatchTaskList()
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_HATCH_TASK_LIST);
	send(buf);
}

void WSManager::getFeedBin(int feedBinId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_FEED_BIN, feedBinId, mapIndex);
	send(buf);
}

void WSManager::getTradeList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_TRADE_LIST);
	send(buf);
}

void WSManager::getRoom(int roomId, int mapIndex)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_ROOM, roomId, mapIndex);
	send(buf);
}

void WSManager::requestCardGifts(int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::REQUEST_CHARACTER_CARD_GIFTS, cardId);
	send(buf);
}

void WSManager::requestNpcGifts(int npcId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::REQUEST_NPC_GIFTS, npcId);
	send(buf);
}

void WSManager::changeNpcTalkProgress(int npcId, int dialogId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::CHANGE_NPC_TALK_PROGRESS, npcId, dialogId);
	send(buf);
}

void WSManager::changeCardTalkProgress(int cardId, int dialogId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::CHANGE_CARD_TALK_PROGRESS, cardId, dialogId);
	send(buf);
}

void WSManager::sendNpcgift(int itemId, int npcId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::SEND_NPC_GIFTS, itemId, npcId);
	send(buf);
}

void WSManager::cardCheckOut(int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::CARD_CHECK_OUT, cardId);
	send(buf);
}

void WSManager::taskDialogueProgress(int missionId, int talkTargetId, int talkProgress)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d", WSCommand::TASK_DIALOGUE_PROGRESS, missionId, talkTargetId, talkProgress);
	send(buf);
}

void WSManager::setCurrentCard(int cardId, int squadId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::SET_CURRENT_CARD, cardId, squadId);
	send(buf);
}

void WSManager::getCurrentCard()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_CURRENT_CARD);
	send(buf);
}

void WSManager::updateThrough(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::UPDATE_TROUGH, buildingId, mapIndex);
	send(buf);
}

void WSManager::getSeedCount()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_SEED_COUNT);
	send(buf);
}

void WSManager::moveItem(int source, int target)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::MOVE_ITEM, source + 1, target + 1);
	send(buf);
}

void WSManager::setMissionTrackingList(const char* data)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d %s", WSCommand::SET_MISSION_TRACKING_LIST, data);
	send(buf);
}

void WSManager::getMissionTrackingList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_MISSION_TRACKING_LIST);
	send(buf);
}

void WSManager::checkBackpack()
{
	if (backpackCheck.size() > 0) {
		return;
	}

	Item** blocks = GetBackpack()->getAll();

	for (int i = 0; i < BACKPACK_DATA_MAX; i++) {
		if (blocks[i] != nullptr) {
			backpackCheck.push_back(*blocks[i]);
		}
	}

	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::CHECK_BACKPACK, checkBackpackVersion);
	send(buf);
}

void WSManager::sendDebugLog(const std::string& str)
{
	char buf[256];
	sprintf(buf, "%04d %d,", WSCommand::DEV_LOG, (int)GetMainGame()->getUid());

	std::string outStr = buf + str;
	send(outStr);
}

void WSManager::birdsTroubleUpdate()
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d ", WSCommand::BIRDS_TROUBLE_UPDATE);
	send(buf);
}

void WSManager::beastTroubleUpdate()
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d ", WSCommand::BEAST_TROUBLE_UPDATE);
	send(buf);
}

void WSManager::checkTown()
{
	bool freshCheck = townCheck.townLevel == 0;

	memset(&townCheck, 0, sizeof(TownCheck));

	townCheck.townLevel = GetMainGame()->getTownLevel();
	townCheck.townExp = GetMainGame()->getTownExp();
	townCheck.beauty = GetMainGame()->getBeauty();
	townCheck.money = GetMainGame()->getMoney();
	townCheck.diamond = GetMainGame()->getDiamond();

	if (freshCheck) {
		char buf[256];
		sprintf(buf, "%04d %d", WSCommand::CHECK_CITY, checkCityVersion);
		send(buf);
	}
}

void WSManager::cancelFishing(int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::CANCEL_FISHING, cardId);
	send(buf);
}

void WSManager::getHangerMap(int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_HANGER_MAP, mapIndex);
	send(buf);
}

void WSManager::setSignBoard(int buildingId, int mapIndex, const std::string& name)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%s", WSCommand::SET_SIGN_BOARD, buildingId, mapIndex, name.c_str());
	send(buf);
}

void WSManager::getSignBoard(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_SIGN_BOARD, buildingId, mapIndex);
	send(buf);
}

void WSManager::putTableItem(int type, int tableid, int itemid, int gridx, int gridy, int direction)
{
	//type,放1，取2;itemid放发格子id,取发itemid;grid需要-1;
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d,%d,%d", WSCommand::TABLE, type, tableid, itemid, gridx, gridy, direction);
	send(buf);
}
void WSManager::getTableList(int buildingid, int mapindex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_TABLE_DATA, buildingid, mapindex);
	send(buf);
}
void WSManager::invitedEat(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::INVITED_EAT, buildingId, mapIndex);
	send(buf);
}

void WSManager::getBulletinBoardItemList(int buildingId, int mapIndex)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不打开公告栏
		return;
	}
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_BULLETIN_BOARD_ITEM_LIST, buildingId, mapIndex);
	send(buf);
}

void WSManager::bulletinBoardConversion(int bulletinBoardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::BULLETIN_BOARD_CONVERSION, bulletinBoardId);
	send(buf);
}

void WSManager::getVisitingUserInformation(int mapIndex, int buildingId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_VISITING_USER_INFORMATION, mapIndex, buildingId);
	send(buf);
}

void WSManager::StartVisitingTask(int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::START_VISITING_TASK, cardId);
	send(buf);
}

void WSManager::getVisitingTaskList(int mapIndex, int buildingId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_VISITING_TASK_LIST, mapIndex, buildingId);
	send(buf);
}

void WSManager::startVisiting(int visitingTaskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::START_VISITING, visitingTaskId);
	send(buf);
}

void WSManager::stopVisiting()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::STOP_VISITING);
	send(buf);
}

void WSManager::finishVisitingTask(int visitingTaskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::FINISH_VISITING_TASK, visitingTaskId);
	send(buf);
}

void WSManager::accelerateVisitingTask(int visitingTaskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::ACCELERATE_VISITING_TASK, visitingTaskId);
	send(buf);
}

void WSManager::getDock()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_DOCK);
	send(buf);
}

void WSManager::getPostRandomCharacter(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_POST_RANDOM_CHARACTER, buildingId, mapIndex);
	send(buf);
}

void WSManager::renewalPostRoom(int buildingId, int mapIndex, int roomIndex, int day)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::RENEWAL_POST_ROOM, buildingId, mapIndex, roomIndex, day);
	send(buf);
}

void WSManager::getLimitRoom(int roomId, int mapIndex)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_LIMIT_ROOM, roomId, mapIndex);
	send(buf);
}

void WSManager::getShopMoneyLimit(int level)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_SHOP_SELL_MONEY_LIMIT, level);
	send(buf);
}

void WSManager::getSellMoneyByShop()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_EVERY_DAY_SHOP_SELL_MONEY);
	send(buf);
}

void WSManager::getNightMarketGoodsList(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_NIGHT_MARKET_GOODS_LIST, buildingId, mapIndex);
	send(buf);
}

void WSManager::buyNightMarketGoods(int buildingId, int mapIndex, int goodsId, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::BUY_NIGHT_MARKET_GOODS, buildingId, mapIndex, goodsId, amount);
	send(buf);
}

void WSManager::uploadMutualMarketGoods(int buildingId, int mapIndex, int itemId, int itemAmount, int totalPrice, int mutualMarketGoodsId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d,%d,%d", WSCommand::UPLOAD_MUTUAL_MARKET_GOODS, buildingId, mapIndex, itemId, itemAmount, totalPrice, mutualMarketGoodsId);
	send(buf);
}

void WSManager::getMutualMarketGoodsList(int buildingId, int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_MUTUAL_MARKET_GOODS_LIST, buildingId, mapIndex);
	send(buf);
}

void WSManager::buyMutualMarketGoods(int buildingId, int mapIndex, int goodsId, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::BUY_MUTUAL_MARKET_GOODS, buildingId, mapIndex, goodsId, amount);
	send(buf);
}

void WSManager::getMutualMarketMoneyBox(int uid)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_MUTUAL_MARKET_MONEY_BOX_DATA, uid);
	send(buf);
}

void WSManager::receiveMarketBoxMoney(int buildingId, int money)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::TAKE_MUTUAL_MARKET_MONEY_BOX, buildingId, money);
	send(buf);
}

void WSManager::getMutualMarketFriendGoodsList(int64_t uid)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_MUTUAL_MARKET_DATA, (int)uid);
	send(buf);
}

void WSManager::delistingMutualMarketGoods(int mutualMarketGoodsId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::DE_LISTING_MUTUAL_MARKET_GOODS, mutualMarketGoodsId);
	send(buf);
}

void WSManager::getCarpetPositionList(int mapIndex)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_CARPET_POSITION_LIST, mapIndex);
	send(buf);
}

void WSManager::equitAccessory(int cardId, int backpackId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::WEAR_TREASURES, cardId, backpackId + 1);
	send(buf);
}

void WSManager::unequipAccessory(int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::UNLOAD_TREASURES, cardId);
	send(buf);
}

void WSManager::getTreasureList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_TREASURE_LIST);
	send(buf);
}

void WSManager::upgradeAccessory(int accessoryId, int backpackUniqueId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::TREASURE_UPGRADE, accessoryId, backpackUniqueId);
	send(buf);
}

void WSManager::upgradeAcdessoryLevel(int accessoryId, const std::string& backpackIds)
{
	char buf[256];
	sprintf(buf, "%04d %d,%s", WSCommand::TREASURE_ADD_EXP, accessoryId, backpackIds.c_str());
	send(buf);
}

void WSManager::addAccessory(int backpackUniqueId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::ITEM_ADD_TREASURES_LIST, backpackUniqueId + 1);
	send(buf);
}

void WSManager::getBoxPositionList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_BOX_POSITION_LIST);
	send(buf);
}

void WSManager::getItemInbox(int bid)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_ITEM_INBOX, bid);
	send(buf);
}

void WSManager::saveItemInbox(int sourcePosition, int bid, int targetPosition, int count)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::SAVE_ITEM_INBOX, sourcePosition + 1, bid, targetPosition + 1, count);
	send(buf);
}

void WSManager::fetchItemInbox(int sourcePosition, int bid, int targetPosition, int count)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::FETCH_ITEM_INBOX, sourcePosition + 1, bid, targetPosition + 1, count);
	send(buf);
}

void WSManager::useItemWithCard(int cardId, int backpackId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::USE_ITEM_WITH_CARD, cardId, backpackId + 1);
	send(buf);
}

void WSManager::getVisitingFriendInformation(int mapIndex, int buildingId, uint64_t friendUserId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d", WSCommand::GET_VISITING_FRIEND_INFORMATION, mapIndex, buildingId, (int)friendUserId);
	send(buf);
}

void WSManager::getVisitingHistoryList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_VISITING_HISTORY_LIST);
	send(buf);
}

void WSManager::makeAcceleration(int taskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::MAKE_ACCELERATION, taskId);
	send(buf);
}

void WSManager::getMakeLimitList()
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不用
		return;
	}

	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_MAKE_LIMIT_LIST);
	send(buf);
}

void WSManager::upgradeBuilding(int characterCardId, int buildingRecipeId, int mapIndex, int buildingId, CraftQueue* queue)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d,%d", WSCommand::UPGRADE_BUILDING, characterCardId, buildingRecipeId, mapIndex, buildingId, 1);
	send(buf);

	craftQueue.push(queue);
}

void WSManager::upgradeBuildingFinish(int upgradeTaskId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::UPGRADE_BUILDING_FINISH, upgradeTaskId);
	send(buf);
}

void WSManager::cardUpgrade(int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::CARD_UPGRADE, cardId);
	send(buf);
}

void WSManager::saveCardProperty(int build, int stamina, int trade, int craft, int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d,%d", WSCommand::MODIFY_STATS_CARD_SWITCH_LIST, build, stamina, trade, craft, cardId);
	send(buf);
}

void WSManager::getLastVisitingTime()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_LAST_VISITING_TIME);
	send(buf);
}

void WSManager::getRecipeIdList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_RECIPE_ID_LIST);
	send(buf);
}

void WSManager::devTp(int mapIndex, int x, int y)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::DEV_TP, (int)GetMainGame()->getUid(), mapIndex, x, y);
	send(buf);
}

void WSManager::devMission(int missionId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::DEV_MISSION, (int)GetMainGame()->getUid(), missionId);
	send(buf);
}

void WSManager::devDeleteFinishMission(int missionId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::REMOVE_FINISH_MISSION, (int)GetMainGame()->getUid(), missionId);
	send(buf);
}

void WSManager::devSetCityBeauty(int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::DEV_CHANGE_AESTHETIC_DEGREE, (int)GetMainGame()->getUid(), amount);
	send(buf);
}

void WSManager::disassemble(int backpackId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::DISASSEMBLE, backpackId + 1);
	send(buf);
}

void WSManager::getMakeHistory()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_MAKE_HISTORY);
	send(buf);
}

void WSManager::getFlowerList(int mapIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_FLOWER_LIST, mapIndex);
	send(buf);
}

void WSManager::changeMapBlock(int mapX, int mapY, int mapType)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d", WSCommand::CHANGE_MAP_BLOCK, mapX, mapY, mapType);
	send(buf);
}

void WSManager::checkCraftQueue()
{
	char buf[256];
	sprintf(buf, "%04d %d,%04d ", WSCommand::DEV_COMMAND, (int)GetMainGame()->getUid(), WSCommand::GET_MAKE_TASK_LIST);
	send(buf);
}

void WSManager::getFriendList(int uid)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_FRIEND_LIST, uid);
	send(buf);
}

void WSManager::changeUserName(std::string username)
{
	char buf[256];
	sprintf(buf, "%04d %s", WSCommand::CHANGE_USERNAME, username.c_str());
	send(buf);
}

void WSManager::pettingAnimals(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::PETTING_ANIMALS, id);
	send(buf);
}

void WSManager::sleep(int mapId, int buildingId, int cardId, int bedIndex)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d,%d", WSCommand::SLEEP, mapId, buildingId, cardId, bedIndex);
	send(buf);
	//sleeptologin = true;
}
void WSManager::wakeUp(int mapId, int buildingId, int cardId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d,%d", WSCommand::WAKE_UP, mapId, buildingId, cardId);
	send(buf);
}
void WSManager::isSleep()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_SLEEP_TASK_LIST);
	send(buf);
}

void WSManager::setPlayerAvatar(int cardid)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::CHANGE_AVATAR, cardid);
	send(buf);
}

void WSManager::getHuntingTrapList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_HUNTER_TASK_LIST);
	send(buf);
}

void WSManager::finishHungtingTrap(int taskId, HuntingTrap* trap)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::FINISH_HUNTER_TASK, taskId);
	send(buf);

	huntingTrapDeleteQueue.push(trap);
}

void WSManager::redeemMeat(int backpackid, int amount)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::REDEEM_ANIMAL_MEAT, backpackid, amount);
	send(buf);
}

void WSManager::getMapScopeList(int mapid)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_MAP_SCOPE_LIST, mapid);
	send(buf);
}

void WSManager::getWeatherTime()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_WEATHER_TIME);
	send(buf);
}

//戏台
void WSManager::getStageAllData()
{
	char buf2[256];
	sprintf(buf2, "%04d ", WSCommand::GET_STAGE_LIST);
	GetWSManager()->send(buf2);
}

void WSManager::getSocialTeamData()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_TEAM_DATA);
	GetWSManager()->send(buf);
}

void WSManager::invitaFriend(int friendId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::TEAM_INVITATION, friendId);
	GetWSManager()->send(buf);
}

void WSManager::getTeamMember()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_SHUWUJIA_MEMBER);
	GetWSManager()->send(buf);
}

void WSManager::handleTeamInvita(int teamId, int code)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::HANDLE_TEAM_INVITATION, teamId, code);
	GetWSManager()->send(buf);
}

void WSManager::handleTeamVote(int targetId, int code)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::HANDLE_TEAM_VOTE, targetId, code);
	GetWSManager()->send(buf);
}
void WSManager::enterGatheringPlace(int mapId, int buildingId)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::ENTER_SHUWUJIA, mapId, buildingId);
	GetWSManager()->send(buf);
}
void WSManager::getOtherMemberPos()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_SHUWUJIA_POSITION);
	GetWSManager()->send(buf);
}
void WSManager::exitGatheringPlace()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::EXIT_SHUWUJIA);
	GetWSManager()->send(buf);
}

void WSManager::getInvitationList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_TEAM_INVITATION);
	GetWSManager()->send(buf);
}

void WSManager::getVoteList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_VOTE_RESULT);
	GetWSManager()->send(buf);
}

void WSManager::setTeamName(const std::string& name)
{
	char buf[256];
	sprintf(buf, "%04d %s", WSCommand::SET_TEAM_NAME, name.c_str());
	GetWSManager()->send(buf);
}

void WSManager::removeTeamMember(int memberId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::REMOVE_TEAM_MEMBER, memberId);
	GetWSManager()->send(buf);
}

void WSManager::teamTransfer(int memberId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::TEAM_TRANSFER, memberId);
	GetWSManager()->send(buf);
}
void WSManager::getMemberPermission(int memberId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_MEMBER_PERMISSION, memberId);
	GetWSManager()->send(buf);
}

void WSManager::setMemberPermission(int memberId, const std::string& permitstr, int code)
{
	char buf[256];
	sprintf(buf, "%04d %d,%s,%d", WSCommand::SET_TEAM_PERMISSION, memberId, permitstr.c_str(), code);
	GetWSManager()->send(buf);
}

void WSManager::setTeamSignature(const std::string& str)
{
	char buf[256];
	sprintf(buf, "%04d %s", WSCommand::SET_SHUWUJIA_SIGNATURE, str.c_str());
	GetWSManager()->send(buf);
}

void WSManager::getRecycleList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_RECYCLE_LIST);
	GetWSManager()->send(buf);
}

void WSManager::RecycleAll()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::RECYCLE_ALL);
	GetWSManager()->send(buf);
}

void WSManager::GetTeamLog()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_TEAM_LOG);
	GetWSManager()->send(buf);
}

void WSManager::GetOwnerPermissions()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_OWNER_PERMISSIONS);
	GetWSManager()->send(buf);
}

void WSManager::recycleSingle(int recycleId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::RECYCLE_VISITING_RECYCLE, recycleId);
	GetWSManager()->send(buf);
}

void WSManager::getUnlockedScope()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_UNLOCKED_SCOPE);
	GetWSManager()->send(buf);
}

void WSManager::unlockScope(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::UNLOCK_SCOPE, id);
	GetWSManager()->send(buf);
}

void WSManager::visitShuwujiaMember(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::VISIT_SHUWUJIA_MEMBER, id);
	GetWSManager()->send(buf);
}

void WSManager::getShuwujiaPermissions()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_PERMISSIONS);
	GetWSManager()->send(buf);
}

void WSManager::partyInvitation(int lv, int time, std::vector<int>& list)
{
	long long ttt = time;
	ttt *= 1000;
	char buf[256];
	sprintf(buf, "%04d %d,%lld", WSCommand::PARTY_INVITATION, lv, ttt);
	string head = string(buf);

	for (size_t i = 0; i < list.size(); i++)
	{
		sprintf(buf, ",%d", list[i]);
		head = head + buf;
	}

	GetWSManager()->send(head);
}


void WSManager::agreePartyInvitation(int bo, int partyId)
{
	char buf[256];

	sprintf(buf, "%04d %d,%d", WSCommand::AGREE_PARTY_INVITATION, bo, partyId);
	GetWSManager()->send(buf);
}

void WSManager::endParty(int partyId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::END_PARTY, partyId);
	GetWSManager()->send(buf);
}

void WSManager::leaveShuwujia()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::EXIT_SHUWUJIA);
	GetWSManager()->send(buf);
}

void WSManager::startParty(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::START_PARTY, id);
	GetWSManager()->send(buf);
}

void WSManager::getDailyMission()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_DAILY_MISSION);
	GetWSManager()->send(buf);
}

void WSManager::getNewArrivalList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_NEW_STORE_NPC_NAMES);
	GetWSManager()->send(buf);
}

void WSManager::setUnread(const std::string& str, int unread)
{
	char buf[256];
	sprintf(buf, "%04d %s,%d", WSCommand::SET_UNREAD, str.c_str(), unread);
	GetWSManager()->send(buf);
}

void WSManager::getUnread()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_UNREAD);
	GetWSManager()->send(buf);
}

void WSManager::getPlayerUpgradePrompt(int level)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_UPGRADE_UNLOCK_PROP_PROMPT, level);
	GetWSManager()->send(buf);
}

void WSManager::getCollectionReceivedReward()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_COLLECTION_MISSION_STATE_LIST);
	GetWSManager()->send(buf);
}

void WSManager::getCollectionData()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_COLLECTION_MAP);
	GetWSManager()->send(buf);
}

void WSManager::getCollectionMissionData()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_COLLECTION_MISSION_DATA_LIST);
	GetWSManager()->send(buf);
}

void WSManager::setCollectionMissionReward(int missionId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::RECEIVE_COLLECTION_MISSION_REWARD, missionId);
	GetWSManager()->send(buf);
}

void WSManager::getCollectionSingleData()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_SINGLE_ITEM_COLLECTION_MISSION_LIST);
	GetWSManager()->send(buf);
}

void WSManager::getCollectioinSingleRewardList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_SINGLE_ITEM_COLLECTION_MISSION_STATE);
	GetWSManager()->send(buf);
}

void WSManager::getMineMapIdList()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_MINE_CAVES_MAO_ID_LIST);
	GetWSManager()->send(buf);
}

void WSManager::setCollectionSingleReward(int missionId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::RECEIVE_SINGLE_ITEM_COLLECTION_MISSION_REWARD, missionId);
	GetWSManager()->send(buf);
}

void WSManager::getSevenDaysSignIn()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_SEVEN_DAYS_SIGN_IN_DATA);
	GetWSManager()->send(buf);
}

void WSManager::getMonthDaysSignIn()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_DAILY_SIGN_IN_DATA);
	GetWSManager()->send(buf);
}

void WSManager::replenishDaySignIn(int day)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::RE_DAILY_SIGN_IN, day);
	GetWSManager()->send(buf);
}

void WSManager::cumulativeSignIn(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::CUMULATIVE_DAILY_SIGN_IN, id);
	GetWSManager()->send(buf);
}

void WSManager::sevenDaySignIn()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::SEVEN_DAYS_SIGN_IN);
	GetWSManager()->send(buf);
}

void WSManager::getGuideTipsReward(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_PROMPT_GUIDANCE_REWARDS, id);
	GetWSManager()->send(buf);
}

void WSManager::getRecycleBoxList(const std::string& str)
{
	char buf[256];
	sprintf(buf, "%04d %s", WSCommand::RECYCLE_BOX_ITEM, str.c_str());
	GetWSManager()->send(buf);
}

void WSManager::getAchievementData()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_ACHIEVEMENT_LIST);
	GetWSManager()->send(buf);
}

void WSManager::receiveAchievement(int id)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::RECEIVE_ACHIEVEMENT_ITEMS, id);
	GetWSManager()->send(buf);
}

void WSManager::getBedList(int mapId)
{
	char buf[256];
	sprintf(buf, "%04d %d", WSCommand::GET_BED_DATA_LIST, mapId);
	GetWSManager()->send(buf);
}

void WSManager::getLeaveSquad()
{
	char buf[256];
	sprintf(buf, "%04d ", WSCommand::GET_CARD_DISABLE);
	GetWSManager()->send(buf);
}
void WSManager::takeDialogueApprove(int missionId, int index)
{
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::RECEIVE_DIALOGUE_APPROVE, missionId, index);
	GetWSManager()->send(buf);
}


// ------------------------------------------------------------------------------------

void WSManager::processInitMap(const std::string& data)
{
	if (data == "OK") {
		initMapCallback = true;
	}
}

void WSManager::processMove(const std::string& data)
{
	if (!GetMainGame()->isInMainGame())
		return;

	vector<string> splitStr = splitStringByDelimiter(data, ",");
	int mapId = atoi(splitStr[0].c_str());
	int x = atoi(splitStr[1].c_str());
	int y = atoi(splitStr[2].c_str());
	GetPlayer()->validateServerPos(mapId, (float)x, (float)y);
}

void WSManager::processPickUp(const std::string& data)
{
	if (data == "OK") {
		GetMainGame()->checkBackpack();
	}

}

void WSManager::processGetPosition(const std::string& data)
{
	vector<string> splitStr = splitStringByDelimiter(data, ",");
	int mapId = atoi(splitStr[0].c_str());
	float x = (float)atof(splitStr[1].c_str());
	float y = (float)atof(splitStr[2].c_str());

	if (GetMainGame()->getCurrentMapId() == 0)
	{
		if (MineSystemController::getInstance()->checkIsMineMap(mapId) && mapId != 132)//如果是矿洞
		{
			MineSystemController::getInstance()->getAllMapData(mapId);
		}

		GetMainGame()->setCurrentMap(mapId);
	}
	else if (mapId != GetMainGame()->getCurrentMapId())
		GetMainGame()->setCurrentMap(mapId);

	GetPlayer()->setPos(Vec2(x, y));
}

void WSManager::processGetBackpack(const string& cmdData, bool isSortBackpack)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)cmdData.c_str());

	int activeItemId = -1;
	auto activeItem = GetBackpack()->getActive();
	if (activeItem)
	{
		activeItemId = activeItem->itemId;
	}

	Item** backpack = GetBackpack()->getAll();

	for (int i = 0; i < GetBackpackMax(); i++) {
		if (backpack && backpack[i] != nullptr) {
			delete backpack[i];
			backpack[i] = nullptr;
		}
	}

	GetBackpack()->unequip();
	int backpackMax = jsonDoc["gridCount"].GetInt();
	GetBackpack()->setBackpackMax(backpackMax);

	for (size_t i = 0; i < jsonDoc["list"].Size(); i++) {
		int pos = jsonDoc["list"][i]["id"].GetInt() - 1;
		ItemType itemType = (ItemType)jsonDoc["list"][i]["type"].GetInt();
		int itemId = jsonDoc["list"][i]["itemId"].GetInt();
		int amount = jsonDoc["list"][i]["amount"].GetInt();
		int quality = jsonDoc["list"][i]["quality"].GetInt();
		int portalId = jsonDoc["list"][i]["portalId"].IsNull() ? -1 : jsonDoc["list"][i]["portalId"].GetInt();
		int objectId = jsonDoc["list"][i]["objectId"].IsNull() ? -1 : jsonDoc["list"][i]["objectId"].GetInt();
		bool enable = jsonDoc["list"][i]["enable"].GetBool();


		Item* item = GetItemProvider()->spawnItemWithAmount(itemId, amount);
		item->uniqueId = pos;
		item->setQuality(quality);
		item->portalId = portalId;
		item->objectId = objectId;
		item->locked = !enable;

		if (itemType == ItemType::WATERCAN) {
			int hp = jsonDoc["list"][i]["hp"].GetInt();
			item->useLeft = hp;
		}

		backpack[pos] = item;

		if (!jsonDoc["list"][i]["filler"].IsNull()) {
			int fillerItemId = jsonDoc["list"][i]["filler"]["itemId"].GetInt();
			int fillerAmount = jsonDoc["list"][i]["filler"]["amount"].GetInt();
			int fillerQuality = jsonDoc["list"][i]["filler"]["quality"].GetInt();

			Item* filler = GetItemProvider()->spawnItemWithAmount(fillerItemId, fillerAmount);
			filler->setQuality(fillerQuality);

			item->attachment = filler;
		}
	}

	if (UIViewMgr::getInstance()->isViewShow(uiType::UI_MAIN_VIEW)) {
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TEAM_RECYCLE_VIEW);
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_RECYCLE_VIEW);
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_HUSHI_MARKET_VIEW);
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_NIGHT_MARKET_VIEW);
	}

	if (activeItemId != -1)
	{
		Item* tempItem = GetBackpack()->getItemByItemId(activeItemId);
		if (tempItem)
		{
			GetBackpack()->equip(tempItem->uniqueId);
		}
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACKPACK_LAYOUT);

	backpackChecking = false;
}

void WSManager::processUnlockBackpackGrid(const std::string& data)
{
	int backpackMax = atoi(data.c_str());
	GetBackpack()->setBackpackMax(backpackMax);
	GetMainGame()->addDiamond(-50);
	if (UIViewMgr::getInstance()->isViewShow(uiType::UI_MAIN_VIEW)) {
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);
	}

	GetMsgMgr()->showMsg(u8"解锁成功。");
}


bool WSManager::processGetMap(std::string& cmdData)
{
	vector<string> splitStr = splitStringByDelimiter(cmdData, ",");
	int mapId = atoi(splitStr[0].c_str());

	string decodeData = b64decode(splitStr[1]);
	uint8_t* decompData = (uint8_t*)malloc(1024 * 1024);
	int dataSize = UncompressData((uint8_t*)decodeData.c_str(), decodeData.size(), decompData, 1024 * 1024);

	if (dataSize == -1) {
		free(decompData);
		return false;
	}

	CC_ASSERT(dataSize % sizeof(MAPBLOCK) == 0);

	GameMap* map = GetMainGame()->getMapById(mapId);
	int width = map->getWidth();
	MAPBLOCK* blocks = (MAPBLOCK*)malloc(dataSize);
	mapDataServerToClient(decompData, blocks, dataSize / sizeof(MAPBLOCK), width);
	free(decompData);

	map->setMapBlock(blocks);
	map->refreshMap();

	return true;
}

void WSManager::processGetTreeList(const std::string& data, bool updateMap)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int def = jsonDoc[i]["size"]["def"].GetInt();
		int type = jsonDoc[i]["treeId"].GetInt();
		int id = jsonDoc[i]["id"].GetInt();
		float hp = jsonDoc[i]["hp"].GetFloat();
		int growTime = jsonDoc[i]["growTime"].GetInt();
		int exp = jsonDoc[i]["exp"].GetInt();
		int currentStageIndex = jsonDoc[i]["currentStageIndex"].GetInt();
		uint64_t lastUpdateTime = jsonDoc[i]["lastUpdateTime"].GetUint64();

		Tree* tree = map->plantTree(mapX, mapY, id, type, currentStageIndex, updateMap);
		tree->setHp(hp);
		tree->setGrowTime(growTime);
		tree->setExp(exp);
		tree->setDef(def);
		tree->setLastUpdate(lastUpdateTime);
		/*
		for (size_t j = 0; j < jsonDoc[i]["size"]["growList"].Size(); j++) {
			int hpStage = jsonDoc[i]["size"]["hpList"][j].GetInt();
			int stumpHpStage = jsonDoc[i]["size"]["stumpHpList"][j].GetInt();
			tree->clearHpList();
			tree->addGrowStageHp(hpStage);
			tree->addStumpHp(stumpHpStage);
		}*/
	}

	char buf[256];
	bool errorFound = false;
	std::string errorStr;
	for (int y = 0; y < map->getHeight(); y++) {
		for (int x = 0; x < map->getWidth(); x++) {
			auto block = map->getMapBlock(x, y);

			if (block->tileType == TILE_TREE) {
				Tree* tree = map->getTreeById(block->index);
				if (tree == nullptr) return;
				int treeMapX, treeMapY;
				Vec2 treePos = tree->getPos();
				tree->getMapPos(&treeMapX, &treeMapY);

				int checkMapX = (int)(treePos.x / 128.0f);
				int checkMapY = (int)(treePos.y / 128.0f);

				if (treeMapX != x || treeMapY != y) {
					sprintf(buf, "mapId=%d mapPos=%d-%d id=%d treePos=%d-%d\n", mapId, x, y, block->index, treeMapX, treeMapY);
					errorStr += buf;
					errorFound = true;
				}
			}
		}
	}

	if (errorFound) {
		sendDebugLog("TreePosError:\n" + errorStr);
	}
}

void WSManager::processGetGrassList(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int size = jsonDoc[i]["width"].GetInt();
		int id = jsonDoc[i]["id"].GetInt();
		float hp = jsonDoc[i]["hp"].GetFloat();
		float def = jsonDoc[i]["def"].GetFloat();

		Grass* grass = map->plantGrass(mapX, mapY, id, size);
		grass->setHp(hp);
		grass->setSize(size);
		grass->setDef(def);
	}
}

void WSManager::processGetMultiBlockResourceList(const std::string& data, bool updateMap)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int typeId = jsonDoc[i]["itemId"].GetInt();
		int id = jsonDoc[i]["id"].GetInt();
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int hp = jsonDoc[i]["hp"].GetInt();
		int width = jsonDoc[i]["width"].GetInt();
		int height = jsonDoc[i]["height"].GetInt();
		int def = jsonDoc[i]["def"].GetInt();
		auto type = jsonDoc[i]["type"].GetString();
		MultiBlockResource::MultiBlockResourceType resourceType;

		if (!strcmp(type, "Rock")) {
			resourceType = MultiBlockResource::MultiBlockResourceType::ROCK;
		}
		else if (!strcmp(type, "BrokenBuilding")) {
			continue;
		}
		else if (!strcmp(type, "Trunk")) {
			resourceType = MultiBlockResource::MultiBlockResourceType::TRUNK;
		}
		else if (!strcmp(type, "Grass")) {
			Grass* grass = map->plantGrass(mapX, mapY, id, 1, updateMap);
			if (grass)
			{
				grass->setHp((float)hp);
				grass->setSize(width);
				grass->setDef((float)def);
				grass->setItemId(itemId);

			}
			else
			{
				int i = 0;
			}
			continue;
		}
		else {
			continue;
		}

		map->spawnMultiBlockResource(mapX, mapY, resourceType, width, height, hp, typeId, def, updateMap, id);
	}

	//处理飞行装饰动物
	map->dealAirAnimal();
}

void WSManager::processGetFarmList(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);

	unsigned long long nowTime = time(NULL);

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int cropId = jsonDoc[i]["cropId"].GetInt();
		uint64_t growTime = jsonDoc[i]["growTime"].GetUint64();
		uint64_t lastWaterTime = jsonDoc[i]["lastWaterTime"].GetUint64();
		uint64_t seedTime = jsonDoc[i]["seedTime"].GetUint64();
		bool watered = jsonDoc[i]["watered"].GetBool();
		int currentStageIndex = jsonDoc[i]["currentStageIndex"].GetInt();

		Crop* crop = Crop::create();
		crop->setId(id);
		crop->setParentMap(map);
		crop->setData(cropId);
		crop->setCameraMask(map->getCameraMask());
		crop->setStage(currentStageIndex);
		if (watered) {
			crop->water(lastWaterTime);
		}
		crop->setAccGrowTime(growTime);
		crop->initAboutRain(seedTime, nowTime * 1000);
		GetMainGame()->addUpdate(crop);
		crop->retain();
		map->addCrop(id, crop);
	}

	for (int mapY = 0; mapY < map->getHeight(); mapY++) {
		for (int mapX = 0; mapX < map->getWidth(); mapX++) {
			MAPBLOCK* block = map->getMapBlock(mapX, mapY);

			if (block->tileType == TILE_FARM && block->index > 0) {
				Crop* crop = map->getCrop(mapX, mapY);
				if (crop == nullptr)
				{
					continue;
				}
				Vec2 cropPos;
				cropPos.x = (mapX + 0.5f) * map->getTileWidth();
				cropPos.y = (mapY + 1) * map->getTileHeight() - 64.0f;
				crop->setPos(cropPos);
				crop->setMapPos(mapX, mapY);
				map->addFarmList(mapX, mapY, ObjectListType::OLT_CROP, crop->isHarvestable());
			}


		}
	}
}

void WSManager::processRefresh(const std::string& data)
{
	const char* treeId = "5";
	const char* grassId = "6";
	const char* rockId = "8";

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GameMap* map = GetMainGame()->getCurrentMap();

	for (size_t i = 0; i < jsonDoc[treeId].Size(); i++) {
		int mapX = jsonDoc[treeId][i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[treeId][i]["mapPosition"]["y"].GetInt();
		int def = jsonDoc[treeId][i]["size"]["def"].GetInt();
		int type = jsonDoc[treeId][i]["treeId"].GetInt();
		int id = jsonDoc[treeId][i]["id"].GetInt();
		float hp = jsonDoc[treeId][i]["hp"].GetFloat();
		int growTime = jsonDoc[treeId][i]["growTime"].GetInt();
		int exp = jsonDoc[treeId][i]["exp"].GetInt();
		int currentStageIndex = jsonDoc[treeId][i]["currentStageIndex"].GetInt();
		uint64_t lastUpdateTime = jsonDoc[treeId][i]["lastUpdateTime"].GetUint64();

		Tree* tree = map->plantTree(mapX, mapY, id, type, currentStageIndex, true);
		tree->setHp(hp);
		tree->setGrowTime(growTime);
		tree->setExp(exp);
		tree->setDef(def);
		tree->setLastUpdate(lastUpdateTime);

		for (size_t j = 0; j < jsonDoc[treeId][i]["dropList"].Size(); j++) {
			int itemId = jsonDoc[treeId][i]["dropList"][j]["itemId"].GetInt();
			int amount = jsonDoc[treeId][i]["dropList"][j]["amount"].GetInt();

			tree->addDropItem(itemId, amount);
		}

		//for (size_t j = 0; j < jsonDoc[treeId][i]["size"]["growList"].Size(); j++) {
		//	int hpStage = jsonDoc[treeId][i]["size"]["hpList"][j].GetInt();
		//	int stumpHpStage = jsonDoc[treeId][i]["size"]["stumpHpList"][j].GetInt();
		//	tree->addGrowStageHp(hpStage);
		//	tree->addStumpHp(stumpHpStage);
		//}
	}

	for (size_t i = 0; i < jsonDoc[grassId].Size(); i++) {
		int mapX = jsonDoc[grassId][i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[grassId][i]["mapPosition"]["y"].GetInt();
		int size = jsonDoc[grassId][i]["size"].GetInt();
		int id = jsonDoc[grassId][i]["id"].GetInt();
		float hp = jsonDoc[grassId][i]["hp"].GetFloat();

		Grass* grass = map->plantGrass(mapX, mapY, id, size, true);
		grass->setHp(hp);

		for (size_t j = 0; j < jsonDoc[grassId][i]["dropList"].Size(); j++) {
			int itemId = jsonDoc[grassId][i]["dropList"][j]["itemId"].GetInt();
			int amount = jsonDoc[grassId][i]["dropList"][j]["amount"].GetInt();

			grass->addDropItem(itemId, amount);
		}
	}

	for (size_t i = 0; i < jsonDoc[rockId].Size(); i++) {
		int mapX = jsonDoc[rockId][i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[rockId][i]["mapPosition"]["y"].GetInt();
		int typeId = jsonDoc[rockId][i]["category"].GetInt();
		int id = jsonDoc[rockId][i]["id"].GetInt();
		int hp = jsonDoc[rockId][i]["hp"].GetInt();
		int width = jsonDoc[rockId][i]["width"].GetInt();
		int height = jsonDoc[rockId][i]["height"].GetInt();
		int def = jsonDoc[rockId][i]["def"].GetInt();
		auto type = jsonDoc[rockId][i]["type"].GetString();
		MultiBlockResource::MultiBlockResourceType resourceType;

		if (strcmp(type, "Rock")) {
			resourceType = MultiBlockResource::MultiBlockResourceType::ROCK;
		}
		else if (strcmp(type, "BrokenBuilding")) {
			continue;
		}
		else if (strcmp(type, "Trunk")) {
			continue;
		}
		else {
			continue;
		}

		map->spawnMultiBlockResource(mapX, mapY, resourceType, width, height, hp, typeId, def, true, id);
	}
}

void WSManager::processGetPickableList(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		float mapX = jsonDoc[i]["position"]["x"].GetFloat();
		float mapY = jsonDoc[i]["position"]["y"].GetFloat();
		int itemId = jsonDoc[i]["item"]["itemId"].GetInt();
		int amount = jsonDoc[i]["item"]["amount"].GetInt();
		int quality = jsonDoc[i]["item"]["quality"].GetInt();
		int portalId = jsonDoc[i]["item"]["portalId"].IsNull() ? -1 : jsonDoc[i]["item"]["portalId"].GetInt();
		int objectId = jsonDoc[i]["item"]["objectId"].IsNull() ? -1 : jsonDoc[i]["item"]["objectId"].GetInt();
		bool autopick = jsonDoc[i]["autoPickUp"].GetBool();
		int64_t uid = jsonDoc[i]["userId"].GetInt64();
		uint64_t expireTime = jsonDoc[i]["expiredTime"].GetUint64();

		mapX += (rand() % 128 - 64);
		mapY += (rand() % 128 - 64);

		DropItem* item = map->popItem(mapX, mapY, itemId, amount, id);
		item->setAutopick(autopick);
		item->setIdle();
		item->setQuality(quality);
		item->setPortalId(portalId);
		item->setObjectId(objectId);
		item->setUid(uid);
		item->setExpireTime(expireTime);
	}
}

void WSManager::processItemDrop(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		DropItemData data;

		data.id = jsonDoc[i]["id"].GetInt();
		data.posX = jsonDoc[i]["position"]["x"].GetFloat() + (rand() % 128 - 64);
		data.posY = jsonDoc[i]["position"]["y"].GetFloat() + (rand() % 128 - 64);
		data.mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		data.mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		data.itemId = jsonDoc[i]["item"]["itemId"].GetInt();
		data.amount = jsonDoc[i]["item"]["amount"].GetInt();
		data.quality = jsonDoc[i]["item"]["quality"].GetInt();
		data.portalId = jsonDoc[i]["item"]["portalId"].IsNull() ? -1 : jsonDoc[i]["item"]["portalId"].GetInt();
		data.objectId = jsonDoc[i]["item"]["objectId"].IsNull() ? -1 : jsonDoc[i]["item"]["objectId"].GetInt();
		data.autopick = jsonDoc[i]["autoPickUp"].GetBool();
		data.uid = jsonDoc[i]["userId"].GetInt64();
		data.expireTime = jsonDoc[i]["expiredTime"].GetUint64();

		if (!jsonDoc[i]["item"]["filler"].IsNull()) {
			int fillerItemId = jsonDoc[i]["item"]["filler"]["itemId"].GetInt();
			int fillerAmount = jsonDoc[i]["item"]["filler"]["amount"].GetInt();
			int fillerQuality = jsonDoc[i]["item"]["filler"]["quality"].GetInt();

			Item* filler = GetItemProvider()->spawnItemWithAmount(fillerItemId, fillerAmount);
			filler->setQuality(fillerQuality);

			data.attachment = filler;
		}

		map->enqueuePopItem(data);
	}
}

void WSManager::processFishingCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int taskId = jsonDoc["id"].GetInt();
	int fishId = jsonDoc["result"]["itemId"].GetInt();
	uint64_t fishEndTs = jsonDoc["time"].GetUint64();

	if (GetPlayer()->isFishing()) {
		GetPlayer()->setFishCallbackParam(fishEndTs + 1000, fishId, taskId);
	}
}

void WSManager::processCatchCrabsCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int taskId = jsonDoc["id"].GetInt();
	int mapIndex = jsonDoc["mapIndex"].GetInt();

	GameMap* map = GetMainGame()->getMapById(mapIndex);
	map->removeGuideSpine_1();
	Crabcage* cage = crabcageQueue.front();
	crabcageQueue.pop();

	int mapX, mapY;

	cage->getMapPos(&mapX, &mapY);
	cage->setId(taskId);

	map->addCrabcage(taskId, cage);

	if (!jsonDoc["tool"]["filler"].IsNull())
	{
		int baitid = jsonDoc["tool"]["filler"]["itemId"].GetInt();
		int baitamount = jsonDoc["tool"]["filler"]["amount"].GetInt();
		cage->setBait(baitid, baitamount);
	}
	uint64_t time = jsonDoc["time"].GetUint64();
	int grid = jsonDoc["tool"]["type"].GetInt();
	cage->setStartTime(time);
	cage->setMaxGrid(grid);
	if (!jsonDoc["result"].IsNull())
	{
		int amount = jsonDoc["result"].Size();
		cage->setResultAmount(amount);
	}
	cage->showSpr(true);
	MAPBLOCK* block = map->getMapBlock(mapX, mapY);
	block->tileType = TILE_CRABCAGE;
	block->index = taskId;
}

void WSManager::processGetCatchCrabsTaskList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int id = jsonDoc[i]["id"].GetInt();
		int mapId = jsonDoc[i]["mapIndex"].GetInt();

		GameMap* map = GetMainGame()->getMapById(mapId);

		Crabcage* cage = map->plantCrabcage(mapX, mapY);

		cage->setId(id);
		map->addCrabcage(id, cage);

		if (!jsonDoc[i]["tool"]["filler"].IsNull())
		{
			int baitid = jsonDoc[i]["tool"]["filler"]["itemId"].GetInt();
			int baitamount = jsonDoc[i]["tool"]["filler"]["amount"].GetInt();
			cage->setBait(baitid, baitamount);
		}
		int grid = jsonDoc[i]["tool"]["type"].GetInt();
		int itemId = jsonDoc[i]["tool"]["itemId"].GetInt();
		uint64_t time = jsonDoc[i]["time"].GetUint64();
		cage->setStartTime(time);
		cage->setMaxGrid(grid);
		cage->setItemId(itemId);
		if (!jsonDoc[i]["result"].IsNull())
		{
			int amount = jsonDoc[i]["result"].Size();
			cage->setResultAmount(amount);
		}
		cage->showSpr(true);
	}
}

void WSManager::processFinishFishing(const std::string& data)
{
	if (data == "ERROR") {
		return;
	}

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	std::unordered_map<int, int> itemList;

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int amount = jsonDoc[i]["amount"].GetInt();
		int quality = jsonDoc[i]["quality"].GetInt();

		Item* item = GetItemProvider()->spawnItemWithAmount(itemId, amount);
		item->setQuality(quality);
		GetBackpack()->put(*item);

		/*char buf[256];
		sprintf(buf, u8"获得%s品%s×%d。", qualityText[quality - 1], item->name.c_str(), amount);
		GetMsgMgr()->showMsg(buf);*/

		delete item;

		itemList[itemId] = amount;
	}

	for (auto& entry : itemList) {

		if (GetVisitSystem()->checkIsVisiting())
			GetMissionSystem()->guestFishing(entry.first, entry.second);
		else
			GetMissionSystem()->fishing(entry.first, entry.second);
	}

	GetMainGame()->checkBackpack();
}


void WSManager::processFinishCatching(const std::string& data)
{
	if (data == "ERROR") {
		return;
	}

	int commaPos = data.find(",");
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	std::unordered_map<int, int> itemList;

	Crabcage* cage = crabcageDeleteQueue.front();
	crabcageDeleteQueue.pop();
	auto card = GetCharacterSystem()->getCurrent();

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int amount = jsonDoc[i]["amount"].GetInt();
		int quality = jsonDoc[i]["quality"].GetInt();
		int uniqueId = jsonDoc[i]["id"].GetInt();

		itemList[itemId] = amount;
		Item* data = GetItemProvider()->getData(itemId);
		if (data->type != ItemType::CRABCAGE)
		{
			int cardExpAdd = data->values[1];
			GetSkillSystem()->checkCardExp(card, &cardExpAdd);
			card->addExp(cardExpAdd);
		}
		/*Item* item = GetItemProvider()->spawnItemWithAmount(itemId, amount);

		if (itemId == cage->getItemId())
		{

			Item* backpackItem = GetBackpack()->getByPosition(uniqueId - 1);
			backpackItem = item;
			backpackItem->uniqueId = uniqueId - 1;
			backpackItem->locked = false;

			if (!jsonDoc[i]["filler"].IsNull()) {
				int fillerItemId = jsonDoc[i]["filler"]["itemId"].GetInt();
				int fillerAmount = jsonDoc[i]["filler"]["amount"].GetInt();
				int fillerQuality = jsonDoc[i]["filler"]["quality"].GetInt();

				Item* filler = GetItemProvider()->spawnItemWithAmount(fillerItemId, fillerAmount);
				filler->setQuality(fillerQuality);

				backpackItem->attachment = filler;
			}

			continue;
		}
		else
		{
			auto card = GetCharacterSystem()->getCurrent();
			int exp = item->values[1];
			card->addExp(exp);
			item->setQuality(quality);
			GetBackpack()->put(*item);
		}*/

		/*char buf[256];
		sprintf(buf, u8"获得%s品%s×%d。", qualityText[quality - 1], item->name.c_str(), amount);
		GetMsgMgr()->showMsg(buf);*/

		//delete item;


	}

	GameMap* map = (GameMap*)cage->getParent();
	int mapX, mapY;
	cage->getMapPos(&mapX, &mapY);
	map->retrieveCrabcage(mapX, mapY);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);

	if (GetVisitSystem()->checkIsVisiting())
		GetMissionSystem()->guestCatchCrabOrShrimp(itemList);
	else
		GetMissionSystem()->retrievecrabcage(itemList);
	//GetMainGame()->checkBackpack();
}

void WSManager::prepareCrafting(const std::string& data, bool& breakFlag, CraftQueue*& queue) {
	breakFlag = true;
	if (craftQueue.empty()) return;
	queue = craftQueue.front();
	craftQueue.pop();

	if (data == "ERROR") {
		queue->recipe = nullptr;
		queue->card = nullptr;
		queue->workingBuilding = nullptr;
		return;
	}

	int taskId = atoi(data.c_str());
	queue->taskId = taskId;

	auto* recipe = queue->recipe;
	int amount = queue->amount;
	Item** backpackBlocks = GetBackpack()->getAll();

	for (auto& recipeData : recipe->recipe) {
		int itemId = recipeData.first;
		int itemAmount = recipeData.second * amount;

		for (int i = 0; i < GetBackpackMax(); i++) {
			if (backpackBlocks[i] == nullptr)
				continue;

			if (backpackBlocks[i]->itemId != itemId)
				continue;

			if (backpackBlocks[i]->amount <= itemAmount) {
				itemAmount -= backpackBlocks[i]->amount;
				backpackBlocks[i] = nullptr;
				continue;
			}

			backpackBlocks[i]->amount -= itemAmount;
			break;
		}
	}

	auto* card = queue->card;

	if (card != nullptr)
	{
		card->taskPtr = queue;
		card->taskType = TaskType::CRAFT;
		card->taskId = taskId;
		card->hidePartner();
	}

	auto* building = queue->workingBuilding;
	if (building != nullptr) {
		building->setBusy(true, queue->product->type);
		building->setTask(queue);
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);

	GetCraftManager()->getCraftQueue().push_back(queue);
	if (queue->recipe->type == CraftRecipeType::TOOL || queue->recipe->type == CraftRecipeType::CLOTHCRAFT ||
		queue->recipe->type == CraftRecipeType::BOOK || queue->recipe->type == CraftRecipeType::EXP_JEWEL)
	{
		GetCraftManager()->addRecipeTotalCount(queue->recipe->id, queue->amount);
	}

	GetMainGame()->addMoney(queue->money * -1, false, false);
	GetMainGame()->checkBackpack();
	breakFlag = false;
}

void WSManager::processMake(const std::string& data)
{
	bool breakFlag = false;
	CraftQueue* queue = nullptr;
	prepareCrafting(data, breakFlag, queue);

	if (breakFlag) return;

	if (queue->id == 40)
	{
		NoviceGuideMgr::getInstance()->dealWithUseWrokTable();
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_NPC_CRAFT_VIEW);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BUILD_INFO, (void*)(queue->recipe->id), 0);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_WORKING_TABLE_VIEW);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_MAKING_TIME);
}

void WSManager::processMakeFinish(const std::string& data)
{
	int commaPos = data.find(",");
	int makeTaskId = atoi(data.substr(0, commaPos).c_str());
	//string jsonStr = data.substr(commaPos + 1);

	GetCraftManager()->finishQueueCallback(makeTaskId);

	GetBuildController()->updateRedPoint();
}

void WSManager::processGetMakeTaskList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int taskId = jsonDoc[i]["id"].GetInt();
		uint64_t startTime = jsonDoc[i]["startTime"].GetUint64();
		int recipeId = jsonDoc[i]["recipe"]["id"].GetInt();
		int amount = jsonDoc[i]["recipe"]["count"].GetInt();
		int chrId = jsonDoc[i]["cardId"].IsNull() ? 0 : jsonDoc[i]["cardId"].GetInt();
		int mapIndex = jsonDoc[i]["mapIndex"].GetInt();
		int buildingId = jsonDoc[i]["buildingId"].GetInt();
		uint64_t serverNeedTime = jsonDoc[i]["recipe"]["spendTime"].GetUint64() * amount;

		CCASSERT(taskId != 0, "taskId != 0");

		CraftQueue* queue = GetCraftManager()->addQueue(recipeId, amount, startTime, taskId, mapIndex, buildingId, chrId);
		uint64_t localNeedTime = queue->endTs - queue->startTs - 1000ULL;

		CCLOG("TASKID %d: LOCALNEEDTIME %llu, SERVERNEEDTIME: %llu, diff %d", taskId, (unsigned long long)localNeedTime, (unsigned long long)serverNeedTime, (int)((int64_t)localNeedTime - (int64_t)serverNeedTime));
	}
}

void WSManager::processGetBuildingList(const std::string& data)
{
	int commaPos = data.find(",");
	int commaPos2 = data.find(",", commaPos + 1);
	int mapId = atoi(data.substr(0, commaPos).c_str());
	ItemType itemType = (ItemType)atoi(data.substr(commaPos + 1, commaPos2 - commaPos - 1).c_str());
	string jsonStr = data.substr(commaPos2 + 1);
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);
	size_t buildingCount = jsonDoc.Size();
	for (size_t i = 0; i < buildingCount; i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int typeId = jsonDoc[i]["typeId"].GetInt();
		int xPos = mapX * 128;
		int yPos = (mapY + 1) * 128;
		int portalId = jsonDoc[i]["inPortalId"].IsNull() ? 0 : jsonDoc[i]["inPortalId"].GetInt();
		bool moveLock = jsonDoc[i]["moveLock"].GetBool();
		int beauty = jsonDoc[i]["beauty"].GetInt();
		int ownerId = jsonDoc[i]["ownerId"].GetInt();

		MapObject* obj = nullptr;

		switch (itemType) {
		case ItemType::BUILDING:
		case ItemType::INDOORBUILDING:
		case ItemType::INDOOROUTDOORBUILDING:
		{
			if (Contains(dummyBuildingIdList, typeId)) {
				map->spawnDummyBuilding(typeId, xPos, yPos, mapX, mapY, id, moveLock);
				continue;
			}

			Building* building = map->spawnBuilding(typeId, (float)xPos, (float)yPos, nullptr, id, -1, true);
			building->setPortalId(portalId);
			building->setBeauty(beauty);
			building->setOwnerId(ownerId);

			if (mapId < 100 && portalId > 0) {
				GetMainGame()->addPortalBuildingPair(portalId, building);
				auto portal = GetMainGame()->getPortal(portalId);
				if (portal)
				{
					GetMainGame()->addMapBuildingMap(portal->mapIndex, building);
				}
			}

			if (building->getBuildingId() == 22064) //矿洞
			{
				int i = building->getId();
				MineSystemController::getInstance()->setData(building, mapId, i);
			}

			obj = building;


		}
		break;

		case ItemType::WALL:
		case ItemType::INDOORWALL:
			obj = map->spawnWall(typeId, mapX, mapY, false, id, false);
			((Wall*)obj)->setBeauty(beauty);
			break;
		default:
			continue;
		}

		obj->setLock(moveLock);
	}

	if (itemType == ItemType::WALL || itemType == ItemType::INDOORWALL) {
		map->updateWallSprite();
	}


	auto isMapBuilding = GetMainGame()->checkMapBuildingMap(mapId);
	if (isMapBuilding)
	{
		auto building = GetMainGame()->getBuildingByMapId(mapId);
		if (Contains(homeBuildingList, building->getBuildingId()) || Contains(houseBuildingList, building->getBuildingId()))
		{
			((House*)building)->creatAllPartner();

		}

		if (Contains(animalHouseTypes, building->getBuildingId())) {
			if (!((AnimalHouse*)building)->checkFirstCreateMap())
			{
				((AnimalHouse*)building)->createAllAnimal();
				((AnimalHouse*)building)->showTroughPrompt(mapId);
			}
		}
	}

	if (mapId == 131)
	{
		GetSocializeSystem()->refreshMapByMember();
	}

}


void WSManager::processGetNpcList(const std::string& data)
{

	//    return;

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int likeness = jsonDoc[i]["approve"].GetInt();
		int talkProgress = jsonDoc[i]["talkProgress"].GetInt();
		int giftCount = jsonDoc[i]["count"].GetInt();
		int npcPresentProgress = Npc::getNpcTemplate(id)->giftList.size();
		int64_t lastTalkTime = jsonDoc[i]["lastTalkTime"].GetInt64();
		int64_t lastGiftTime = jsonDoc[i]["lastSendGiftTime"].GetInt64();
		int npcMapId = jsonDoc[i]["npcPosition"]["mapIndex"].GetInt();
		GameMap* map = GetMainGame()->getMapById(npcMapId);
		int npcMapPosX = jsonDoc[i]["npcPosition"]["mapPosition"]["x"].GetInt();
		int npcMapPosY = jsonDoc[i]["npcPosition"]["mapPosition"]["y"].GetInt();
		if (BehaviorController::getInstance()->getNPCBehavior()->isInside(id))
			continue;

		Npc* npc = map->spawnNpc(id, npcMapPosX, npcMapPosY);
		npc->setFavor(likeness);
		npc->setLastTalkTime(lastTalkTime);
		npc->setLastGiftTime(lastGiftTime);
		npc->setGiftCount(giftCount);
		npc->setMapId(npcMapId);

		auto itr = jsonDoc[i]["approveGiftMap"].MemberBegin();
		while (itr != jsonDoc[i]["approveGiftMap"].MemberEnd()) {
			npcPresentProgress--;
			itr++;
		}

		npc->setPresentProgress(npcPresentProgress);

		GetMainGame()->addNpc(npc);

		if (talkProgress > 0) {
			GetScriptSystem()->setNpcProgress(id + 10000, talkProgress);
		}

		MovieShowMgr::getInstance()->checkShowByNpcFriendship(id, likeness);
	}
}

void WSManager::processBuildingBuildCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int typeId = jsonDoc["typeId"].GetInt();
	int mapX = jsonDoc["mapPosition"]["x"].GetInt();
	int mapY = jsonDoc["mapPosition"]["y"].GetInt();
	int width = jsonDoc["width"].GetInt();
	int height = jsonDoc["height"].GetInt();
	std::string blockdata = jsonDoc["data"].GetString();
	int ownerId = jsonDoc["ownerId"].GetInt();
	int mapId = jsonDoc["mapIndex"].GetInt();
	int portalId = jsonDoc["portalId"].GetInt();

	PlaceData placeData;
	placeData.mapX = mapX;
	placeData.mapY = mapY;
	placeData.width = width;
	placeData.height = height;

	std::string decodeRes = b64decode(blockdata);
	memcpy(placeData.data, decodeRes.c_str(), decodeRes.length());

	GameMap* map = GetMainGame()->getMapById(mapId);
	Item* itemData = GetItemProvider()->getData(typeId);
	int beauty = itemData->values[0];
	int newBuildingId = map->getNewBuildingId();

	//探访时主人升级建筑
	if (GetVisitSystem()->checkIsVisiting() && ownerId != GetMainGame()->getUid())
	{
		int oldMapX, oldMapY;
		bool existOldBuilding = false;
		bool isforBreak = false;
		for (int i = mapX; i < mapX + width; i++)
		{
			if (isforBreak)
				break;

			for (int j = mapY - height; j < mapY; j++)
			{
				MAPBLOCK* block = map->getMapBlock(i, j);
				if (block->tileType == TileType::TILE_BUILDING)
				{
					existOldBuilding = true;
					isforBreak = true;
					auto oldBuilding = map->getBuildingById(block->index);
					oldBuilding->setBusy(false);
					oldMapX = i;
					oldMapY = j;
					break;
				}
			}
		}

		if (existOldBuilding)
		{

			map->shoveTile(oldMapX, oldMapY, 0, 1, 1, true);
		}

	}

	switch (itemData->type) {
	case ItemType::BUILDING:
	case ItemType::DECORATION:
	case ItemType::INDOORBUILDING:
	case ItemType::INDOOROUTDOORBUILDING:
	{
		Building* building = map->spawnBuilding(typeId, placeData.mapX * 128.0f, (placeData.mapY + 1) * 128.0f, &placeData, newBuildingId, portalId, false);
		building->setBeauty(beauty);
		building->setOwnerId(ownerId);
		if (typeId == 26297)
		{
			LightSystemController::getInstance()->updateDarkLayer();
		}
	}
	break;

	case ItemType::ROADTILE:
		// TODO: spawn road here
		break;

	case ItemType::WALL:
	{
		auto wall = map->spawnWall(typeId, placeData.mapX, placeData.mapY, true);
		wall->setBeauty(beauty);
	}
	break;
	}


	if (GetVisitSystem()->checkIsVisiting() || GetMainGame()->getUid() != ownerId)
		beauty = 0;


	GetMainGame()->addBeauty(beauty);

	if (ownerId == GetMainGame()->getUid()) {
		if (GetVisitSystem()->checkIsVisiting()) {
			GetMissionSystem()->guestPlace(typeId);
		}
		else {
			GetMissionSystem()->place(typeId);
			GetMissionSystem()->cumulativePlace(typeId);
			if (map->getId() >= 101 && map->getId() <= 105)
				GetMissionSystem()->placeHome(typeId);
		}

		GetPlayer()->place(typeId, mapX, mapY, width, height, blockdata, ownerId);
	}

	auto mview = (MainView*)UIViewMgr::getInstance()->getView(uiType::UI_MAIN_VIEW);

	if (typeId == 22060 || typeId == 22094)
	{
		GetGuideController()->guideChecker(33);
	}
	else if (typeId == 36033)
	{
		GetGuideController()->guideChecker(35);
	}
	else if (typeId == 37003)
	{
		if (mview)
		{
			mview->addGuideIcon(12);
		}
	}
	else if (typeId == 36202)
	{
		GetGuideController()->guideChecker(10);
	}

	if (Contains(baoXiangList, typeId))
	{
		char buf[256];
		sprintf(buf, "%04d %d", WSCommand::GET_TREASURE_BOX_LIST, mapId);
		this->send(buf);
	}
}

void WSManager::processVisitingLockBuildingCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");

	int mapId = stoi(strSplit[0]);
	int buildingId = stoi(strSplit[1]);
	GameMap* map = GetMainGame()->getMapById(mapId);
	Building* building = map->getBuildingById(buildingId);

	auto tempItem = GetItemProvider()->getData(building->getBuildingId());
	building->setBusy(true, tempItem->type);

}

void WSManager::processEatItemCallback(const std::string& data)
{
	int commaPos = data.find(",");
	int uniqueId = atoi(data.substr(0, commaPos).c_str());
	int amountT = atoi(data.substr(commaPos + 1).c_str());
	//int uniqueId = atoi(data.c_str());
	Item* consumeItem = GetBackpack()->getByPosition(uniqueId - 1);
	auto card = GetCharacterSystem()->getCurrent();
	if (consumeItem->type == ItemType::DISH || consumeItem->type == ItemType::FRUIT || consumeItem->type == ItemType::MEDICINE)
	{
		int spMaxMod = card->spLimit;
		int hpMaxMod = card->hpLimit;

		if (consumeItem->values[0] > 0 && card->sp < spMaxMod) {
			card->sp += consumeItem->values[0];
			if (card->sp > spMaxMod) {
				card->sp = spMaxMod;
			}
		}

		if (consumeItem->values[1] > 0 && card->hp < hpMaxMod) {
			card->hp += consumeItem->values[1];
			if (card->hp > hpMaxMod) {
				card->hp = hpMaxMod;
			}

		}

		consumeItem->amount = consumeItem->amount - amountT;
		GetBackpack()->callbackUpdate(consumeItem);
	}
}

void WSManager::processGetStumpList(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	GameMap* map = GetMainGame()->getMapById(mapId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int hp = jsonDoc[i]["hp"].GetInt();
		int treeId = jsonDoc[i]["treeId"].GetInt();
		int stage = jsonDoc[i]["stage"].GetInt();
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int def = jsonDoc[i]["def"].GetInt();

		map->spawnStump(mapX, mapY, treeId, hp, stage, def, false, id);
	}
}

void WSManager::processHarvest(const std::string& data)
{
	if (data == "ERROR") {
		auto pos = GetPlayer()->getPos();
		GetMainGame()->getCurrentMap()->spawnFloatingIndicatorText(u8"不能收获。", pos.x, pos.y - 96.0f, Color4B(255, 128, 128, 255), Color4B(0, 0, 0, 255), 48.0f, 0.0f, 48.0f, -0.5f);
		return;
	}

	int commaPos = data.find(",");
	int commaPos2 = data.find(",", commaPos + 1);
	int mapX = atoi(data.substr(0, commaPos).c_str());
	int mapY = atoi(data.substr(commaPos + 1, commaPos2 - commaPos - 1).c_str());
	string jsonStr = data.substr(commaPos2 + 1);

	auto map = GetMainGame()->getCurrentMap();
	auto block = map->getMapBlock(mapX, mapY);

	if (block->tileType == TileType::TILE_TREE) {
		Tree* tree = map->getTree(mapX, mapY);
		tree->harvestCallback();
	}
	else if (block->tileType == TileType::TILE_FARM) {
		Crop* crop = map->getCrop(mapX, mapY);

		if (crop == nullptr)
			throw;

		crop->harvestCallback();
	}
	else if (block->tileType == TileType::TILE_FLOWER) {
		Flower* flower = map->getFlower(mapX, mapY);

		if (flower == nullptr)
			throw;

		flower->harvestCallback();
	}
	else if (block->tileType == TileType::TILE_BUILDING) {
		Building* pBuilding = map->getBuildingById(block->index);
		if (Contains(clothesStandList, pBuilding->getBuildingId())) {
			((ClothesStand*)pBuilding)->clearCoatHangerSprite();
		}
	}
	else if (block->tileType == TileType::TILE_NONE) {
		//新增一种特殊情况 收获了树，树会立马删除，导致方块为none
	}
	else {
		throw;
	}

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	std::vector<int> missionTargets;

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int amount = jsonDoc[i]["amount"].GetInt();
		int quality = jsonDoc[i]["quality"].GetInt();

		Item* item = GetItemProvider()->spawnItemWithAmount(itemId, amount);
		item->setQuality(quality);

		/*char buf[256];
		sprintf(buf, u8"获得%s品%s×%d。", qualityText[quality - 1], item->name.c_str(), amount);
		GetMsgMgr()->showMsg(buf);*/

		GetBackpack()->put(*item);
		if (!Contains(missionTargets, itemId)) missionTargets.push_back(itemId);
		delete item;
	}

	for (auto target : missionTargets) {
		GetMissionSystem()->harvest(target, 1);
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);
	GetMainGame()->checkBackpack();
}

void WSManager::processGetCity(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int exp = jsonDoc["experience"]["value"].GetInt();
	int beauty = jsonDoc["aestheticDegree"].GetInt();
	int money = jsonDoc["money"].GetInt();
	int friendCoin = jsonDoc["friendCoin"].GetInt();
	int diamond = jsonDoc["rechargeableCoin"].GetInt();

	GetMainGame()->setTownExp(0);
	GetMainGame()->setTownLevel(1);
	GetCollectionSystem()->setObtainExpSwitch();
	GetMainGame()->addTownExp(exp);
	GetMainGame()->setBeauty(beauty);
	GetMainGame()->setMoney(money);
	GetMainGame()->setfriendCoin(friendCoin);
	GetMainGame()->setDiamond(diamond);

	this->getLevelLimitMoneyData(GetMainGame()->getTownLevel());
	this->getShopMoneyLimit(GetMainGame()->getTownLevel());
}

void WSManager::processGetLevelLimitMoney(const std::string& data)
{
	int amount = atoi(data.c_str());
	GetMainGame()->setMoneyLimit(amount);
}

void WSManager::processGetCharacterCardList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		CharacterCard* card = new CharacterCard();

		card->name = jsonDoc[i]["name"].GetString();
		card->id = jsonDoc[i]["id"].GetInt();
		card->rarity = jsonDoc[i]["rarity"].GetInt();
		card->level = 1;
		card->addExp(jsonDoc[i]["exp"]["value"].GetInt());
		card->approve = jsonDoc[i]["approve"].GetInt();
		card->sp = jsonDoc[i]["sp"].GetInt();
		card->spMax = jsonDoc[i]["spMax"].GetInt();
		card->hp = jsonDoc[i]["hp"].GetInt();
		card->hpMax = jsonDoc[i]["hpMax"].GetInt();
		card->build = jsonDoc[i]["build"].GetInt();
		card->buildMax = jsonDoc[i]["buildMax"].GetInt();
		card->stamina = jsonDoc[i]["stamina"].GetInt();
		card->staminaMax = jsonDoc[i]["staminaMax"].GetInt();
		card->trade = jsonDoc[i]["trade"].GetInt();
		card->tradeMax = jsonDoc[i]["tradeMax"].GetInt();
		card->craft = jsonDoc[i]["craft"].GetInt();
		card->craftMax = jsonDoc[i]["craftMax"].GetInt();
		card->shards = jsonDoc[i]["fragmentCount"].GetInt();
		card->skillLevel = jsonDoc[i]["skill"]["level"].GetInt();
		card->skillName = jsonDoc[i]["skill"]["name"].GetString();
		card->skillDescription = jsonDoc[i]["skill"]["description"].GetString();
		card->talkProgress = jsonDoc[i]["talkProgress"].GetInt();
		card->mGiftCnt = jsonDoc[i]["count"].GetInt();
		card->mLastGiftTime = jsonDoc[i]["lastSendGiftTime"].GetUint64();
		card->mLastTalkTime = jsonDoc[i]["lastTalkTime"].GetUint64();

		if (card->talkProgress > 0) {
			GetScriptSystem()->setNpcProgress(card->id, card->talkProgress);
		}

		char buf[256];
		sprintf(buf, "card_avatar_%d", card->id);
		card->avatarSpr = buf;

		card->hpLimit = card->hpMax + card->stamina / 20;
		card->spLimit = card->spMax + card->stamina / 10;

		for (size_t j = 0; j < jsonDoc[i]["statsSwitchList"].Size(); j++)
		{
			int value = jsonDoc[i]["statsSwitchList"][j].GetInt();
			card->cardPropertySwitch.push_back(value);
		}

		auto itr = jsonDoc[i]["skill"]["checkEffectMap"].MemberBegin();
		while (itr != jsonDoc[i]["skill"]["checkEffectMap"].MemberEnd()) {
			int checkId = atoi(itr->name.GetString());
			int effectId = itr->value.GetInt();
			card->skillMap[checkId] = effectId;
			itr++;
		}

		card->taskType = TaskType::DEFAULT;

		std::string taskType = jsonDoc[i]["taskType"].IsNull() ? "" : jsonDoc[i]["taskType"].GetString();
		if (taskType == "CardSleep")
		{
			card->taskType = TaskType::SLEEP;
		}

		card->taskPtr = nullptr;
		card->taskId = jsonDoc[i]["taskId"].GetInt();

		int weaponId = jsonDoc[i]["weaponId"].GetInt();
		int accessoryId = jsonDoc[i]["treasureId"].GetInt();

		if (weaponId > 0) {
			//card->weapon = GetItemProvider()->spawnItem(weaponId);
		}

		if (accessoryId > 0) {
			auto accessory = GetItemProvider()->spawnItem(GetAccessoriesManager()->getData(accessoryId)->itemId);
			accessory->portalId = accessoryId;
			accessory->cardId = card->id;
			card->accessory = accessory;
			card->addAccessoryData();
		}

		GetSkillSystem()->checkCharacterUpdate(card);
		GetCharacterSystem()->addCard(card);
	}

	this->getLeaveSquad();
}

void WSManager::processGetDisableCardList(const std::string& data)
{

	if (data == "ERROR") {
		return;
	}

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		int cardId = jsonDoc[i].GetInt();
		auto card = GetCharacterSystem()->getById(cardId);
		card->setCardLeaveSquad(true);
	}

}

void WSManager::processGetCharacterCardQueue(const std::string& data)
{
	std::vector<std::string> groupStrList = splitStringByDelimiter(data, ":");

	for (auto& groupStr : groupStrList) {
		Squad* squad = GetCharacterSystem()->addSquad();
		std::vector<std::string> cardStr = splitStringByDelimiter(groupStr, ",");

		for (size_t i = 0; i < cardStr.size(); i++) {
			int id = atoi(cardStr[i].c_str());

			if (id == -1) {
				continue;
			}

			CharacterCard* card = GetCharacterSystem()->getById(id);

			squad->card[i] = card;
		}
	}
}

void WSManager::processHatch(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int taskId = jsonDoc["id"].GetInt();

	IncubatorEntry* entry = incubatorTaskIdQueue.front();
	entry->taskId = taskId;
	incubatorTaskIdQueue.pop();
}

void WSManager::processFinishMission(const std::string& data)
{
	return;
	if (data == "ERROR") {
		GetMsgMgr()->showMsg(u8"完成任务失败！");
		return;
	}

	int missionId = stoi(data);

	if (!GetMissionSystem()->completeMissionCallback(missionId)) {
		GetMsgMgr()->showMsg(u8"完成任务失败！");
		return;
	}

	GetMainGame()->checkBackpack();
	GetMainGame()->checkTown();

	auto view = UIViewMgr::getInstance()->getView(UINAME::UI_MAIN_VIEW);
	((MainView*)view)->showStageText(missionId);
	GetMissionSystem()->showCompleteMissionView(missionId);

	GetLiChengMrg()->completeMissionHandler(missionId);

}

void WSManager::processGetFinishMissionList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int val = jsonDoc[i].GetInt();

		GetMissionSystem()->forceMissionComplete(val);
	}
}

void WSManager::processGetTreasures(const std::string& data)
{
	int commaPos = data.find(",");
	int commaPos2 = data.find(",", commaPos + 1);
	int buildingId = atoi(data.substr(0, commaPos).c_str());
	int mapId = atoi(data.substr(commaPos + 1, commaPos2 - commaPos - 1).c_str());
	string jsonStr = data.substr(commaPos2 + 1);

	GameMap* map = GetMainGame()->getMapById(mapId);
	Museum* museum = dynamic_cast<Museum*>(map->getBuildingById(buildingId));

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int val = jsonDoc[i].GetInt();

		if (val > 0)
			museum->putArtifact(val, i + 1);
	}
}

void WSManager::processGetMapIdList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	g_mapIdVtr.clear();

	std::vector<int> mapIdList;

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapId = jsonDoc[i].GetInt();

		g_mapIdVtr.push_back(mapId);

		GetMainGame()->createMapThin(mapId, 111);//mingtest
	}

	g_MapAllDataJsonDoc_cnt = 0;
	char buf[2048];
	sprintf(buf, "%04d %d", WSCommand::GET_ALL_DATA, g_mapIdVtr[g_MapAllDataJsonDoc_cnt]);
	send(buf);

	int mapId = g_mapIdVtr[g_MapAllDataJsonDoc_cnt];
	if (mapId != 132 && Contains(minemapIdList, mapId)) //请求矿洞信息
	{
		GetWSManager()->getMineList(mapId);
		GetLightController()->getLightStateList(mapId);
		GetMineController()->getGearInfo(mapId);
		GetMineController()->getDoorInfo(mapId);
		GetMineController()->getLayerConfig(mapId);
	}
	//auto str = FileUtils::getInstance()->getStringFromFile("mapDataJson/map5.json");
	//WSManager::getInstance()->processMapAllData(str);

	//string head = string(buf);
	//for (size_t i = 1; i < mapIdVtr.size(); i++)
	//{
	//	sprintf(buf, ",%d", mapIdVtr[i]);
	//	head = head + buf;
	//}
	//send(head);


	//GetWSManager()->sendEcho(WSEcho::INITCOMPLETE);

	GetMainGame()->setMapCount(jsonDoc.Size());
}

void WSManager::processGetPortalList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int mapIndex = jsonDoc[i]["mapIndex"].GetInt();
		int xPos = jsonDoc[i]["xpos"].GetInt();
		int yPos = jsonDoc[i]["ypos"].GetInt();
		int anotherId = jsonDoc[i]["anotherId"].IsNull() ? -1 : jsonDoc[i]["anotherId"].GetInt();
		bool enabled = jsonDoc[i]["enabled"].GetBool();

		GetMainGame()->addPortal(id, mapIndex, xPos, yPos, anotherId, enabled);
	}
}

void WSManager::processCardUpgradeCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	CharacterCard* card = GetCharacterSystem()->getById(jsonDoc["id"].GetInt());
	int oldSkillLevel = card->skillLevel;

	if (card->accessory != nullptr)
	{
		card->reduceAccessoryData(card->accessory->portalId);
	}

	card->name = jsonDoc["name"].GetString();
	card->rarity = jsonDoc["rarity"].GetInt();
	card->level = 1;
	card->exp = 0;
	card->addExp(jsonDoc["exp"]["value"].GetInt());
	card->approve = jsonDoc["approve"].GetInt();
	card->sp = jsonDoc["sp"].GetInt();
	card->spMax = jsonDoc["spMax"].GetInt();
	card->hp = jsonDoc["hp"].GetInt();
	card->hpMax = jsonDoc["hpMax"].GetInt();
	card->build = jsonDoc["build"].GetInt();
	card->buildMax = jsonDoc["buildMax"].GetInt();
	card->stamina = jsonDoc["stamina"].GetInt();
	card->staminaMax = jsonDoc["staminaMax"].GetInt();
	card->trade = jsonDoc["trade"].GetInt();
	card->tradeMax = jsonDoc["tradeMax"].GetInt();
	card->craft = jsonDoc["craft"].GetInt();
	card->craftMax = jsonDoc["craftMax"].GetInt();
	card->skillLevel = jsonDoc["skill"]["level"].GetInt();
	card->taskPtr = nullptr;
	card->taskId = jsonDoc["taskId"].GetInt();
	card->shards = jsonDoc["fragmentCount"].GetInt();

	card->hpLimit = card->hpMax + card->stamina / 20;
	card->spLimit = card->spMax + card->stamina / 10;

	if (card->accessory != nullptr)
	{
		card->addAccessoryData();
	}

	GetSkillSystem()->checkCharacterUpdate(card);
	GetMissionSystem()->cardLevelReached(card->id, card->level);
	GetMissionSystem()->cardAttainLevelCount(card->level);

	//通知升阶界面更新数据
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_CARD_UPCLASS_VIEW);

	if (oldSkillLevel != card->skillLevel)
		GetMissionSystem()->upgradeCard(card->id);
}

void WSManager::processEcho(const std::string& data)
{
	WSEcho echo = (WSEcho)atoi(data.c_str());

	switch (echo) {
	case WSEcho::NONE:
		break;
	case WSEcho::MAPLOADED:
		GetMainGame()->increateMapLoaded();
		break;
	case WSEcho::INITCOMPLETE:
		GetMainGame()->completeInit();
	default:
		break;

	}
}

void WSManager::processGetHangingDecorationList(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);
	GameMap* map = GetMainGame()->getMapById(mapId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		bool recyclable = jsonDoc[i]["recyclable"].GetBool();
		map->spawnWallDecor(mapX, mapY, itemId, recyclable, id, itemId == 38037 ? true : false);  //TODO 灯暂时写死38037
	}
}

void WSManager::processGetFollowList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		auto animal = GetPlayer()->spawnAnimal(jsonDoc[i].GetInt());
		animal->enableWander(false);
	}
}

void WSManager::processGetTrough(const std::string& data)
{

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int id = jsonDoc["id"].GetInt();
	int mapId = jsonDoc["mapIndex"].GetInt();
	GameMap* map = GetMainGame()->getMapById(mapId);

	AnimalHouse* house = (AnimalHouse*)map->getBuildingById(id);

	for (size_t i = 0; i < jsonDoc["animalList"].Size(); i++) {
		int animalId = jsonDoc["animalList"][i].GetInt();

		Animal* animal = GetMainGame()->getAnimalById(animalId);
		house->addAnimal(animal, animalId);
	}

	auto itr = jsonDoc["fodder"].MemberBegin();
	while (itr != jsonDoc["fodder"].MemberEnd()) {
		int fodderId = atoi(itr->name.GetString());
		int count = itr->value.GetInt();

		house->setFodder(fodderId, count);
		itr++;
	}

	itr = jsonDoc["maxFodderSize"].MemberBegin();
	while (itr != jsonDoc["maxFodderSize"].MemberEnd()) {
		int fodderId = atoi(itr->name.GetString());
		int count = itr->value.GetInt();

		house->addMaxFodder(fodderId, count);
		itr++;
	}

	Portal* portal = GetMainGame()->getPortal(house->getPortalId());

	auto indoorMap = GetMainGame()->getMapById(portal->mapIndex);
	if (indoorMap)
	{
		if (!house->checkFirstCreateMap())
		{
			house->createAllAnimal();
			house->showTroughPrompt(portal->mapIndex);
		}
	}

}

void WSManager::processGetAnimalList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int hp = jsonDoc[i]["hp"].GetInt();
		int64_t growTime = jsonDoc[i]["growthTime"].GetInt64();
		int currentFeedId = jsonDoc[i]["currentFeedId"].IsNull() ? 0 : jsonDoc[i]["currentFeedId"].GetInt();
		int64_t lastEatTime = jsonDoc[i]["lastEatTime"].GetInt64();
		int64_t lastUpdateTime = jsonDoc[i]["lastUpdateTime"].GetInt64();
		int productId = jsonDoc[i]["product"]["id"].GetInt();
		int animalId = jsonDoc[i]["animalType"].GetInt();
		int approve = jsonDoc[i]["approve"].GetInt();

		AnimalData* data = GetAnimalProvider()->getAnimalDataById(animalId);

		Animal* animal = nullptr;

		switch (data->type) {
		case AnimalType::AT_POULTRY:
			animal = Poultry::create();
			break;

		case AnimalType::AT_LIVESTOCK:
			animal = Livestock::create();
			break;
		}

		GetMainGame()->addUpdate(animal);
		animal->enableWander(false);
		animal->retain();
		animal->setAnimalId(animalId);
		animal->setHp((float)hp);
		animal->setProgress(growTime);
		animal->setId(id);
		animal->setFollowId(0);
		animal->setLastUpdate(lastUpdateTime);
		animal->setProduct(productId);
		animal->setApprove(approve);

		Item* fodderData = GetItemProvider()->getData(currentFeedId);

		if (currentFeedId > 0) {
			animal->setCurrentFodderId(currentFeedId);
			int64_t fodderLeft = lastEatTime - lastUpdateTime;
			animal->setFodderLeft(fodderLeft);
		}

		GetMainGame()->addAnimal(id, animal);
	}
}

void WSManager::processGetHatchTaskList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());
	int64_t currentTs = currentTimeMillis();

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int animalType = jsonDoc[i]["animalType"].GetInt();
		int troughId = jsonDoc[i]["troughId"].GetInt();
		int mapIndex = jsonDoc[i]["mapIndex"].GetInt();
		int exp = jsonDoc[i]["exp"].GetInt();
		int64_t spendTime = jsonDoc[i]["spendTime"].GetInt64();
		int64_t startTime = jsonDoc[i]["startTime"].GetInt64();

		IncubatorEntry* entry = new IncubatorEntry();
		entry->animalId = animalType;
		entry->taskId = id;
		entry->startTime = startTime;
		entry->endTime = startTime + spendTime;
		entry->remainTime = entry->endTime - currentTs;

		GameMap* map = GetMainGame()->getMapById(mapIndex);
		PoultryHouse* house = (PoultryHouse*)map->getBuildingById(troughId);
		house->addIncubatorEntry(entry);
	}
}

void WSManager::processGetFeedBin(const std::string& data)
{

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int id = jsonDoc["id"].GetInt();
	int mapId = jsonDoc["mapIndex"].GetInt();
	GameMap* map = GetMainGame()->getMapById(mapId);

	Granary* granary = (Granary*)map->getBuildingById(id);

	auto itr = jsonDoc["fodder"].MemberBegin();
	while (itr != jsonDoc["fodder"].MemberEnd()) {
		int fodderId = atoi(itr->name.GetString());
		int count = itr->value.GetInt();

		granary->setFodder(fodderId, count);
		itr++;
	}

	auto itr2 = jsonDoc["maxFodderSize"].MemberBegin();
	while (itr2 != jsonDoc["maxFodderSize"].MemberEnd()) {
		int fodderId = atoi(itr2->name.GetString());
		int count = itr2->value.GetInt();

		granary->setFodderMax(fodderId, count);
		itr2++;
	}
}

void WSManager::processAddFeedBin(const std::string& data)
{
	if (data == "ERROR") {

		return;
	}

	auto strSplit = splitStringByDelimiter(data, ",");

	int backpackId = stoi(strSplit[2]);
	int amount = stoi(strSplit[3]);

	GetBackpack()->consumeItemByUniqueId(backpackId - 1, amount);
}

void WSManager::processGetTradeList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	auto itr = jsonDoc.MemberBegin();
	while (itr != jsonDoc.MemberEnd()) {
		int id = atoi(itr->name.GetString());
		int sell = itr->value["sell"].GetInt();
		int buy = itr->value["buy"].GetInt();

		Item* data = GetItemProvider()->getData(id);

		if (data->buyLimit != -1) {
			data->buyLeft = buy;
		}
		else {
			data->buyLeft = 99;
		}

		if (data->sellLimit != -1) {
			data->sellLeft = sell;
		}
		else {
			data->sellLeft = 99;
		}

		itr++;
	}
}

void WSManager::processGetRoom(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int mapId = jsonDoc["mapIndex"].GetInt();
	int buildingId = jsonDoc["id"].GetInt();

	GameMap* map = GetMainGame()->getMapById(mapId);
	House* house = (House*)map->getBuildingById(buildingId);

	for (size_t i = 0; i < jsonDoc["npcRoom"].Size(); i++) {
		int npcId = jsonDoc["npcRoom"][i].GetInt();
		int chrId = jsonDoc["cardRoom"][i].GetInt();

		if (npcId == -1 && chrId == -1)
			continue;

		if (npcId > -1) {
			Npc* npc = GetMainGame()->getNpcById(npcId);
			house->setNpc(npc, i);
		}
		else {
			CharacterCard* card = GetCharacterSystem()->getById(chrId);
			house->setCard(card, i);
		}
	}

}

void WSManager::processCheckIn(const std::string& data)
{
	if (data == "ERROR") {
		MsgMgr::getInstance()->showMsg(u8"入住失败。");
		return;
	}

	auto strSplit = splitStringByDelimiter(data, ",");

	int cardId = stoi(strSplit[0]);
	int buildingId = stoi(strSplit[1]);
	int mapId = stoi(strSplit[2]);
	int roomIndex = stoi(strSplit[3]);

	GameMap* map = GetMainGame()->getMapById(mapId);
	House* house = (House*)map->getBuildingById(buildingId);

	CharacterCard* card = GetCharacterSystem()->getById(cardId);
	house->setCard(card, roomIndex);
	house->creatPartner(card, roomIndex);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_HOUSE_VIEW);
	GetMissionSystem()->cardsettle(card->id);

}

void WSManager::processCheckOut(const std::string& data)
{
	if (data == "ERROR") {
		MsgMgr::getInstance()->showMsg(u8"退住失败。");
		return;
	}

	int cardId = stoi(data.c_str());
	CharacterCard* card = GetCharacterSystem()->getById(cardId);
	auto house = card->house;
	house->removeCard(card, false);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_HOUSE_VIEW);
}

void WSManager::processNewNpcCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int likeness = jsonDoc[i]["approve"].GetInt();
		int64_t lastTalkTime = jsonDoc[i]["lastTalkTime"].GetInt64();
		int mapIndex = jsonDoc[i]["mapIndex"].GetInt();
		int roomId = jsonDoc[i]["roomId"].GetInt();
		int roomIndex = jsonDoc[i]["roomIndex"].GetInt();
		Npc* npc = GetMainGame()->addNewNpc(id);

		npc->addFavor(likeness);
		npc->setLastTalkTime(lastTalkTime);
		npc->setMapId(mapIndex);

		GameMap* map = GetMainGame()->getMapById(mapIndex);
		House* house = (House*)map->getBuildingById(roomId);

		house->setNpc(npc, roomIndex);
	}
}

void WSManager::processNpcCheckinCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int likeness = jsonDoc[i]["approve"].GetInt();
		int64_t lastTalkTime = jsonDoc[i]["lastTalkTime"].GetInt64();
		int mapIndex = jsonDoc[i]["mapIndex"].GetInt();
		int roomId = jsonDoc[i]["roomId"].GetInt();
		int roomIndex = jsonDoc[i]["roomIndex"].GetInt();
		Npc* npc = GetMainGame()->getNpcById(id);

		GameMap* map = GetMainGame()->getMapById(mapIndex);
		House* house = (House*)map->getBuildingById(roomId);

		house->setNpc(npc, roomIndex);
	}
}

void WSManager::processRequestGifts(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		ItemType itemType = (ItemType)jsonDoc[i]["type"].GetInt();
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int amount = jsonDoc[i]["amount"].GetInt();
		int quality = jsonDoc[i]["quality"].GetInt();

		Item* item = GetItemProvider()->spawnItemWithAmount(itemId, amount);
		item->setQuality(quality);

		if (itemType == ItemType::WATERCAN) {
			int hp = jsonDoc[i]["hp"].GetInt();
			item->useLeft = hp;
		}

		/*char buf[256];
		sprintf(buf, u8"你收到了%s品%s×%d！", qualityText[quality - 1], item->name.c_str(), amount);
		GetMsgMgr()->showMsg(buf);*/

		GetBackpack()->putAndClean(item);
	}

	GetMainGame()->checkBackpack();
}

void WSManager::processGetMissionList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int targetId = jsonDoc[i]["talkTargetId"].GetInt();
		int scriptId = jsonDoc[i]["talkProgress"].GetInt();
		std::vector<int> requireList;
		std::vector<int> completeList;

		auto itr = jsonDoc[i]["require"].MemberBegin();
		while (itr != jsonDoc[i]["require"].MemberEnd()) {
			int value = itr->value.GetInt();
			requireList.push_back(value);
			itr++;
		}

		auto itr2 = jsonDoc[i]["complete"].MemberBegin();
		while (itr2 != jsonDoc[i]["complete"].MemberEnd()) {
			int value = itr2->value.GetInt();
			completeList.push_back(value);
			itr2++;
		}

		GetMissionSystem()->forceMissionStart(id);

		for (size_t i = 0; i < requireList.size(); i++) {
			if (completeList[i] >= requireList[i]) {
				GetMissionSystem()->forceCompleteObjective(id, i, completeList[i]);
			}
			else {
				GetMissionSystem()->forceSetObjectiveProgress(id, i, completeList[i]);
			}
		}

		if (targetId != 0 && scriptId != 0) {
			GetMissionSystem()->forceSetTargetAndScript(id, targetId, scriptId);
		}
	}
}

void WSManager::processGetCurrentCard(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int cardId = atoi(strSplit[0].c_str());
	int squadId = atoi(strSplit[1].c_str());

	GetCharacterSystem()->setActiveSquad(squadId);
	GetCharacterSystem()->setCurrent(cardId, false);
}

void WSManager::processTreeCallback(const std::string& data)
{
	if (GetVisitSystem()->checkIsVisiting())
		return;

	processGetTreeList(data, true);
}

void WSManager::processResourceCallback(const std::string& data)
{
	if (GetVisitSystem()->checkIsVisiting())
		return;

	processGetMultiBlockResourceList(data, true);

}
void WSManager::processGetMissionTrackingList(const std::string& data)
{
	std::vector<std::string> strSplit = splitStringByDelimiter(data, ",");
	std::vector<int> list;

	for (auto str : strSplit) {
		int val = atoi(str.c_str());

		if (val > -1) {
			if (GetMissionSystem()->getMissionById(val))
			{
				list.push_back(val);
			}
		}
	}

	GetMissionSystem()->setMissionTrackingList(list, false);
}

void WSManager::processBirdsTroubleUpdate(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);
	GameMap* map = GetMainGame()->getMapById(mapId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	int id = jsonDoc["id"].GetInt();
	uint64_t growTime = jsonDoc["growTime"].GetUint64();
	uint64_t lastWaterTime = jsonDoc["lastWaterTime"].GetUint64();
	bool watered = jsonDoc["watered"].GetBool();

	auto crop = map->getCropById(id);
	int mapX, mapY;

	if (watered) {
		crop->water(lastWaterTime);
	}

	crop->setAccGrowTime(growTime);
	crop->getMapPos(&mapX, &mapY);
	map->spawnSparrow(mapX, mapY, 1);
}

void WSManager::processBeastTroubleUpdate(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);
	GameMap* map = GetMainGame()->getMapById(mapId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	int id = jsonDoc["id"].GetInt();
	auto animal = GetMainGame()->getAnimalById(id);

	switch (animal->getAnimalType()) {
	case AnimalType::AT_POULTRY:

		((Poultry*)animal)->knockHideEgg();

		break;
	case AnimalType::AT_LIVESTOCK:
		break;
	}

	int hp = jsonDoc["hp"].GetInt();
	int64_t growTime = jsonDoc["growthTime"].GetInt64();
	int currentFeedId = jsonDoc["currentFeedId"].IsNull() ? 0 : jsonDoc["currentFeedId"].GetInt();
	int64_t lastEatTime = jsonDoc["lastEatTime"].GetInt64();
	int64_t lastUpdateTime = jsonDoc["lastUpdateTime"].GetInt64();
	int productId = jsonDoc["product"]["id"].GetInt();
	int approve = jsonDoc["approve"].GetInt();


	animal->setHp((float)hp);
	animal->setProgress(growTime);
	animal->setLastUpdate(lastUpdateTime);
	animal->setProduct(productId);
	animal->setApprove(approve);

	Item* fodderData = GetItemProvider()->getData(currentFeedId);

	if (currentFeedId > 0) {
		int64_t fodderLeft = lastEatTime - lastUpdateTime;
		animal->setFodderLeft(fodderLeft);
	}

}

void WSManager::processAuth(const std::string& data)
{
	if (data == "-1") { // 无效UID
		UserDefault::getInstance()->deleteValueForKey("token");
		GetMainGame()->failAuth();
		skipIdInfoCallback = true;
	}
	else if (data == "-2") { // 禁用时间段
		auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
		view->setViewType(ANTIADDICTTYPE::INVALIDTIME);
		view->setLocalZOrder(10);
		GetMainGame()->failAuth();
		skipIdInfoCallback = true;
	}
	else if (data == "-3") { // 每日时长超时
		auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
		view->setViewType(ANTIADDICTTYPE::INVALIDTIME);
		view->setLocalZOrder(10);
		GetMainGame()->failAuth();
		skipIdInfoCallback = true;
	}
	else {
		vector<string> split = splitStringByDelimiter(data, ",");

		int64_t serverTs = atoll(split[0].c_str());
		int64_t uid = atoll(split[1].c_str());
		int64_t worldStartTs = atoll(split[2].c_str());
		int64_t localTs = currentTimeMillis();
		int64_t latency = localTs - authTimer;
		CCLOG("Latency: %dms", (int)latency);

		adjustTime(serverTs - latency / 2);
		GetMainGame()->setUid(uid);
		GetMainGame()->setWorldStartTs(worldStartTs);
		GetMainGame()->setPlayerAge(20);

		if (split.size() > 3) {
			int age = atoi(split[3].c_str());
			int64_t time = atoll(split[4].c_str());

			GetMainGame()->setPlayerAge(age);
		}
		skipIdInfoCallback = false;
	}
}

void WSManager::processDevCommand(const std::string& data) {

	int commaPos = data.find(",");
	int version = atoi(data.substr(0, commaPos).c_str());
	auto cmd = (WSCommand)atoi(data.substr(commaPos + 1, commaPos + 5).c_str());
	auto cmdData = data.substr(commaPos + 6);

	switch (cmd) {
	case GET_BACKPACK:
		if (version < checkBackpackVersion)
		{
			return;
		}
		processCheckBackpack(cmdData);
		break;
	case GET_CITY:
		if (version < checkCityVersion)
		{
			return;
		}
		processCheckCity(cmdData);
		break;
	case GET_MAKE_TASK_LIST:
		GetCraftManager()->verifyCraftQueue(const_cast<char*>(cmdData.c_str()));
		break;
	default:
		break;
	}
}

void WSManager::processCheckBackpack(const std::string& data)
{
	int commaPos = data.find(",");
	int version = atoi(data.substr(0, commaPos).c_str());
	std::string jsonStr = data.substr(commaPos + 1);

	if (version < checkBackpackVersion)
	{
		return;
	}

	checkBackpackVersion = 0;

	std::unordered_map<int, ItemCheck> checkMap;

	for (auto& item : backpackCheck) {
		checkMap[item.uniqueId] = item;
	}

	backpackCheck.clear();

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());
	char errorBuf[1024];
	string errorStr;
	bool error = false;

	for (size_t i = 0; i < jsonDoc["list"].Size(); i++) {
		ItemType itemType = (ItemType)jsonDoc["list"][i]["type"].GetInt();
		int itemId = jsonDoc["list"][i]["itemId"].GetInt();
		int amount = jsonDoc["list"][i]["amount"].GetInt();
		int pos = jsonDoc["list"][i]["id"].GetInt() - 1;
		int quality = jsonDoc["list"][i]["quality"].GetInt();
		int portalId = jsonDoc["list"][i]["portalId"].IsNull() ? -1 : jsonDoc["list"][i]["portalId"].GetInt();
		int objectId = jsonDoc["list"][i]["objectId"].IsNull() ? -1 : jsonDoc["list"][i]["objectId"].GetInt();
		int useLeft = itemType == ItemType::WATERCAN ? jsonDoc["list"][i]["hp"].GetInt() : 0;

		ItemCheck& item = checkMap[pos];

		if (item.itemId != itemId ||
			item.amount != amount ||
			item.quality != quality ||
			item.portalId != portalId ||
			item.objectId != objectId ||
			item.useLeft != useLeft
			) {
			sprintf(errorBuf,
				"POS: %3d SERVER\tCLIENT\n"
				"itemId   %6d\t%6d\n"
				"amount   %6d\t%6d\n"
				"quality  %6d\t%6d\n"
				"portalId %6d\t%6d\n"
				"objectId %6d\t%6d\n"
				"useLeft  %6d\t%6d\n",
				pos,
				itemId, item.itemId,
				amount, item.amount,
				quality, item.quality,
				portalId, item.portalId,
				objectId, item.objectId,
				useLeft, item.useLeft);

			errorStr += errorBuf;
			error = true;
		}
	}

	if (error) {
		sendDebugLog(errorStr);
		//Vec2 playerPos = GetPlayer()->getPos();
		//playerPos.y -= 96.0f;

		//MsgMgr::getInstance()->showMsg(u8"
		// 不同步！");

		if (!backpackChecking) {
			getBackpack();
			backpackChecking = true;
		}
	}

}

void WSManager::processCheckCity(const std::string& data)
{

	int commaPos = data.find(",");
	int version = atoi(data.substr(0, commaPos).c_str());
	std::string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	if (version < checkCityVersion)
	{
		return;
	}

	checkCityVersion = 0;

	int exp = jsonDoc["experience"]["value"].GetInt();
	int beauty = jsonDoc["aestheticDegree"].GetInt();
	int money = jsonDoc["money"].GetInt();

	int townLevel = 1;
	int townExp = exp;

	if (townLevel < (int)townLevelSplit.size()) {
		while (townExp >= townLevelSplit[townLevel - 1]) {
			townExp -= townLevelSplit[townLevel - 1];
			townLevel++;

			if (townLevel >= (int)townLevelSplit.size()) {
				goto TOWNLEVELMAX;
			}
		}
	}
	else {
	TOWNLEVELMAX:
		if (townExp > townLevelSplit[townLevel - 1])
			townExp = townLevelSplit[townLevel - 1];
	}

	if (townLevel != townCheck.townLevel ||
		townExp != townCheck.townExp ||
		beauty != townCheck.beauty ||
		money != townCheck.money) {
		char errorBuf[1024];
		sprintf(errorBuf,
			"         SERVER\tCLIENT\n"
			"level    %6d\t%6d\n"
			"townExp  %6d\t%6d\n"
			"beauty   %6d\t%6d\n"
			"money    %6d\t%6d\n"
			"diamond  %6d\t%6d\n",
			townLevel, townCheck.townLevel,
			townExp, townCheck.townExp,
			beauty, townCheck.beauty,
			money, townCheck.money,
			0, 0
		);

		sendDebugLog(errorBuf);

		Vec2 playerPos = GetPlayer()->getPos();
		playerPos.y -= 96.0f;

		MsgMgr::getInstance()->showMsg(u8"城镇不同步！");
		this->getCity();
	}

	memset(&townCheck, 0, sizeof(TownCheck));
}

void WSManager::processGetHangerMap(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);
	GameMap* map = GetMainGame()->getMapById(mapId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	auto itr = jsonDoc.MemberBegin();

	while (itr != jsonDoc.MemberEnd()) {
		int buildingId = atoi(itr->name.GetString());
		int itemId = itr->value["itemId"].GetInt();

		ClothesStand* stand = (ClothesStand*)map->getBuildingById(buildingId);
		stand->setClothes(itemId);

		itr++;
	}
}

void WSManager::processGetSignBoard(const std::string& data)
{
	if (data == "ERROR") {
		MsgMgr::getInstance()->showMsg(u8"包含违禁词！");
		return;
	}

	int commaPos = data.find(",");
	int commaPos2 = data.find(",", commaPos + 1);
	int buildingId = atoi(data.substr(0, commaPos).c_str());
	int mapId = atoi(data.substr(commaPos + 1, commaPos2 - commaPos - 1).c_str());

	if (commaPos2 + 1 == data.size()) {
		return;
	}

	std::string str = data.substr(commaPos2 + 1);

	GameMap* map = GetMainGame()->getMapById(mapId);
	Sign* sign = (Sign*)map->getBuildingById(buildingId);
	sign->setContent(str);
}

void WSManager::processInvitedEat(const std::string& data)
{
	if (data == "ERROR") {
		MsgMgr::getInstance()->showMsg(u8"今天已经吃过席啦，明天再来吧！");
		return;
	}

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int likeness = jsonDoc[i]["approve"].GetInt();

		Npc* npc = GetMainGame()->getNpcById(id);

		int likeDiff = likeness - npc->getFavor();
		npc->setFavor(likeness);

		char buf[256];
		sprintf(buf, u8"「%s」参加吃席，好感度+%d！", npc->getNpcName().c_str(), likeDiff);

		MsgMgr::getInstance()->showMsg(buf);
	}

	GetMainGame()->subInviteEatMoney();
	GetMissionSystem()->invitedEat();

	MissionSystem::getInstance()->inviteParty();

}

void WSManager::processGetBulletinBoardItemList(const std::string& data)
{
	if (GetVisitSystem()->checkIsVisiting()) {  //探访时不打开公告栏
		return;
	}
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		BillboardExchange* exchange = new BillboardExchange();

		exchange->id = jsonDoc[i]["id"].GetInt();

		exchange->input.rewardDiamond = jsonDoc[i]["input"]["rechargeableCoin"].GetInt();
		exchange->input.rewardExp = jsonDoc[i]["input"]["cityExp"].GetInt();
		exchange->input.rewardMoney = jsonDoc[i]["input"]["money"].GetInt();

		for (size_t j = 0; j < jsonDoc[i]["input"]["itemList"].Size(); j++) {
			RewardItem item;

			item.itemId = jsonDoc[i]["input"]["itemList"][j]["itemId"].GetInt();
			item.amount = jsonDoc[i]["input"]["itemList"][j]["amount"].GetInt();

			exchange->input.items.push_back(item);
		}


		exchange->output.rewardDiamond = jsonDoc[i]["reward"]["rechargeableCoin"].GetInt();
		exchange->output.rewardExp = jsonDoc[i]["reward"]["cityExp"].GetInt();
		exchange->output.rewardMoney = jsonDoc[i]["reward"]["money"].GetInt();

		for (size_t j = 0; j < jsonDoc[i]["reward"]["itemList"].Size(); j++) {
			RewardItem item;

			item.itemId = jsonDoc[i]["reward"]["itemList"][j]["itemId"].GetInt();
			item.amount = jsonDoc[i]["reward"]["itemList"][j]["amount"].GetInt();

			exchange->output.items.push_back(item);
		}

		GetMainGame()->addBillboardExchange(exchange);
	}
}

void WSManager::processGetVisitingUserInformation(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	if (jsonDoc.IsNull()) {
		Node* view = UIViewMgr::getInstance()->getView(uiType::UI_PIERVISI_VIEW);
		((PierVisitView*)view)->getRandomNull();
		return;
	}
	DistanceUserEntity* due = new DistanceUserEntity();

	due->uid = jsonDoc["uid"].GetUint64();
	due->distance = jsonDoc["distance"].GetInt();
	due->playerLevel = jsonDoc["playerLevel"].GetInt();
	due->name = jsonDoc["username"].GetString();
	GetVisitSystem()->setCurrentTarget(due);

}

void WSManager::processGetVisitingTaskList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GetVisitSystem()->clearTaskList();

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		VisitingTask task;

		task.id = jsonDoc[i]["id"].GetInt();
		task.startTime = jsonDoc[i]["startTime"].GetUint64();
		task.distance = jsonDoc[i]["distance"].GetInt();
		task.cardId = jsonDoc[i]["cardId"].GetInt();
		task.targetUid = jsonDoc[i]["targetUid"].GetUint64();
		task.username = jsonDoc[i]["username"].GetString();
		GetVisitSystem()->addTask(task);

		auto taskPtr = GetVisitSystem()->getTaskById(task.id);
		auto card = GetCharacterSystem()->getById(task.cardId);
		card->taskId = task.id;
		card->taskType = TaskType::VISIT;
		card->taskPtr = taskPtr;
	}
}

void WSManager::processGetPostRandomCharacter(const std::string& data)
{
	// TODO
}

void WSManager::processGetLimitRoom(const std::string& data)
{
	int commaPos = data.find(",");
	int commaPos2 = data.find(",", commaPos + 1);
	int buildingId = atoi(data.substr(0, commaPos).c_str());
	int mapId = atoi(data.substr(commaPos + 1, commaPos2 - commaPos - 1).c_str());

	std::string jsonStr = data.substr(commaPos2 + 1);

	GameMap* map = GetMainGame()->getMapById(mapId);
	Hotel* hotel = (Hotel*)map->getBuildingById(buildingId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	for (int i = 0; i < hotel->getMaxResidents(); i++) {
		int64_t roomTime = jsonDoc["expire"][i].GetInt64();
		int cardId = jsonDoc["cardRoom"][i].GetInt();

		if (roomTime > -1) {
			hotel->setRoomTime(i, (uint64_t)roomTime);
		}

		if (cardId > -1) {
			hotel->setCard(GetCharacterSystem()->getById(cardId), i);
		}
	}
}

void WSManager::processStartVisitingTask(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	VisitingTask task;

	task.id = jsonDoc["id"].GetInt();
	task.cardId = jsonDoc["cardId"].GetInt();
	task.distance = jsonDoc["distance"].GetInt();
	task.startTime = jsonDoc["startTime"].GetUint64();
	task.targetUid = jsonDoc["targetUid"].GetUint64();
	task.username = jsonDoc["username"].GetString();
	GetVisitSystem()->addTask(task);
	auto taskPtr = GetVisitSystem()->getTaskById(task.id);
	auto card = GetCharacterSystem()->getById(task.cardId);
	card->taskId = task.id;
	card->taskType = TaskType::VISIT;
	card->taskPtr = taskPtr;
	card->hidePartner();

	bool isTaskType = false;
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_DUIWU_LIST_VIEW, (void*)isTaskType, 0);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_PIERVISIT_CALLBACK_VIEW);

	GetMsgMgr()->showMsg(u8"派遣成功，正在前往了。");

	GetGuideController()->guideChecker(103);
	getLastVisitingTime();
}

void WSManager::processStartVisiting(const std::string& data)
{
	if (data == "OK") {
		GetVisitSystem()->setCurrentTarget(nullptr);
		GetMainGame()->reloadMap();
	}
	else {
		GetVisitSystem()->cancelVisit();
	}
}

void WSManager::processStopVisiting(const std::string& data)
{
	if (data == "OK") {
		GetVisitSystem()->leaveVisitCallback();
		GetMainGame()->reloadMap();
		int tempVisitId = GetVisitSystem()->getAutofinishid();
		if (tempVisitId != -1)
		{
			GetVisitSystem()->endVisit(tempVisitId);
		}
	}
}

void WSManager::processBuyItemCallback(const std::string& data)
{
	if (data == "ERROR")
	{
		GetMsgMgr()->showMsg("购买失败");
		return;
	}
	int commaPos = data.find(",");
	int itemId = atoi(data.substr(0, commaPos).c_str());
	int amount = atoi(data.substr(commaPos + 1).c_str());

	GetShopSystem()->buyItemCallback(itemId, amount);

}

void WSManager::processSellItemCallback(const std::string& data)
{
	if (data == "ERROR")
	{
		GetMsgMgr()->showMsg("售卖失败");
		return;
	}
	int commaPos = data.find(",");
	int itemId = atoi(data.substr(0, commaPos).c_str());
	int amount = atoi(data.substr(commaPos + 1).c_str());

	GetShopSystem()->sellItemCallback(itemId, amount);
}

void WSManager::processBuyAnimalCallback(const std::string& data)
{
	if (data == "ERROR")
	{
		GetMsgMgr()->showMsg("购买动物失败");
		return;
	}
	int commaPos = data.find(",");
	int animalId = atoi(data.substr(0, commaPos).c_str());
	int amount = atoi(data.substr(commaPos + 1).c_str());

	GetAnimalProvider()->buyAnimalCallback(animalId, amount);
}

void WSManager::processBuyNightMarketGoodsCallback(const std::string& data)
{
	int commaPos = data.find(",");
	int64_t buyerUid = atoll(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	int id = jsonDoc["id"].GetInt();
	int amount = jsonDoc["amount"].GetInt();
	auto nmEntry = GetShopSystem()->getNightMarketEntryById(id);


	if (buyerUid == GetMainGame()->getUid()) {
		Item* item = GetItemProvider()->spawnItemWithAmount(nmEntry->itemId, amount);

		/*char buf[256];
		sprintf(buf, u8"买到了%s×%d。", item->name.c_str(), amount);
		GetMsgMgr()->showMsg(buf);*/

		GetBackpack()->putAndClean(item);
		double subMoneyd = nmEntry->originalPrice * nmEntry->discount * amount;

		auto card = GetCharacterSystem()->getCurrent();
		double coeff = card->getTradeCoefficient();
		GetSkillSystem()->checkMutualMarketBuy(nmEntry->itemId, &coeff, card);
		int subMoney = (int)floor((subMoneyd * (1.0 - coeff)));

		GetMainGame()->addMoney(subMoney * -1, false);
		GetMissionSystem()->nightMarketTradeCount();

		if (GetVisitSystem()->checkIsVisiting()) {
			GetMissionSystem()->outboundShopping();
		}
	}

	nmEntry->amount -= amount;

	if (nmEntry->amount == 0)
		GetShopSystem()->removeNightMarketEntry(id);

	// 这里插入刷新夜市界面
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_NIGHT_MARKET_VIEW);
}

void WSManager::processGetNightMarketGoodsList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GetShopSystem()->clearNightMarketEntries();

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		NightMarketGoods good;

		good.id = jsonDoc[i]["id"].GetInt();
		good.itemId = jsonDoc[i]["itemId"].GetInt();
		good.amount = jsonDoc[i]["amount"].GetInt();
		good.originalPrice = jsonDoc[i]["originalPrice"].GetInt();
		good.discount = jsonDoc[i]["discount"].GetDouble();
		good.totalPrice = (int)(good.amount * good.originalPrice * good.discount);
		good.itemName = GetItemProvider()->getData(good.itemId)->name;

		char buf[256];
		sprintf(buf, "item_%d", good.itemId);
		good.spriteName = buf;

		GetShopSystem()->addNightMarketEntry(good);
	}
}

void WSManager::processGetMutualMarketGoodsList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GetShopSystem()->clearMutualMarketEntries();

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		MutualMarketGoods good;

		good.id = jsonDoc[i]["id"].GetInt();
		good.itemId = jsonDoc[i]["itemId"].GetInt();
		good.totalPrice = jsonDoc[i]["totalPrice"].GetInt();
		good.remainingItemAmount = jsonDoc[i]["remainingItemAmount"].GetInt();
		good.itemAmount = jsonDoc[i]["itemAmount"].GetInt();
		good.itemName = GetItemProvider()->getData(good.itemId)->name;

		char buf[256];
		sprintf(buf, "item_%d", good.itemId);
		good.spriteName = buf;

		GetShopSystem()->addMutualMarketEntry(good);
	}
}

void WSManager::processBuyMutualMarketGoodsCallback(const std::string& data)
{
	int commaPos = data.find(",");
	int64_t buyerUid = atoll(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	int id = jsonDoc["id"].GetInt();
	int amount = jsonDoc["remainingItemAmount"].GetInt();
	auto mmEntry = GetShopSystem()->getMutualMarketEntryById(id);

	if (buyerUid == GetMainGame()->getUid()) {
		Item* item = GetItemProvider()->spawnItemWithAmount(mmEntry->itemId, amount);
		/*char buf[256];
		sprintf(buf, u8"买到了%s×%d。", item->name.c_str(), amount);
		GetMsgMgr()->showMsg(buf);*/

		GetBackpack()->putAndClean(item);
		double subMoneyd = ((double)mmEntry->totalPrice / mmEntry->itemAmount * amount);
		auto card = GetCharacterSystem()->getCurrent();
		double coeff = card->getTradeCoefficient();
		GetSkillSystem()->checkMutualMarketBuy(mmEntry->itemId, &coeff, card);
		int subMoney = (int)floor((subMoneyd * (1.0 - coeff)));
		GetMainGame()->addMoney(subMoney * -1, false);

		if (GetVisitSystem()->checkIsVisiting()) {
			GetMissionSystem()->outboundShopping();
			GetMissionSystem()->friendMutualMarketBuy();
		}
	}

	mmEntry->remainingItemAmount -= amount;

	if (mmEntry->remainingItemAmount == 0)
		GetShopSystem()->removeNightMarketEntry(id);

	GetWSManager()->getMutualMarketMoneyBox(GetVisitSystem()->getCurVisitUid());
	GetWSManager()->getDock();
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_HUSHI_MARKET_VIEW);
}

void WSManager::processGetMutualMarketBoxMoney(const std::string& data)
{
	int money = atoi(data.c_str());
	GetShopSystem()->setMoney(money);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_HUSHI_MONEY_VIEW);
}

void WSManager::processGetFriendMutualMarketGoods(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GetShopSystem()->clearFriendMutualMarketEntries();

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		MutualMarketGoods good;

		good.id = jsonDoc[i]["id"].GetInt();
		good.itemId = jsonDoc[i]["itemId"].GetInt();
		good.totalPrice = jsonDoc[i]["totalPrice"].GetInt();
		good.remainingItemAmount = jsonDoc[i]["remainingItemAmount"].GetInt();
		good.itemAmount = jsonDoc[i]["itemAmount"].GetInt();
		good.itemName = GetItemProvider()->getData(good.itemId)->name;

		char buf[256];
		sprintf(buf, "item_%d", good.itemId);
		good.spriteName = buf;

		GetShopSystem()->addFriendMutualMarketEntry(good);
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_FRIEND_MUTUAL_MARKET_GOODS);
}

void WSManager::processDelistingMutualMarketGoodsCallback(const std::string& data)
{
	int id = atoi(data.c_str());

	if (GetVisitSystem()->checkIsVisiting()) {
		auto mmEntry = GetShopSystem()->getMutualMarketEntryById(id);
		if (mmEntry != nullptr) {
			Item* item = GetItemProvider()->spawnItemWithAmount(mmEntry->itemId, mmEntry->remainingItemAmount);

			/*char buf[256];
			sprintf(buf, u8"买到了%s×%d。", item->name.c_str(), item->amount);
			GetMsgMgr()->showMsg(buf);*/

			GetBackpack()->putAndClean(item);
		}
	}

	GetShopSystem()->removeMutualMarketEntry(id);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_HUSHI_MARKET_VIEW);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);
}

void WSManager::processUploadMutualMarketGoods(const std::string& data)
{
	if (data == "OK") {
		GetShopSystem()->mutualUploadCallback();
	}
}

void WSManager::processIdInfoCallback(const std::string& data)
{
	if (data == "ERROR") {
		GetMainGame()->enterAdultCheck();
	}
	else if (!skipIdInfoCallback) {
		GetMainGame()->finishAuth();
	}
}

void WSManager::processGetCarpetPositionList(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);
	GameMap* map = GetMainGame()->getMapById(mapId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int id = jsonDoc[i]["id"].GetInt();
		int beauty = 0;

		if (jsonDoc[i].HasMember("beauty"))
			beauty = jsonDoc[i]["beauty"].GetInt();
		else
			beauty = GetItemProvider()->getData(itemId)->values[0];

		auto carpet = map->spawnCarpet(mapX, mapY, itemId, false, id);
		carpet->setBeauty(beauty);
	}
}

void WSManager::processGetTreasureList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {

		int id = jsonDoc[i]["id"].GetInt();
		bool isNew = true;
		Accessory* accessory = nullptr;
		if (GetAccessoriesManager()->checkData(id))
		{
			accessory = GetAccessoriesManager()->getData(id);
			isNew = false;
		}
		else
		{
			accessory = new Accessory();
			isNew = true;
		}

		accessory->id = jsonDoc[i]["id"].GetInt();
		accessory->itemId = jsonDoc[i]["itemId"].GetInt();
		accessory->name = jsonDoc[i]["name"].GetString();
		accessory->exp = jsonDoc[i]["exp"]["value"].GetInt();
		accessory->level = 1;

		accessory->build = jsonDoc[i]["build"].GetInt();
		accessory->stamina = jsonDoc[i]["stamina"].GetInt();
		accessory->trade = jsonDoc[i]["trade"].GetInt();
		accessory->craft = jsonDoc[i]["craft"].GetInt();

		accessory->buildMax = jsonDoc[i]["buildMax"].GetInt();
		accessory->staminaMax = jsonDoc[i]["staminaMax"].GetInt();
		accessory->tradeMax = jsonDoc[i]["tradeMax"].GetInt();
		accessory->craftMax = jsonDoc[i]["craftMax"].GetInt();

		accessory->rarity = jsonDoc[i]["rarity"].GetInt();
		accessory->description = GetAccessoriesManager()->getTemplateData(accessory->itemId)->description;

		accessory->skillLevel = jsonDoc[i]["skill"]["level"].GetInt();
		accessory->skillLevelLimit = jsonDoc[i]["skill"]["levelLength"].GetInt();
		accessory->skillName = jsonDoc[i]["skill"]["name"].GetString();
		accessory->skillDescription = jsonDoc[i]["skill"]["description"].GetString();

		auto itr = jsonDoc[i]["skill"]["checkEffectMap"].MemberBegin();

		while (itr != jsonDoc[i]["skill"]["checkEffectMap"].MemberEnd()) {
			int check = atoi(itr->name.GetString());
			int effect = itr->value.GetInt();

			accessory->skillMap[check] = effect;

			itr++;
		}

		for (size_t j = 0; j < jsonDoc[i]["levelLimitList"].Size(); j++) {
			accessory->levelLimitList.push_back(jsonDoc[i]["levelLimitList"][j].GetInt());
		}

		accessory->calculateLevel();

		if (isNew)
		{
			GetAccessoriesManager()->addData(accessory);
		}
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::GETDATE_TREASURE_VIEW);

}

void WSManager::processTreasureUpgrade(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int id = jsonDoc["id"].GetInt();
	CharacterCard* card = nullptr;

	Accessory* accessory = GetAccessoriesManager()->getData(id);

	if (accessory->cardId > 0)
	{
		card = GetCharacterSystem()->getById(accessory->cardId);
		card->reduceAccessoryData(accessory->id);
	}

	accessory->level = 1;
	accessory->exp = jsonDoc["exp"]["value"].GetInt();
	accessory->build = jsonDoc["build"].GetInt();
	accessory->stamina = jsonDoc["stamina"].GetInt();
	accessory->trade = jsonDoc["trade"].GetInt();
	accessory->craft = jsonDoc["craft"].GetInt();

	accessory->skillLevel = jsonDoc["skill"]["level"].GetInt();

	accessory->calculateLevel();

	if (card != nullptr)
	{
		card->addAccessoryData();
	}

	char buf[128];
	sprintf(buf, u8"升到了%d阶", accessory->skillLevel);
	GetMsgMgr()->showMsg(buf);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TREASURE_UPCLASS_VIEW);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_CARD_ACCESSORY_VIEW);
}

void WSManager::processGetBoxPositionList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	std::vector<int> bidList;

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["bid"].GetInt();
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int mapIndex = jsonDoc[i]["mapIndex"].GetInt();
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();

		GameMap* map = GetMainGame()->getMapById(mapIndex);
		Box* box = GetMainGame()->getBox(id);

		if (box == nullptr)
			map->spawnBox(mapX, mapY, itemId, nullptr, id);
		else
		{
			box->setMapPos(mapX, mapY);
			box->setPos(Vec2(mapX * 128.0f, (mapY + 1) * 128.0f));
			map->addBox(box);
		}


		bidList.push_back(id);
	}

	auto boxList = GetMainGame()->getBoxList();
	std::vector<int> eraseList;

	for (auto& entry : boxList) {
		Box* box = entry.second;

		if (!Contains(bidList, box->getId())) {
			eraseList.push_back(box->getId());
			box->clear();
			box->release();
			box->removeFromParent();
		}
	}

	for (auto& eraseBid : eraseList)
		boxList.erase(eraseBid);
}

void WSManager::processGetTreasureId(const std::string& data)
{
	int commaPos = data.find(",");
	int backpackId = atoi(data.substr(0, commaPos).c_str());
	int portalId = atoi(data.substr(commaPos + 1).c_str());

	auto item = GetBackpack()->getByPosition(backpackId - 1);
	item->portalId = portalId;
}

void WSManager::processGetUpgradeAccessoryLevel(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int id = jsonDoc["id"].GetInt();
	CharacterCard* card = nullptr;

	Accessory* accessory = GetAccessoriesManager()->getData(id);

	if (accessory->cardId > 0)
	{
		card = GetCharacterSystem()->getById(accessory->cardId);
		card->reduceAccessoryData(accessory->id);
	}
	accessory->level = 1;
	accessory->exp = jsonDoc["exp"]["value"].GetInt();
	accessory->build = jsonDoc["build"].GetInt();
	accessory->stamina = jsonDoc["stamina"].GetInt();
	accessory->trade = jsonDoc["trade"].GetInt();
	accessory->craft = jsonDoc["craft"].GetInt();

	accessory->skillLevel = jsonDoc["skill"]["level"].GetInt();

	accessory->calculateLevel();

	if (card != nullptr)
	{
		card->addAccessoryData();
	}

	char buf[128];
	sprintf(buf, u8"升到了%d级", accessory->level);
	GetMsgMgr()->showMsg(buf);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TREASURE_UPSKILL_VIEW);
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_CARD_ACCESSORY_VIEW);
}

void WSManager::processGetItemInbox(const std::string& data)
{
	int commaPos = data.find(",");
	int boxId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Box* box = GetMainGame()->getBox(boxId);
	auto& items = box->getItems();

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		ItemType itemType = (ItemType)jsonDoc[i]["type"].GetInt();
		int itemId = jsonDoc[i]["itemId"].GetInt();
		int amount = jsonDoc[i]["amount"].GetInt();
		int pos = jsonDoc[i]["id"].GetInt() - 1;
		int quality = jsonDoc[i]["quality"].GetInt();
		int portalId = jsonDoc[i]["portalId"].IsNull() ? -1 : jsonDoc[i]["portalId"].GetInt();
		int objectId = jsonDoc[i]["objectId"].IsNull() ? -1 : jsonDoc[i]["objectId"].GetInt();

		Item* item = GetItemProvider()->spawnItemWithAmount(itemId, amount);
		item->uniqueId = pos;
		item->setQuality(quality);
		item->portalId = portalId;
		item->objectId = objectId;

		if (itemType == ItemType::WATERCAN) {
			int hp = jsonDoc[i]["hp"].GetInt();
			item->useLeft = hp;
		}

		items[pos] = item;

		if (!jsonDoc[i]["filler"].IsNull()) {
			int fillerItemId = jsonDoc[i]["filler"]["itemId"].GetInt();
			int fillerAmount = jsonDoc[i]["filler"]["amount"].GetInt();
			int fillerQuality = jsonDoc[i]["filler"]["quality"].GetInt();

			Item* filler = GetItemProvider()->spawnItemWithAmount(fillerItemId, fillerAmount);
			filler->setQuality(fillerQuality);

			item->attachment = filler;
		}
	}
}

void WSManager::processGetVisitingHistoryList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GetVisitSystem()->clearHistory();

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		VisitingTaskHistory history;
		history.targetUid = jsonDoc[i]["targetUid"].GetUint64();
		history.startTime = jsonDoc[i]["startTime"].GetUint64();
		history.name = jsonDoc[i]["username"].GetString();
		history.avatar = jsonDoc[i]["avatar"].GetInt();
		history.playerLevel = jsonDoc[i]["playerLevel"].GetInt();

		GetVisitSystem()->addHistory(history);
	}
}

void WSManager::processGetMakeLimitList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int recipeId = jsonDoc[i]["recipeId"].GetInt();
		int count = jsonDoc[i]["count"].GetInt();

		GetCraftManager()->setRecipeMakeCount(recipeId, count);
	}
}

void WSManager::processUpgradeBuilding(const std::string& data)
{
	bool breakFlag = false;
	CraftQueue* queue = nullptr;
	prepareCrafting(data, breakFlag, queue);
}

void WSManager::processUpgradeBuildingFinish(const std::string& data)
{
	if (data == "ERROR") {
		GetMsgMgr()->showMsg(u8"完成队列失败！");
		return;
	}

	int commaPos = data.find(",");
	int commaPos2 = data.find(",", commaPos + 1);
	int taskId = atoi(data.substr(0, commaPos).c_str());
	int mapId = atoi(data.substr(commaPos + 1, commaPos2 - commaPos).c_str());
	string jsonStr = data.substr(commaPos2 + 1);

	auto craftTask = GetCraftManager()->getCraftQueueByTaskId(taskId);
	auto oldBuilding = craftTask->workingBuilding;
	int oldPortalId = oldBuilding->getPortalId();

	GetCraftManager()->finishQueueCallback(taskId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	int typeId = jsonDoc["typeId"].GetInt();
	int ownerid = jsonDoc["ownerId"].GetInt();
	int mapX = jsonDoc["mapPosition"]["x"].GetInt();
	int mapY = jsonDoc["mapPosition"]["y"].GetInt();
	int id = jsonDoc["id"].GetInt();

	GameMap* map = GetMainGame()->getMapById(mapId);

	int oldAnotherPortalId = oldPortalId == 0 ? 0 : GetMainGame()->getPortal(oldPortalId)->anotherId;
	auto buildingData = GetBuildingDataProvider()->getEntryById(typeId);

	PlaceData placeData;
	placeData.mapX = mapX;
	placeData.mapY = mapY;
	placeData.width = buildingData->mapWidth;
	placeData.height = buildingData->mapHeight;

	for (int i = 0; i < placeData.height; i++) {
		int targetY = placeData.height - i - 1;
		memcpy(placeData.data + targetY * placeData.width, buildingData->mapOccupyData + i * placeData.width, placeData.width);
	}

	int oldMapX, oldMapY;
	oldBuilding->getMapPos(&oldMapX, &oldMapY);
	auto oldBuildingData = oldBuilding->getBuildingData();

	bool isforBreak = false;
	for (int i = oldMapX; i < oldMapX + oldBuildingData->mapWidth; i++)
	{
		if (isforBreak)
			break;

		for (int j = oldMapY - oldBuildingData->mapHeight; j < oldMapY; j++)
		{
			MAPBLOCK* block = map->getMapBlock(i, j);
			if (block->index == oldBuilding->getId())
			{
				oldMapX = i;
				oldMapY = j;
				isforBreak = true;
				break;
			}

		}
	}

	map->shoveTile(oldMapX, oldMapY, 0, 1, 1, true);
	auto obj = map->spawnBuilding(typeId, mapX * 128.0f, mapY * 128.0f + 128.0f, &placeData, id, -1, false);
	obj->setOwnerId(ownerid);
	auto itemData = GetItemProvider()->getData(typeId);
	obj->setBeauty(itemData->values[0]);

	if (flexibleBuildingNPCList.find(typeId) != flexibleBuildingNPCList.end())
	{
		NPCBehavior* NPCBehavior_ = BehaviorController::getInstance()->getNPCBehavior();
		std::vector<BuildingNpcInfo>& vtr = flexibleBuildingNPCList[typeId];

		Vec2 PortalPos = GetMainGame()->getCurrentMap()->getPortalPosById(obj->getPortalId());
		for (size_t i = 0; i < vtr.size(); i++)
		{
			auto npc = GetMainGame()->getNpcById(vtr[i].npcId);
			if (npc && npc->getParentMap()->getId() == GetMainGame()->getCurrentMapId())
			{
				NPCBehaviorTarget target;
				target.mapId = vtr[i].mapId;
				target.mapX = vtr[i].posX;
				target.mapY = vtr[i].posY;
				target.npcId = vtr[i].npcId;
				NPCBehavior_->add(target);

				npc->moveToNewBuilding((int)PortalPos.x, (int)PortalPos.y);
			}
		}
	}

	if (obj->getBuildingId() == 22064) //矿洞
	{
		int i = obj->getId();
		MineSystemController::getInstance()->setData(obj, mapId, i);
	}

	GetMainGame()->addBeauty(itemData->values[0]);
	if (oldPortalId > 0) GetMainGame()->removePortal(oldPortalId);
	if (oldAnotherPortalId > 0) GetMainGame()->removePortal(oldAnotherPortalId);

	getNpcList();
	if (typeId == 22013 || typeId == 22014 || typeId == 22091 || typeId == 22092 || typeId == 22093)//升级自宅小屋才需要
	{
		getBoxPositionList();
	}

	GetBuildController()->updateRedPoint();
}

void WSManager::processGetLastVisitingTime(const std::string& data)
{
	uint64_t serverData = (uint64_t)strtoull(data.c_str(), NULL, 10);
	GetVisitSystem()->setServerData(serverData);
}

void WSManager::processCharacterCardPoolLottery(const std::string& data)
{

}

void WSManager::processRewardCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	char buf[256];
	int cityExp = jsonDoc["cityExp"].GetInt();
	int cardExp = jsonDoc["cardExp"].GetInt();
	int money = jsonDoc["money"].GetInt();
	int rechargeableCoin = jsonDoc["rechargeableCoin"].GetInt();

	bool checkMoney = money == 0 ? false : true;
	if (checkMoney)
	{
		GetMainGame()->addMoney(money, false);
	}
	GetMainGame()->addTownExp(cityExp, false);
	GetMainGame()->addDiamond(rechargeableCoin, false);

	//if (cityExp > 0 && !MainGame::getInstance()->isMaxTownLvl()) {
	//	sprintf(buf, u8"获得了%d城镇经验！", cityExp);
	//	GetMsgMgr()->showMsg(buf);
	//}

	/*if (cityExp > 0) {
		sprintf(buf, u8"获得了%d城镇经验！", cityExp);
		GetMsgMgr()->showMsg(buf);
	}

	if (money > 0) {
		sprintf(buf, u8"获得了%d铜钱！", money);
		GetMsgMgr()->showMsg(buf);
	}*/

	if (rechargeableCoin > 0) {
		sprintf(buf, u8"获得了%d宝玉！", rechargeableCoin);
		GetMsgMgr()->showMsg(buf);
	}

	for (size_t i = 0; i < jsonDoc["itemList"].Size(); i++) {
		int itemId = jsonDoc["itemList"][i]["itemId"].GetInt();
		int amount = jsonDoc["itemList"][i]["amount"].GetInt();

		auto item = GetItemProvider()->spawnItemWithAmount(itemId, amount);

		/*sprintf(buf, u8"获得了%s×%d！", item->name.c_str(), amount);
		GetMsgMgr()->showMsg(buf);*/

		GetBackpack()->putAndClean(item);
	}
	for (size_t i = 0; i < jsonDoc["cardExpMap"].Size(); i++) {
		int cardid = jsonDoc["cardExpMap"][i]["targetId"].GetInt();
		int cardexp = jsonDoc["cardExpMap"][i]["value"].GetInt();
		if (cardexp != 0)
		{
			auto card = GetCharacterSystem()->getById(cardid);
			card->addExp(cardexp);
			sprintf(buf, u8"%s获得了%d经验！", GetCharacterSystem()->getById(cardid)->name.c_str(), cardexp);
			GetMsgMgr()->showMsg(buf);
		}
	}
	for (size_t i = 0; i < jsonDoc["cardApproveMap"].Size(); i++) {
		int cardid = jsonDoc["cardApproveMap"][i]["targetId"].GetInt();
		int cardapprove = jsonDoc["cardApproveMap"][i]["value"].GetInt();
		if (cardapprove != 0)
		{
			auto card = GetCharacterSystem()->getById(cardid);
			card->approve += cardapprove;
			sprintf(buf, u8"%s好感度+%d！", GetCharacterSystem()->getById(cardid)->name.c_str(), cardapprove);
			GetMsgMgr()->showMsg(buf);
		}
	}
	for (size_t i = 0; i < jsonDoc["npcApproveMap"].Size(); i++) {
		int npcid = jsonDoc["npcApproveMap"][i]["targetId"].GetInt();
		int npcapprove = jsonDoc["npcApproveMap"][i]["value"].GetInt();
		if (npcapprove != 0)
		{
			Npc* tempNpc = GetMainGame()->getNpcById(npcid);
			tempNpc->addFavor(npcapprove);
			sprintf(buf, u8"%s好感度+%d！", tempNpc->getNpcName().c_str(), npcapprove);
			GetMsgMgr()->showMsg(buf);
		}
	}

	if (jsonDoc["itemList"].Size() > 0)
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);
}

void WSManager::processDelistMutualMarketGoods(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	MutualMarketGoods good;

	good.id = jsonDoc["id"].GetInt();
	good.itemId = jsonDoc["itemId"].GetInt();
	good.totalPrice = jsonDoc["totalPrice"].GetInt();
	good.remainingItemAmount = jsonDoc["remainingItemAmount"].GetInt();
	good.itemAmount = jsonDoc["itemAmount"].GetInt();

	GetShopSystem()->mutualDelistCallback(good);
}

void WSManager::processGetRecipeIdList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int value = jsonDoc[i].GetInt();

		GetCraftManager()->unlockRecipe(value);
	}
}

void WSManager::processDestroyItem(const std::string& data)
{
	if (data == "ERROR") {
		MsgMgr::getInstance()->showMsg(u8"销毁失败！");
		return;
	}

	int index = atoi(data.c_str()) - 1;
	Item** block = GetBackpack()->getAll();

	GetMissionSystem()->destroy(block[index]->itemId, block[index]->amount);

	if (block[index]->type == ItemType::ACCESSORIES) {
		GetAccessoriesManager()->deleteData(block[index]->portalId);
	}

	delete block[index];
	block[index] = nullptr;
}

void WSManager::processDestroyBoxItem(const std::string& data)
{
	if (data == "ERROR") {
		MsgMgr::getInstance()->showMsg(u8"销毁失败！");
		return;
	}

	auto strSplit = splitStringByDelimiter(data, ",");
	int boxId = atoi(strSplit[0].c_str());
	int index = atoi(strSplit[1].c_str()) - 1;

	auto box = GetMainGame()->getBox(boxId);
	auto& block = box->getItems();

	if (block[index]->type == ItemType::ACCESSORIES) {
		GetAccessoriesManager()->deleteData(block[index]->portalId);
	}

	delete block[index];
	block[index] = nullptr;

	bool empty = true;
	for (auto& item : block) {
		if (item != nullptr) {
			empty = false;
			break;
		}
	}

	if (empty)
		GetMissionSystem()->emptybox(box->getBuildingId());
}

void WSManager::processGetMakeHistory(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	auto itr = jsonDoc.MemberBegin();
	while (itr != jsonDoc.MemberEnd()) {
		int itemId = atoi(itr->name.GetString());
		int value = itr->value.GetInt();

		GetItemProvider()->setCumulativeCraft(itemId, value);

		itr++;
	}
}

void WSManager::processGetFlowerList(const std::string& data, bool updateMap)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);


	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["id"].GetInt();
		int cropId = jsonDoc[i]["cropId"].GetInt();
		uint64_t growTime = jsonDoc[i]["growTime"].GetUint64();
		uint64_t lastUpdateTime = jsonDoc[i]["lastUpdateTime"].GetUint64();
		int currentStageIndex = jsonDoc[i]["currentStageIndex"].GetInt();
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();

		Flower* flower = map->plantFlower(mapX, mapY, cropId, nullptr, id);
		flower->setStage(currentStageIndex);
		flower->setAccGrowTime(growTime);
		flower->setLastUpdate(lastUpdateTime);
		map->addFarmList(mapX, mapY, ObjectListType::OLT_FLOWER, flower->isHarvestable());  //服务端懒更新 这里的数据未必是最新.....
	}
}

void WSManager::processBuyProduct(const std::string& data)
{
	//检查月卡
	char buf[256];
	sprintf(buf, "%04d %d,%d", WSCommand::GET_PRODUCT_LIMIT, 1, 1);
	GetWSManager()->send(buf);

	if (data[0] != '-')
		return;

	if (data == "-1") { // 未满8岁禁止购买
		auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
		view->setViewType(ANTIADDICTTYPE::UNDERAGE8DENIED);
		view->setLocalZOrder(10);
		view->setPositionZ(-10.0f);
	}
	else if (data == "-2") { // 8-15单次
		auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
		view->setViewType(ANTIADDICTTYPE::AGE8CHARGETIP);
		view->setLocalZOrder(10);
		view->setPositionZ(-10.0f);
	}
	else if (data == "-3") { // 8-15超额
		auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
		view->setViewType(ANTIADDICTTYPE::AGE8CHARGELIMIT);
		view->setLocalZOrder(10);
		view->setPositionZ(-10.0f);
	}
	else if (data == "-4") { // 8-15单次
		auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
		view->setViewType(ANTIADDICTTYPE::AGE16CHARGETIP);
		view->setLocalZOrder(10);
		view->setPositionZ(-10.0f);
	}
	else if (data == "-5") { // 16-17超额
		auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
		view->setViewType(ANTIADDICTTYPE::AGE16CHARGELIMIT);
		view->setLocalZOrder(10);
		view->setPositionZ(-10.0f);
	}

}

void WSManager::processNewCharacterCardPoolLottery(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());
	std::vector<int> rarityList;

	int itemId = jsonDoc["cost"]["itemId"].GetInt();
	int amount = jsonDoc["cost"]["amount"].GetInt();

	GetBackpack()->consumeItem(itemId, amount);

	for (size_t i = 0; i < jsonDoc["result"].Size(); i++) {
		int value = jsonDoc["result"][i].GetInt();

		if (value > 1000) {
			auto item = GetItemProvider()->spawnItem(value);
			GetBackpack()->putAndClean(item);
		}
		else {
			auto temp = GetCharacterSystem()->getCharacterTemplate(value);

			CharacterCard* card = GetCharacterSystem()->getById(value);

			if (card != nullptr) {
				card->shards += 10;
			}
			else {
				card = new CharacterCard();

				card->name = temp->name;
				card->id = value;
				card->rarity = (int)temp->rarity;
				card->level = 1;
				card->addExp(0);
				card->approve = 0;
				card->build = temp->build;
				card->buildMax = temp->buildMax;
				card->stamina = temp->stamina;
				card->staminaMax = temp->staminaMax;
				card->trade = temp->trade;
				card->tradeMax = temp->tradeMax;
				card->craft = temp->craft;
				card->craftMax = temp->craftMax;
				card->shards = 0;
				card->skillLevel = 1;
				card->skillName = temp->skillName;
				card->skillDescription = temp->skillDescription;

				char buf[256];
				sprintf(buf, "card_avatar_%d", card->id);
				card->avatarSpr = buf;

				GetSkillSystem()->checkCharacterUpdate(card);

				card->sp = card->spLimit;
				card->hp = card->hpLimit;

				for (auto entry : temp->skillEffectMap)
					card->skillMap[entry.first] = entry.second;

				card->taskPtr = nullptr;
				card->taskId = 0;

				GetCharacterSystem()->addCard(card);
			}

			rarityList.push_back(card->rarity);
		}
	}

	for (auto rarity : rarityList) {
		GetMissionSystem()->getCardRarity(rarity);
	}

	for (size_t i = 0; i < jsonDoc["result"].Size(); i++) {
		GetMissionSystem()->gacha();
	}

	if (jsonDoc["result"].Size() >= 10) {
		GetMissionSystem()->gacha10();
	}
}

void WSManager::processedPettingAnimals(const std::string& data)
{
	if (strcmp(data.c_str(), "OK") == 0) {
		MsgMgr::getInstance()->showMsg(u8"抚摸成功。");
	}
}

void WSManager::processSendCharacterCardGifts(const std::string& data)
{
	//int commaPos = data.find(",");
	//int itemId = atoi(data.substr(0, commaPos).c_str());
	//int cardId = atoi(data.substr(commaPos + 1).c_str());

	//auto item = GetBackpack()->find(itemId - 1);
	//if (item)
	//{
	//	item->amount--;
	//	GetBackpack()->callbackUpdate(item, false);
	//}
	//
	//GetMissionSystem()->present(cardId, itemId, 1);

	MsgMgr::getInstance()->showMsg(u8"送礼成功。");
}

void WSManager::processEnterGameBox(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int mapId = jsonDoc["mapIndex"].GetInt();
	int64_t uid = jsonDoc["uid"].GetInt64();
	int cardId = jsonDoc["cardId"].GetInt();
	float x = jsonDoc["position"]["x"].GetFloat();
	float y = jsonDoc["position"]["y"].GetFloat();
	int mapX = (int)x / 128;
	int mapY = (int)y / 128;
	Vec2 pos(x, y);

	GameMap* map = GetMainGame()->getMapById(mapId);
	Npc* npc = GetMainGame()->getOtherPlayer((int)uid);
	if (npc == nullptr)
	{
		Npc* npc = GetMainGame()->addNewOtherPlayer((int)uid);
		npc->setCardFrames(cardId);
		npc->setPos(pos);
		npc->setMapPos(mapX, mapY);
		npc->setParentMap(map);
		npc->retain();
		npc->setCameraMask(map->getCameraMask());

		map->addChild(npc);
	}
	else
	{
		GetMainGame()->removeOtherPlayer((int)uid);
	}
}

void WSManager::processExitGameBoxCallBack(const std::string& data)
{
	int uid = stoi(data);

	GetMainGame()->removeOtherPlayer(uid);
}

void WSManager::processTransmittingCallBack(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int mapId = jsonDoc["mapIndex"].GetInt();
	int64_t uid = jsonDoc["uid"].GetInt64();
	float x = jsonDoc["position"]["x"].GetFloat();
	float y = jsonDoc["position"]["y"].GetFloat();
	int mapX = (int)x / 128;
	int mapY = (int)y / 128;
	Vec2 pos(x, y);

	GameMap* map = GetMainGame()->getMapById(mapId);
	Npc* npc = GetMainGame()->getOtherPlayer((int)uid);
	if (npc == nullptr) {
		return;
	}
	//TODO舒五家升级没考虑

	if (npc->getParentMap()->getId() == 131 && !GetSocializeSystem()->getIsGurest())
	{
		GetMainGame()->removeOtherPlayer((int)uid);
		return;
	}
	npc->removeFromParent();
	map->addChild(npc);
	npc->setPos(pos);
	npc->setMapPos(mapX, mapY);
	npc->setParentMap(map);
}

void WSManager::processGetGameBoxPlayerList(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapId = jsonDoc[i]["mapIndex"].GetInt();
		int64_t uid = jsonDoc[i]["uid"].GetInt64();
		int cardId = jsonDoc[i]["cardId"].GetInt();
		float x = jsonDoc[i]["position"]["x"].GetFloat();
		float y = jsonDoc[i]["position"]["y"].GetFloat();
		int mapX = (int)x / 128;
		int mapY = (int)y / 128;
		Vec2 pos(x, y);


		GameMap* map = GetMainGame()->getMapById(mapId);
		if (map == nullptr) //地图未加载
		{
			return;
		}
		Npc* npc = GetMainGame()->addNewOtherPlayer((int)uid);
		npc->setCardFrames(cardId);
		npc->setPos(pos);
		npc->setMapPos(mapX, mapY);
		npc->setParentMap(map);
		npc->retain();
		npc->setCameraMask(map->getCameraMask());

		map->addChild(npc);
	}
}

void WSManager::processGameBoxMoveCallBack(const std::string& data)
{
	if (!GetMainGame()->isInMainGame()) return;

	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int mapId = jsonDoc["mapIndex"].GetInt();
	int64_t uid = jsonDoc["uid"].GetInt64();
	int cardId = jsonDoc["cardId"].GetInt();
	float x = jsonDoc["position"]["x"].GetFloat();
	float y = jsonDoc["position"]["y"].GetFloat();
	int mapX = (int)x / 128;
	int mapY = (int)y / 128;
	Vec2 pos(x, y);

	//if (mapId == 132) return;//矿洞第0层不处理移动，因为玩家会刷所有矿洞地图
	GameMap* map = GetMainGame()->getMapById(mapId);
	if (map == nullptr)
	{
		return;
	}

	Npc* npc = GetMainGame()->getOtherPlayer((int)uid);
	if (npc == nullptr)
	{
		Npc* npc = GetMainGame()->addNewOtherPlayer((int)uid);
		npc->setCardFrames(cardId);
		npc->setPos(pos);
		npc->setMapPos(mapX, mapY);
		npc->setParentMap(map);
		npc->retain();
		npc->setCameraMask(map->getCameraMask());

		map->addChild(npc);
	}
	else
	{
		if (npc->getParentMap() != map)
		{
			npc->setParentMap(map);
		}

		npc->moveToDest(pos);
	}

}

void WSManager::processTreeDieCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int mapId = stoi(strSplit[0]);
	int objectId = stoi(strSplit[1]);
	int direction = stoi(strSplit[2]);
	int uid = stoi(strSplit[3]);

	if (GetMainGame()->getMapById(mapId)->getTreeById(objectId) == nullptr)
	{
		CCLOG("processTreeDieCallback error");
		return;
	}
	GetMainGame()->getMapById(mapId)->getTreeById(objectId)->setMarkDie();
	if (uid != GetMainGame()->getUid()) GetMainGame()->getMapById(mapId)->getTreeById(objectId)->setIgnoreMission();
}

void WSManager::processTreeStumpDieCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int mapId = stoi(strSplit[0]);
	int objectId = stoi(strSplit[1]);
	int direction = stoi(strSplit[2]);
	int uid = stoi(strSplit[3]);


	//后端没有生成树桩的过程,前端有, 用来处理前端树桩还没来得及生成的情况
	if (GetMainGame()->getMapById(mapId)->getStumpById(objectId) == nullptr)
	{
		CCLOG("processTreeStumpDieCallback error");
		GetMainGame()->getMapById(mapId)->addWaitDieStump(objectId);
		return;
	}
	GetMainGame()->getMapById(mapId)->getStumpById(objectId)->setMarkDie();
	if (uid != GetMainGame()->getUid()) GetMainGame()->getMapById(mapId)->getStumpById(objectId)->setIgnoreMission();
}

void WSManager::processResourceDieCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int type = stoi(strSplit[0]);
	int mapId = stoi(strSplit[1]);
	int objectId = stoi(strSplit[2]);
	int uid = stoi(strSplit[3]);

	MapObject* target = nullptr;
	GameMap* map = GetMainGame()->getMapById(mapId);

	switch (type) {
	case TILE_GRASS:
		target = map->getGrassById(objectId);
		break;

	case TILE_ROCK:
	case TILE_TRUNK:
		target = map->getMultiblockResourceById(objectId);
		break;
	}

	if (target == nullptr) return;
	target->setMarkDie();
	if (uid != GetMainGame()->getUid()) target->setIgnoreMission();
}

void WSManager::processPourWaterCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int mapId = stoi(strSplit[0]);
	int mx = stoi(strSplit[1]);
	int my = stoi(strSplit[2]);
	int itemId = stoi(strSplit[3]);
	int direction = stoi(strSplit[4]);
	int backpackId = stoi(strSplit[5]);
	int hp = stoi(strSplit[6]);

	auto itemData = GetItemProvider()->getData(itemId);
	int itemWidth = itemData->values[1];
	int itemHeight = itemData->values[2];

	GetMainGame()->getMapById(mapId)->waterTile(mx, my, serverToClientDirection[direction], itemWidth, itemHeight, WaterTileMode::MARK);

	if (!GetVisitSystem()->checkIsVisiting()) {
		GetBackpack()->getByPosition(backpackId - 1)->useLeft = hp;
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);
		GetMissionSystem()->watercan(0, 1);
	}
}

void WSManager::processPlantCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int mapId = stoi(strSplit[0]);
	int mx = stoi(strSplit[1]);
	int my = stoi(strSplit[2]);
	int backpackId = stoi(strSplit[3]);
	int itemId = stoi(strSplit[4]);

	Item* item = GetBackpack()->getByPosition(backpackId - 1);
	GameMap* targetMap = GetMainGame()->getMapById(mapId);
	//新增的肯定没那么快能收割,直接填false; 而且这里也拿不到crop的数据.
	targetMap->addFarmList(mx, my, item->type == ItemType::FLOWERSEED ? ObjectListType::OLT_FLOWER : ObjectListType::OLT_CROP, false);
	GetMainGame()->getMapById(mapId)->plantItem(mx, my, GetVisitSystem()->checkIsVisiting() ? nullptr : item, itemId);
}

void WSManager::processGameboxCardChangeCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int uid = stoi(strSplit[0]);
	int cardId = stoi(strSplit[1]);
	GetMainGame()->getOtherPlayer(uid)->setCardFrames(cardId);
}

void WSManager::processAntiAddictCallback(const std::string& data)
{
	auto view = (AntiAddictionView*)UIViewMgr::getInstance()->showView(uiType::UI_ANTIADDICTION_VIEW);
	view->setViewType(ANTIADDICTTYPE::INVALIDTIMEINGAME);
	view->setOkButtonCallBack([this]() {disconnect(); });
}

void WSManager::processedHaveMonthCard(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	if (jsonDoc.Size() > 0)
	{
		std::vector<int> vtr;
		auto curTime = currentTimeMillis() + 2000;//服务器跟前端稍有差别，这里强制加2秒
		for (size_t i = 0; i < jsonDoc.Size(); i++)
		{
			int id = jsonDoc[i]["id"].GetInt();
			auto nextTime = jsonDoc[i]["nextTime"].GetUint64();
			if (curTime > nextTime)
			{
				vtr.push_back(id);
			}
		}
		GetPlayer()->setMonthCardRewardVtr(vtr);
		if (vtr.size() > 0)
		{
			auto view = UIViewMgr::getInstance()->getView(UINAME::UI_MAIN_VIEW);
			//((MainView*)view)->setVisiableMonthCardDailyBtn(true);
		}
	}
}

void WSManager::processFlowerBirdsTroubleCallback(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);
	GameMap* map = GetMainGame()->getMapById(mapId);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	int id = jsonDoc["id"].GetInt();
	uint64_t growTime = jsonDoc["growTime"].GetUint64();
	uint64_t lastUpdateTime = jsonDoc["lastUpdateTime"].GetUint64();
	int mapX, mapY;

	Flower* flower = map->getFlowerById(id);
	flower->getMapPos(&mapX, &mapY);
	flower->setAccGrowTime(growTime);
	flower->setLastUpdate(lastUpdateTime);
}

void WSManager::processedMonthCardDaily(const std::string& data)
{
	auto view = UIViewMgr::getInstance()->getView(UINAME::UI_MAIN_VIEW);
	((MainView*)view)->setVisiableMonthCardDailyBtn(false);
	std::vector<int>& vtr = GetPlayer()->getMonthCardRewardVtr();
	vtr.clear();
}

void WSManager::processGetProductLimit(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int porductId = jsonDoc["productId"].GetInt();
	int amount = jsonDoc["purchasedAmount"].GetInt();
	std::string ptype = jsonDoc["productType"].GetString();

	if (porductId == 1 && strcmp(ptype.c_str(), "PACKAGE") == 0)//如果是月卡
	{
		if (amount < 1) {
			auto view = UIViewMgr::getInstance()->getView(uiType::UI_RECHARGE_VIEW);
			if (view)
			{
				auto MonthCardView = view->getChildByName("MonthCard");
				if (MonthCardView)
				{
					((RechargeBuyMonthCard*)MonthCardView)->setVisibleBuyBtn(true);
				}
			}
		}
		else
		{
			if (!GetVisitSystem()->checkIsVisiting()) {  //探访时不用
				char buf[256];
				sprintf(buf, "%04d ", WSCommand::GET_PENDING_REWARD_LIST);
				GetWSManager()->send(buf);
			}
		}
	}

	if (porductId != 1 && strcmp(ptype.c_str(), "PACKAGE") == 0)//是礼包但不是月卡
	{
		int amountLimit = 999987;
		auto datas = RechargeModel::getInstance()->getGoodsListData();
		for (size_t i = 0; i < datas.size(); i++)
		{
			if (datas[i]->productId == porductId)
			{
				amountLimit = datas[i]->amountLimit;
			}
		}

		if (amount < amountLimit) {
			auto view = UIViewMgr::getInstance()->getView(uiType::UI_RECHARGE_VIEW);
			if (view)
			{
				auto rechargeBuyPop = view->getChildByName("BigPackage");
				if (rechargeBuyPop)
				{
					((RechargeBuyPop*)rechargeBuyPop)->setVisibleBuyBtn(true);
				}
			}
		}
	}
}

void WSManager::processUseToolCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");

	int uid = stoi(strSplit[0]);
	int toolId = stoi(strSplit[1]);
	int mx = stoi(strSplit[2]);
	int my = stoi(strSplit[3]);
	int directionIndex = stoi(strSplit[4]);
	int mapId = stoi(strSplit[5]);
	int backpackId = stoi(strSplit[6]);
	int cardId = stoi(strSplit[7]);


	Item* backpackData = nullptr;

	if (uid == GetMainGame()->getUid()) {

		backpackData = GetBackpack()->getByPosition(backpackId - 1);
	}

	ItemType itemType = ItemType::MAX;


	if (backpackData == nullptr)
	{
		itemType = (ItemType)(toolId / 1000);
	}
	else
	{
		itemType = backpackData->type;
	}

	auto card = GetCharacterSystem()->getById(cardId);
	if (uid != GetMainGame()->getUid()) {
		ActionAnimation animation = ActionAnimation::MAX;
		auto npc = GetMainGame()->getOtherPlayer(uid);
		if (npc == nullptr)
			return;

		if (itemType == ItemType::WATERCAN) {
			auto map = npc->getParentMap();
			auto block = map->getMapBlock(mx, my);

			if (block->blockType == MAP_RIVER || block->blockType == MAP_SEA)
				animation = ActionAnimation::REFILL;
			else
				animation = ActionAnimation::WATERCAN;

		}
		else {
			if (itemTypeActionMap.count(itemType) > 0)
				animation = itemTypeActionMap[itemType];
		}

		if (animation != ActionAnimation::MAX)
			npc->playAnimation(serverToClientDirection[directionIndex], animation);
	}

	if (uid != GetMainGame()->getUid())
	{
		return;
	}

	switch (itemType) {
	case ItemType::SHOVEL:
	{
		GetMainGame()->getMapById(mapId)->shoveTile(mx, my, serverToClientDirection[directionIndex], backpackData->values[0], backpackData->values[1]);
		MissionSystem::getInstance()->useitem(toolId);
	}
	break;
	case ItemType::DISH:
	case ItemType::FRUIT:
	{
		int spMaxMod = card->spLimit;
		int hpMaxMod = card->hpLimit;

		if (backpackData->values[0] > 0 && card->sp < spMaxMod) {
			int addCardSp = backpackData->values[0];
			GetSkillSystem()->checkCardSp(card, &addCardSp, backpackData->itemId);
			card->sp += addCardSp;
			if (card->sp > spMaxMod) {
				card->sp = spMaxMod;
			}
		}

		if (backpackData->values[1] > 0 && card->hp < hpMaxMod) {
			card->hp += backpackData->values[1];
			if (card->hp > hpMaxMod) {
				card->hp = hpMaxMod;
			}

		}

		backpackData->amount--;
		GetBackpack()->callbackUpdate(backpackData);
	}
	break;
	case ItemType::ROADTILE:
	case ItemType::RECIPE:
	{
		backpackData->amount--;
		GetBackpack()->callbackUpdate(backpackData);
	}
	break;
	case ItemType::CLOTHE:
	{
		backpackData->amount--;
		int beauty = backpackData->values[0];
		int itemId = backpackData->itemId;
		GetBackpack()->callbackUpdate(backpackData);
		GetMainGame()->addBeauty(beauty);
		GetMissionSystem()->useitem(itemId);
	}
	break;
	case ItemType::WALLDECOR:
	{
		backpackData->amount--;
		int beauty = backpackData->values[0];
		GetBackpack()->callbackUpdate(backpackData);
		GetMainGame()->addBeauty(beauty);
	}
	break;
	case ItemType::BUILDING:
	case ItemType::INDOORBUILDING:
	case ItemType::INDOOROUTDOORBUILDING:
	case ItemType::WALL:
	case ItemType::INDOORWALL:
	case ItemType::BOX:
	case ItemType::DECORATION:
	case ItemType::FERTILIZER:
	{
		backpackData->amount--;
		GetBackpack()->callbackUpdate(backpackData);
		GetMainGame()->getMapById(mapId)->fertilizeCrop(mx, my);
		GetMissionSystem()->useitem(toolId);

	}
	break;
	case  ItemType::CARPET:
	{
		backpackData->amount--;
		int beauty = backpackData->values[0];
		GetBackpack()->callbackUpdate(backpackData);
		GetMainGame()->addBeauty(beauty);
		GetMissionSystem()->addbeauty(beauty);
	}
	break;
	case ItemType::CRABCAGE:
	case ItemType::HUNTINGTRAP:
	{
		backpackData->amount--;
		GetBackpack()->callbackUpdate(backpackData);
	}
	break;
	case ItemType::FLOWER:
	{
		int flowerItemId = toolId - ((int)ItemType::FLOWER - (int)ItemType::FLOWERSEED) * 1000;
		CropData* flowerData = GetCropDataProvider()->getData(flowerItemId);
		if (flowerData != nullptr) {
			GetMainGame()->addBeauty(flowerData->beauty);
		}
	}
	case ItemType::TREE:
	case ItemType::FRUITTREE:
	{
		backpackData->amount--;
		GetBackpack()->callbackUpdate(backpackData);
	}
	break;
		case ItemType::HOE:
			GetMissionSystem()->hoe(1);
			break;
	}

	if (itemTypeStaminaMap.count(itemType) > 0)
	{
		GetCharacterSystem()->getById(cardId)->useStamina(itemTypeStaminaMap[itemType]); //工具类扣体力
	}
}

void WSManager::processSubmitTreasures(const std::string& data)
{
	if (data == "ERROR")
	{
		GetMsgMgr()->showMsg(u8"放置失败");
		return;
	}
	auto strSplit = splitStringByDelimiter(data, ",");

	int backpackId = stoi(strSplit[0]);
	Item* itemData = GetBackpack()->getByPosition(backpackId - 1);
	itemData->amount--;
	int beauty = itemData->values[0];
	int itemId = itemData->itemId;
	GetBackpack()->callbackUpdate(itemData);
	GetMainGame()->addBeauty(beauty);
	GetMissionSystem()->museumcommit(itemId);
	GetMissionSystem()->cumulativeMuseumCommit(itemId);

}

void WSManager::processKnockAnimal(const std::string& data)
{
	int commaPos = data.find(",");
	// int commaPos2 = data.find(",", commaPos + 1);
	// int commaPos3 = data.find(",", commaPos2 + 1);

	int animalId = atoi(data.substr(0, commaPos).c_str());
	// int troughId = atoi(data.substr(commaPos+1, commaPos2-commaPos-1).c_str());
	// int animalId = atoi(data.substr(commaPos2+1, commaPos3-commaPos2-1).c_str());


	auto map = GetMainGame()->getCurrentMap();
	if (map->getId() > 100) {
		AnimalHouse* house = (AnimalHouse*)GetMainGame()->getBuildingByMapId(map->getId());
		house->knockAniaml(animalId);
	}
	map->removeAnimal(animalId);
}

void WSManager::processCancelFishCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int uid = stoi(strSplit[0]);
	int finish = stoi(strSplit[1]);

	auto npc = GetMainGame()->getOtherPlayer(uid);

	if (finish)
		npc->playAnimation(-1, ActionAnimation::FISHFINISH);
	else
		npc->cancelAnimation();
}

void WSManager::processHarvestBroadcastCallback(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");
	int uid = stoi(strSplit[0]);
	int mx = stoi(strSplit[1]);
	int my = stoi(strSplit[2]);

	auto npc = GetMainGame()->getOtherPlayer(uid);

	if (npc == nullptr) return;

	Vec2 targetPt(mx * 128.0f - 64.0f, my * 128.0f - 64.0f);

	int direction = getDirectionFromVecDiff(targetPt, npc->getPos());

	npc->playAnimation(direction, ActionAnimation::HARVEST);
}

void WSManager::processMakeAcceleration(const std::string& data)
{
	if (data == "ERROR") {
		GetMsgMgr()->showMsg(u8"加速失败，宝玉不足？");
		return;
	}

	if (data == "OK") {
		GetMsgMgr()->showMsg(u8"参数错误");
		return;
	}

	auto strSplit = splitStringByDelimiter(data, ",");
	int taskId = stoi(strSplit[0]);
	int diamondNeeded = stoi(strSplit[1]);

	GetCraftManager()->finishByRealMoneyCallback(taskId, diamondNeeded);
}
void WSManager::processGetTableList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int mapId = jsonDoc["mapIndex"].GetInt();
	int buildingId = jsonDoc["id"].GetInt();;
	GameMap* map = GetMainGame()->getMapById(mapId);
	PlaceableTable* table = (PlaceableTable*)map->getBuildingById(buildingId);
	table->clearData();
	for (size_t i = 0; i < jsonDoc["tableMapData"].Size(); i++)
	{
		TableBlock block;
		block.itemid = jsonDoc["tableMapData"][i]["itemId"].GetInt();
		block.gridposx = jsonDoc["tableMapData"][i]["mapPosition"]["x"].GetInt() + 1;//服务器起点为0
		block.gridposy = jsonDoc["tableMapData"][i]["mapPosition"]["y"].GetInt() + 1;
		table->addTableGridList(block);
	}
	for (size_t i = 0; i < jsonDoc["tableItems"].Size(); i++)
	{
		TableItem tableitem;
		tableitem.itemid = jsonDoc["tableItems"][i]["itemId"].GetInt();
		tableitem.gridposx = jsonDoc["tableItems"][i]["firstPosition"]["x"].GetInt() + 1;//服务器起点为0
		tableitem.gridposy = jsonDoc["tableItems"][i]["firstPosition"]["y"].GetInt() + 1;
		tableitem.tableid = jsonDoc["tableItems"][i]["jewelryBoxId"].GetInt();
		tableitem.boxSwitch = jsonDoc["tableItems"][i]["boxSwitch"].GetInt();
		table->addTableItemList(tableitem);
	}
	table->tableUpdate(buildingId);
}

void WSManager::processGetBedList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		int mapId = jsonDoc[i]["mapIndex"].GetInt();
		int buildingId = jsonDoc[i]["id"].GetInt();
		GameMap* map = GetMainGame()->getMapById(mapId);
		Bed* bed = (Bed*)map->getBuildingById(buildingId);
		bed->clearData();
		for (size_t j = 0; j < jsonDoc[i]["cardBerthsList"].Size(); j++)
		{
			bed->addSleepCard(jsonDoc[i]["cardBerthsList"][j].GetInt());
		}
	}

}

void WSManager::processSleep(const std::string& data)
{
	if (data == "OK")
	{
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_CARD_SLEEP_VIEW);
		this->isSleep();
	}
}

void WSManager::processWeatherTime(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int season = jsonDoc["currentSeason"].GetInt();
	bool seasonChange = jsonDoc["seasonalChange"].GetBool();
	uint64_t time = jsonDoc["weather"]["time"].GetUint64();
	int weather = jsonDoc["weather"]["weather"].GetInt();
	uint64_t litreThirteenLevelTime = jsonDoc["litreThirteenLevelTime"].GetUint64();
	auto randomWeatherList = jsonDoc["randomWeather"].GetArray();

	std::vector<int>& w_randomWeatherList = WeatherController::getInstance()->getRandomWeatherList();
	for (size_t i = 0; i < randomWeatherList.Size(); i++) {
		w_randomWeatherList.push_back(randomWeatherList[i].GetInt());
	}
	WeatherController::getInstance()->setLitreThirteenLevelTime(litreThirteenLevelTime);

	WeatherController::getInstance()->WeatherTimeMsg(time, weather, (WeatherController::SeasonType)season);

	WeatherController::getInstance()->setIsShowTips(seasonChange);
}

void WSManager::processGetCardList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());
	std::vector<int> cardListId;
	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		cardListId.push_back(jsonDoc[i].GetInt());
	}
	StageController().getInstance()->setStageCardList(cardListId);
}

//返回戏台数据
void WSManager::processGetStageAllData(const std::string& data)
{
	Document jsonDoc;
	std::vector<StageController::Stage*> stageList;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		StageController::Stage* stage = new StageController::Stage();
		stage->buildingId = jsonDoc[i]["id"].GetInt();
		stage->lastSingTime = jsonDoc[i]["lastSingTime"].GetUint64();
		stage->mapIndex = jsonDoc[i]["mapIndex"].GetInt();
		stage->trackId = jsonDoc[i]["trackId"].GetInt();
		stage->cardId = jsonDoc[i]["cardId"].GetInt();

		std::vector<int> cardListId;  //卡牌id
		for (size_t j = 0; j < jsonDoc[i]["cardList"].Size(); j++)
		{
			cardListId.push_back(jsonDoc[i]["cardList"][j].GetInt());
		}

		std::vector<int> trackList;  //歌曲id

		for (size_t k = 0; k < jsonDoc[i]["trackList"].Size(); k++)
		{
			trackList.push_back(jsonDoc[i]["trackList"][k].GetInt());
		}

		stage->cardListId = cardListId;
		stage->trackList = trackList;
		stageList.push_back(stage);
	}
	StageController().getInstance()->setStageData(stageList);
}

void WSManager::processMissionCallback(const std::string& data)
{
	if (data == "ERROR") {
		return;
	}
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {

		int id = jsonDoc[i]["id"].GetInt();
		int targetId = jsonDoc[i]["talkTargetId"].GetInt();
		int scriptId = jsonDoc[i]["talkProgress"].GetInt();
		std::vector<int> requireList;
		std::vector<int> completeList;

		auto itr = jsonDoc[i]["require"].MemberBegin();
		while (itr != jsonDoc[i]["require"].MemberEnd()) {
			int value = itr->value.GetInt();
			requireList.push_back(value);
			itr++;
		}

		auto itr2 = jsonDoc[i]["complete"].MemberBegin();
		while (itr2 != jsonDoc[i]["complete"].MemberEnd()) {
			int value = itr2->value.GetInt();
			completeList.push_back(value);
			itr2++;
		}

		//GetMissionSystem()->forceMissionStart(id);

		for (size_t i = 0; i < requireList.size(); i++) {
			if (completeList[i] >= requireList[i]) {
				GetMissionSystem()->forceCompleteObjective(id, i, completeList[i]);
			}
			else {
				GetMissionSystem()->forceSetObjectiveProgress(id, i, completeList[i]);
			}
		}

		if (targetId != 0 && scriptId != 0) {
			GetMissionSystem()->forceSetTargetAndScript(id, targetId, scriptId);
		}
	}

}

void WSManager::processSaveItemInBox(const std::string& data)
{
	auto strSplit = splitStringByDelimiter(data, ",");

	int backpackId = stoi(strSplit[0]);
	auto backpackData = GetBackpack()->getByPosition(backpackId - 1);
	if (backpackData != nullptr)
	{
		GetBackpack()->callbackUpdate(backpackData);
		EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_STORAGE_BOX_VIEW);
	}
}

void WSManager::processEditMapBlock(const std::string& data)
{

	if (data == "ERROR")
	{
		return;
	}

	auto strSplit = splitStringByDelimiter(data, ",");

	int userId = stoi(strSplit[0]);
	int mapId = stoi(strSplit[1]);
	int mapX = stoi(strSplit[2]);
	int mapY = stoi(strSplit[3]);
	BlockType mapType = (BlockType)stoi(strSplit[4]);

	auto map = GetMainGame()->getMapById(mapId);
	map->editMapCallback(mapX, mapY, mapType, true);

	GetMissionSystem()->editMapBlock();

}

void WSManager::processTeamDataCallback(const std::string& data)
{
	int commaPos = data.find(",");
	std::string type = data.substr(0, commaPos);
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	bool lock = jsonDoc["lock"].GetBool();
	int64_t id = jsonDoc["id"].GetInt64();
	int64_t leader = jsonDoc["leader"].GetInt64();
	std::string name = jsonDoc["name"].GetString();
	GetSocializeSystem()->setTeamData(id, lock, leader);
	GetSocializeSystem()->setTeamName(name);
	std::vector<int64_t> invitalist;

	for (size_t i = 0; i < jsonDoc["invitationList"].Size(); i++)
	{
		auto temp = jsonDoc["invitationList"][i].GetUint64();
		invitalist.push_back(temp);
	}

	GetSocializeSystem()->setInvitationList(invitalist);

	std::vector<int>& MemberUidVtr = SocializeSystem::getInstance()->getMemberUidVtr();
	MemberUidVtr.clear();
	for (size_t i = 0; i < jsonDoc["memberList"].Size(); i++)
	{
		auto temp = jsonDoc["memberList"][i].GetInt();
		MemberUidVtr.push_back(temp);
	}
	if (MemberUidVtr.size() >= 2)
	{
		GetMissionSystem()->joinOtherTeam(MemberUidVtr.size());
	}

	std::vector<int>& MemberPosUidVtr = SocializeSystem::getInstance()->getMemberPosUidVtr();
	MemberPosUidVtr.clear();
	for (size_t i = 0; i < jsonDoc["memberIndex"].Size(); i++)
	{
		auto temp = jsonDoc["memberIndex"][i].GetInt();
		MemberPosUidVtr.push_back(temp);
	}
	GetSocializeSystem()->teamDataCallback(type);

	SocializeSystem::getInstance()->mPartyTimeVtr.clear();
	if (strcmp(type.c_str(), "PARTY") == 0)
	{
		if (!jsonDoc["partyList"].IsNull())
		{
			time_t nowTime = time(NULL);
			auto partyObjs = jsonDoc["partyList"].GetArray();
			for (int i = 0; i < partyObjs.Size(); i++)
			{
				auto partyObj = partyObjs[i].GetObject();
				string str = partyObj["status"].GetString();

				int64_t satrtTime = partyObj["startTime"].GetInt64();
				int duration = partyObj["config"]["duration"].GetInt();
				int partyId = partyObj["id"].GetInt();

				PartyRunningInfo info;
				info.partyId = partyId;
				info.startTime = satrtTime / 1000;
				info.endTime = (satrtTime + duration) / 1000;
				info.partyLv = partyObj["config"]["grade"].GetInt();
				info.state = 1;
				if (strcmp(str.c_str(), "INVITATION") == 0)
				{
					info.state = 0;
				}
				if (strcmp(str.c_str(), "PARTYING") == 0)
				{
					info.state = 2;
				}

				for (size_t i = 0; i < partyObj["refuseMembers"].Size(); i++)
				{
					auto temp = partyObj["refuseMembers"][i].GetInt();
					info.refuseMembers.push_back(temp);
				}
				SocializeSystem::getInstance()->mPartyTimeVtr.push_back(info);

				if (strcmp(str.c_str(), "INVITATION") == 0)
				{
					if (nowTime >= info.startTime)
					{
						SocializeSystem::getInstance()->mPartyTimeVtr.pop_back();
						if (nowTime >= info.endTime)
						{
							endParty(info.partyId);

						}
						//超时了
						continue;
					}

					int ownerId = partyObj["hostId"].GetInt();
					if (ownerId != MainGame::getInstance()->getUid())
					{
						bool bo = true;
						for (size_t i = 0; i < partyObj["refuseMembers"].Size(); i++)
						{
							auto temp = partyObj["refuseMembers"][i].GetInt();
							if (temp == MainGame::getInstance()->getUid())
							{
								bo = false;
								break;
							}
						}

						if (bo && !UIViewMgr::getInstance()->isViewShow(uiType::UI_TEAM_NOTICE_VIEW))
						{
							auto view = (TeamNoticeView*)UIViewMgr::getInstance()->showView(uiType::UI_TEAM_NOTICE_VIEW);
							string str1(""); string str2("");
							int hour = SocializeSystem::DateToChina(info.startTime, str1, str2);
							char buf[255];
							sprintf(buf, u8"(%d点)", hour);
							view->partyInviteDataUI(str1.append(",").append(str2).append(string(buf)).c_str());
							view->setOkButtonCallBack([=]() {
								WSManager::getInstance()->agreePartyInvitation(1, partyId);
								UIViewMgr::getInstance()->hideView(uiType::UI_TEAM_NOTICE_VIEW);
								});
							view->setNoButtonCallBack([=]() {
								WSManager::getInstance()->agreePartyInvitation(0, partyId);
								UIViewMgr::getInstance()->hideView(uiType::UI_TEAM_NOTICE_VIEW);
								});
						}

					}
				}
				else// waiting or playing
				{
					if (nowTime >= info.endTime)
					{
						SocializeSystem::getInstance()->mPartyTimeVtr.pop_back();
						//超时了
						endParty(info.partyId);
						continue;
					}
				}
			}

			if (SocializeSystem::getInstance()->mPartyTimeVtr.size() > 0)
			{
				struct { bool operator()(PartyRunningInfo& a, PartyRunningInfo& b) const { if (a.state == 0) { return false; } else { return a.startTime < b.startTime; } } } mysort;
				std::sort(SocializeSystem::getInstance()->mPartyTimeVtr.begin(), SocializeSystem::getInstance()->mPartyTimeVtr.end(), mysort);

				//SocializeSystem::getInstance()->mPartyTimeVtr[0].startTime = 1682268420;
				//SocializeSystem::getInstance()->mPartyTimeVtr[0].endTime = 1682268420 + 600000;

				if (SocializeSystem::getInstance()->mPartyTimeVtr[0].state != 0)
					SocializeSystem::getInstance()->setPartyTime(SocializeSystem::getInstance()->mPartyTimeVtr[0].startTime, SocializeSystem::getInstance()->mPartyTimeVtr[0].endTime);
			}

			SocializeSystem::getInstance()->onPartyMapFresh();
		}
		else
		{
			// 关掉宴会
		}
	}

}

void WSManager::processGetTeamData(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	bool lock = jsonDoc["lock"].GetBool();
	int64_t id = jsonDoc["id"].GetInt64();
	int64_t leader = jsonDoc["leader"].GetInt64();
	std::string name = jsonDoc["name"].GetString();
	GetSocializeSystem()->setTeamData(id, lock, leader);
	GetSocializeSystem()->setTeamName(name);
	GetWSManager()->getVoteList();
	std::vector<int64_t> invitalist;

	for (size_t i = 0; i < jsonDoc["invitationList"].Size(); i++)
	{
		auto temp = jsonDoc["invitationList"][i].GetUint64();
		invitalist.push_back(temp);
	}
	GetSocializeSystem()->setInvitationList(invitalist);

	std::vector<int>& MemberUidVtr = SocializeSystem::getInstance()->getMemberUidVtr();
	MemberUidVtr.clear();
	for (size_t i = 0; i < jsonDoc["memberList"].Size(); i++)
	{
		auto temp = jsonDoc["memberList"][i].GetInt();
		MemberUidVtr.push_back(temp);
	}

	if (MemberUidVtr.size() >= 2)
	{
		GetMissionSystem()->joinOtherTeam(MemberUidVtr.size());
	}
	std::vector<int>& MemberPosUidVtr = SocializeSystem::getInstance()->getMemberPosUidVtr();
	MemberPosUidVtr.clear();
	for (size_t i = 0; i < jsonDoc["memberIndex"].Size(); i++)
	{
		auto temp = jsonDoc["memberIndex"][i].GetInt();
		MemberPosUidVtr.push_back(temp);
	}

	SocializeSystem::getInstance()->mPartyTimeVtr.clear();
	//if (!jsonDoc["partyList"].IsNull())
	//{
	//	time_t nowTime = time(NULL);
	//	auto partyObjs = jsonDoc["partyList"].GetArray();
	//	for (int i = 0; i < partyObjs.Size(); i++)
	//	{
	//		auto partyObj = partyObjs[i].GetObject();
	//		string str = partyObj["status"].GetString();

	//		int64_t satrtTime = partyObj["startTime"].GetInt64();
	//		int duration = partyObj["config"]["duration"].GetInt();
	//		int partyId = partyObj["id"].GetInt();

	//		PartyRunningInfo info;
	//		info.partyId = partyId;
	//		info.startTime = satrtTime / 1000;
	//		info.endTime = (satrtTime + duration) / 1000;
	//		info.partyLv = partyObj["config"]["grade"].GetInt();
	//		info.state = 1;
	//		if (strcmp(str.c_str(), "INVITATION") == 0)
	//		{
	//			info.state = 0;
	//		}
	//		if (strcmp(str.c_str(), "PARTYING") == 0)
	//		{
	//			info.state = 2;
	//		}

	//		for (size_t i = 0; i < partyObj["refuseMembers"].Size(); i++)
	//		{
	//			auto temp = partyObj["refuseMembers"][i].GetInt();
	//			info.refuseMembers.push_back(temp);
	//		}
	//		SocializeSystem::getInstance()->mPartyTimeVtr.push_back(info);

	//		if (strcmp(str.c_str(), "INVITATION") == 0)
	//		{
	//			if (nowTime >= info.startTime)
	//			{
	//				SocializeSystem::getInstance()->mPartyTimeVtr.pop_back();
	//				if (nowTime >= info.endTime)
	//				{
	//					endParty(info.partyId);
	//				}
	//				//超时了
	//				continue;
	//			}

	//			int ownerId = partyObj["hostId"].GetInt();
	//			if (ownerId != MainGame::getInstance()->getUid())
	//			{
	//				bool bo = true;
	//				for (size_t i = 0; i < partyObj["refuseMembers"].Size(); i++)
	//				{
	//					auto temp = partyObj["refuseMembers"][i].GetInt();
	//					if (temp == MainGame::getInstance()->getUid())
	//					{
	//						bo = false;
	//						break;
	//					}
	//				}

	//				if (bo && !UIViewMgr::getInstance()->isViewShow(uiType::UI_TEAM_NOTICE_VIEW))
	//				{
	//					auto view = (TeamNoticeView*)UIViewMgr::getInstance()->showView(uiType::UI_TEAM_NOTICE_VIEW);
	//					string str1(""); string str2("");
	//					int hour = SocializeSystem::DateToChina(info.startTime, str1, str2);
	//					char buf[255];
	//					sprintf(buf, u8"(%d点)", hour);
	//					view->partyInviteDataUI(str1.append(",").append(str2).append(string(buf)).c_str());
	//					view->setOkButtonCallBack([=]() {
	//						WSManager::getInstance()->agreePartyInvitation(1, partyId);
	//						UIViewMgr::getInstance()->hideView(uiType::UI_TEAM_NOTICE_VIEW);
	//						});
	//					view->setNoButtonCallBack([=]() {
	//						WSManager::getInstance()->agreePartyInvitation(0, partyId);
	//						UIViewMgr::getInstance()->hideView(uiType::UI_TEAM_NOTICE_VIEW);
	//						});
	//				}

	//			}
	//		}
	//		else // waiting or playing
	//		{
	//			if (nowTime >= info.endTime)
	//			{
	//				endParty(info.partyId);
	//			}
	//		}
	//	}

	//	if (SocializeSystem::getInstance()->mPartyTimeVtr.size() > 0)
	//	{
	//		struct { bool operator()(PartyRunningInfo& a, PartyRunningInfo& b) const { if (a.state == 0) { return false; } else { return a.startTime < b.startTime; } } } mysort;
	//		std::sort(SocializeSystem::getInstance()->mPartyTimeVtr.begin(), SocializeSystem::getInstance()->mPartyTimeVtr.end(), mysort);

	//		//SocializeSystem::getInstance()->mPartyTimeVtr[0].startTime = 1682268420;
	//		//SocializeSystem::getInstance()->mPartyTimeVtr[0].endTime = 1682268420 + 600000;
	//		if (SocializeSystem::getInstance()->mPartyTimeVtr[0].state != 0)
	//			SocializeSystem::getInstance()->setPartyTime(SocializeSystem::getInstance()->mPartyTimeVtr[0].startTime, SocializeSystem::getInstance()->mPartyTimeVtr[0].endTime);
	//	}
	//}

	SocializeSystem::getInstance()->onPartyMapFresh();
}

void WSManager::processPlayerGatheringPlacePosCallback(const std::string& data)
{
	if (!GetMainGame()->isInMainGame())
		return;

	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int mapId = jsonDoc["mapIndex"].GetInt();
	float x = jsonDoc["position"]["x"].GetFloat();
	float y = jsonDoc["position"]["y"].GetFloat();

	auto map = GetMainGame()->getMapById(7);
	auto buildintList = map->getBuildingList();
	for (auto& entry2 : buildintList) {
		auto building = (Building*)entry2.second;

		if (building->getBuildingId() == 22065) {
			GatheringPlace* prt = (GatheringPlace*)building;
			prt->closeSwitch();
			break;
		}
	}

	GetPlayer()->validateServerPos(mapId, (float)x, (float)y);
}

void WSManager::processOtherMemberPos(const std::string& data)
{
	if (!GetMainGame()->isInMainGame()) return;

	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapId = jsonDoc[i]["mapIndex"].GetInt();
		int64_t uid = jsonDoc[i]["uid"].GetInt64();
		if (uid == GetMainGame()->getUid())
		{
			continue;
		}
		int cardId = jsonDoc[i]["cardId"].GetInt();
		float x = jsonDoc[i]["position"]["x"].GetFloat();
		float y = jsonDoc[i]["position"]["y"].GetFloat();
		int mapX = (int)x / 128;
		int mapY = (int)y / 128;
		Vec2 pos(x, y);

		GameMap* map = GetMainGame()->getMapById(mapId);
		Npc* npc = GetMainGame()->getOtherPlayer((int)uid);
		if (npc == nullptr)
		{
			Npc* npc = GetMainGame()->addNewOtherPlayer((int)uid);
			npc->setCardFrames(cardId);
			npc->setPos(pos);
			npc->setMapPos(mapX, mapY);
			npc->setParentMap(map);
			npc->retain();
			npc->setCameraMask(map->getCameraMask());
			map->addOtherMember((int)uid + NPC_OTHER_PLAYER_START, npc);
			map->addChild(npc);
			if (mapId == 131 && SocializeSystem::getInstance()->getIsPartyRunning() && SocializeSystem::getInstance()->willJoinParty(uid))
			{
				npc->setPartyIconsetVisible(true);
			}
		}
		else
		{
			npc->setPos(pos);
			npc->setMapPos(mapX, mapY);
		}

	}
}

void WSManager::processOtherMemberPosCallback(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int64_t uid = jsonDoc["uid"].GetInt64();
	float x = jsonDoc["position"]["x"].GetFloat();
	float y = jsonDoc["position"]["y"].GetFloat();
	int cardId = jsonDoc["cardId"].GetInt();
	int mapId = jsonDoc["mapIndex"].GetInt();
	int mapX = (int)x / 128;
	int mapY = (int)y / 128;
	GameMap* map = GetMainGame()->getMapById(mapId);
	Vec2 pos(x, y);
	Npc* npc = GetMainGame()->getOtherPlayer((int)uid);
	if (npc == nullptr)
	{
		Npc* npc = GetMainGame()->addNewOtherPlayer((int)uid);
		npc->setCardFrames(cardId);
		npc->setPos(pos);
		npc->setMapPos(mapX, mapY);
		npc->setParentMap(map);
		npc->retain();
		npc->setCameraMask(map->getCameraMask());
		map->addOtherMember((int)uid + NPC_OTHER_PLAYER_START, npc);
		map->addChild(npc);
		if (mapId == 131 && SocializeSystem::getInstance()->getIsPartyRunning() && SocializeSystem::getInstance()->willJoinParty(uid))
		{
			npc->setPartyIconsetVisible(true);
		}
	}
	else
	{
		if (npc->getParentMap() != map)
		{
			npc->setParentMap(map);
		}

		if (npc->getCardFrames() != cardId)
		{
			npc->setCardFrames(cardId);
		}

		npc->moveToDest(pos);

	}

}

void WSManager::processGetVoteResultList(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		VoteData* data = new VoteData();
		int64_t target = jsonDoc[i]["target"].GetInt64();
		data->target = target;
		data->targetname = jsonDoc[i]["targetName"].GetString();
		data->type = jsonDoc[i]["type"].GetString();
		data->time = jsonDoc[i]["time"].GetUint64();
		data->initiatorName = jsonDoc[i]["initiatorName"].GetString();
		auto itr = jsonDoc[i]["voteMap"].MemberBegin();
		while (itr != jsonDoc[i]["voteMap"].MemberEnd()) {
			int64_t voter = atoi(itr->name.GetString());
			VoteResult* res = new VoteResult();
			res->voter = voter;
			res->agree = jsonDoc[i]["voteMap"][itr->name]["agree"].GetBool();
			res->result = jsonDoc[i]["voteMap"][itr->name]["result"].GetBool();
			data->result[voter] = res;
			itr++;
		}
		GetSocializeSystem()->addVoteMap(target, data);
	}
	GetSocializeSystem()->voteCallback();
	GetSocializeSystem()->openSwitch();
}


void WSManager::processGetMemberPermission(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	std::vector<std::string> str;
	for (size_t i = 0; i < jsonDoc["accessPermissions"].Size(); i++)
	{
		str.push_back(jsonDoc["accessPermissions"][i].GetString());
	}
	GetSocializeSystem()->setMemberPermission(str);
}

void WSManager::processGetInvitionList(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		ReceivedInvitation* data = new ReceivedInvitation();
		data->teamid = jsonDoc[i]["teamId"].GetInt64();
		data->inviterId = jsonDoc[i]["inviterId"].GetInt64();
		data->friendname = jsonDoc[i]["inviterName"].GetString();
		data->teamname = jsonDoc[i]["teamName"].GetString();
		data->time = jsonDoc[i]["time"].GetUint64();
		GetSocializeSystem()->addInvita(data);

	}
	GetSocializeSystem()->inviteCallback();
}

void WSManager::processGetTeamMemberData(const std::string& data)
{
	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());
	GetSocializeSystem()->clearMemberData();
	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		TeamMemberData* data = new TeamMemberData();
		data->id = jsonDoc[i]["userId"].GetUint64();
		data->name = jsonDoc[i]["username"].GetString();
		data->friendvalue = jsonDoc[i]["intimacy"].GetInt();
		data->avatar = jsonDoc[i]["avatar"].GetInt();
		data->lock = jsonDoc[i]["shuwujiaLock"].GetBool();
		data->signature = jsonDoc[i]["signature"].GetString();
		data->playerLevel = jsonDoc[i]["level"].GetInt();
		GetSocializeSystem()->addMember(data);
	}
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TEAM_DATA);
	GetSocializeSystem()->refreshMapByMember();
}

void WSManager::processTakeHuntingTrapCallback(const std::string& data)
{
	if (data == "ERROR") {
		return;
	}

	HuntingTrap* trap = huntingTrapDeleteQueue.front();
	huntingTrapDeleteQueue.pop();

	GameMap* map = (GameMap*)trap->getParent();
	int mapX, mapY;
	trap->getMapPos(&mapX, &mapY);
	auto reslist = trap->getResultList();
	for (auto res : reslist)
	{
		if (currentTimeMillis() >= res->time)
		{
			GetMissionSystem()->RetrieveTrap(res->animalid, 1);
			break;
		}
	}

	trap->clearResult();
	map->retrieveHuntingTrap(mapX, mapY);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_BACK_PACK);
	GetMainGame()->checkBackpack();
}

void WSManager::processPutHuntingTrapCallback(const std::string& data)
{
	int commaPos = data.find(",");
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	int taskId = jsonDoc["id"].GetInt();
	int mapIndex = jsonDoc["mapIndex"].GetInt();

	GameMap* map = GetMainGame()->getMapById(mapIndex);
	HuntingTrap* trap = huntingTrapQueue.front();
	huntingTrapQueue.pop();

	int mapX, mapY;
	trap->getMapPos(&mapX, &mapY);
	trap->setId(taskId);
	map->addHuntingTrap(taskId, trap);

	std::vector<wildanimal*> wildanimallist;
	for (size_t j = 0; j < jsonDoc["result"].Size(); j++)
	{
		wildanimal* animal = new wildanimal();
		animal->animalid = jsonDoc["result"][j]["animalId"].GetInt();
		animal->time = jsonDoc["result"][j]["time"].GetUint64();
		wildanimallist.push_back(animal);
	}
	if (!jsonDoc["fillerAmount"].IsNull()) {
		int fillerItemId = jsonDoc["fillerAmount"]["itemId"].GetInt();
		int fillerAmount = jsonDoc["fillerAmount"]["amount"].GetInt();
		Item* filler = GetItemProvider()->spawnItemWithAmount(fillerItemId, fillerAmount);
		trap->setBait(filler);
	}
	trap->settrapRestult(wildanimallist);
	if (!trap->isResultEmpty())
	{
		trap->showSpr(true);
	}
	MAPBLOCK* block = map->getMapBlock(mapX, mapY);
	block->tileType = TILE_HUNTING_TRAP;
	block->index = taskId;
}

void WSManager::processRedeemAnimalMeatCallback(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int itemid = jsonDoc[i]["itemId"].GetInt();
		int amount = jsonDoc[i]["amount"].GetInt();

		Item* item = GetItemProvider()->spawnItemWithAmount(itemid, amount);
		GetBackpack()->putAndClean(item);

		//char buf[256];
		//sprintf(buf, u8"获得了%s×%d！", item->name.c_str(), amount);
		GetMsgMgr()->showMsg(u8"兑换成功。");
	}
}

void WSManager::processGetHuntingTrapTaskList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int mapX = jsonDoc[i]["mapPosition"]["x"].GetInt();
		int mapY = jsonDoc[i]["mapPosition"]["y"].GetInt();
		int id = jsonDoc[i]["id"].GetInt();
		int mapId = jsonDoc[i]["mapIndex"].GetInt();

		GameMap* map = GetMainGame()->getMapById(mapId);

		HuntingTrap* trap = map->getHuntingTrap(id);
		if (trap == nullptr)
		{
			std::vector<wildanimal*> wildanimallist;
			for (size_t j = 0; j < jsonDoc[i]["result"].Size(); j++)
			{
				wildanimal* animal = new wildanimal();
				animal->animalid = jsonDoc[i]["result"][j]["animalId"].GetInt();
				animal->time = jsonDoc[i]["result"][j]["time"].GetUint64();

				wildanimallist.push_back(animal);
			}
			int itemId = jsonDoc[i]["tool"]["itemId"].GetInt();
			HuntingTrap* trap = map->plantHuntingTrap(mapX, mapY, itemId);
			trap->setId(id);
			trap->settrapRestult(wildanimallist);
			if (!jsonDoc[i]["fillerAmount"].IsNull()) {
				int fillerItemId = jsonDoc[i]["fillerAmount"]["itemId"].GetInt();
				int fillerAmount = jsonDoc[i]["fillerAmount"]["amount"].GetInt();
				Item* filler = GetItemProvider()->spawnItemWithAmount(fillerItemId, fillerAmount);
				trap->setBait(filler);
			}
			map->addHuntingTrap(id, trap);
		}
	}
}

void WSManager::processGetMapScopeList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		int mapid = jsonDoc[i]["mapIndex"].GetInt();
		auto map = GetMainGame()->getMapById(mapid);

		MapScope* scope = new MapScope();
		int scopeid = jsonDoc[i]["id"].GetInt();
		scope->startx = jsonDoc[i]["start"]["x"].GetInt();
		scope->starty = jsonDoc[i]["start"]["y"].GetInt();
		scope->endx = jsonDoc[i]["end"]["x"].GetInt();
		scope->endy = jsonDoc[i]["end"]["y"].GetInt();
		std::vector<int> animallist;
		for (size_t j = 0; j < jsonDoc[i]["animalLimitList"].Size(); j++)
		{
			int animalid = jsonDoc[i]["animalLimitList"][j].GetInt();
			animallist.push_back(animalid);
		}
		scope->wildanimallist = animallist;
		map->addMapScope(scopeid, scope);
	}
}

void WSManager::processVisitShuwujiaMember(const std::string& data)
{
	if (data == "OK") {
		//SocializeSystem::getInstance()->initGuest();
		GetMainGame()->reloadMap();
		GetMissionSystem()->mirrorShuwujia();
		getShuwujiaPermissions();
	}
	else {
		SocializeSystem::getInstance()->onLeaveGuest();
	}
}

void WSManager::processGetShuwujiaPermissions(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	bool mP_1 = false;
	bool mP_2 = false;
	bool mP_3 = false;
	bool mP_4 = false;

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		const char* str = jsonDoc[i].GetString();

		if (strcmp(str, "LEVEL_1") == 0)
		{
			mP_1 = true;
		}
		else if (strcmp(str, "LEVEL_2") == 0)
		{
			mP_2 = true;
		}
		else if (strcmp(str, "LEVEL_3") == 0)
		{
			mP_3 = true;
		}
		else if (strcmp(str, "LEVEL_4") == 0)
		{
			mP_4 = true;
		}
	}

	auto socializeSystem = SocializeSystem::getInstance();
	socializeSystem->setFirstPermission(mP_1);
	socializeSystem->setSecondPermission(mP_2);
	socializeSystem->setThirthPermission(mP_3);
	socializeSystem->setFourthPermission(mP_4);
}

void WSManager::processUpdateShuwujiaPermissions(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	bool mP_1 = false;
	bool mP_2 = false;
	bool mP_3 = false;
	bool mP_4 = false;

	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		const char* str = jsonDoc[i].GetString();

		if (strcmp(str, "LEVEL_1") == 0)
		{
			mP_1 = true;
		}
		else if (strcmp(str, "LEVEL_2") == 0)
		{
			mP_2 = true;
		}
		else if (strcmp(str, "LEVEL_3") == 0)
		{
			mP_3 = true;
		}
		else if (strcmp(str, "LEVEL_4") == 0)
		{
			mP_4 = true;
		}
	}

	auto socializeSystem = SocializeSystem::getInstance();
	socializeSystem->setFirstPermission(mP_1);
	socializeSystem->setSecondPermission(mP_2);
	socializeSystem->setThirthPermission(mP_3);
	socializeSystem->setFourthPermission(mP_4);
}

void WSManager::processGetRecycleList(const std::string& data, bool recycleAll)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());


	GetSocializeSystem()->clearRecycleItemList();
	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		RecycleItem* data = new RecycleItem();

		ItemType itemType = (ItemType)jsonDoc[i]["item"]["type"].GetInt();
		int itemId = jsonDoc[i]["item"]["itemId"].GetInt();
		int amount = jsonDoc[i]["item"]["amount"].GetInt();
		int pos = jsonDoc[i]["item"]["id"].GetInt() - 1;
		int quality = jsonDoc[i]["item"]["quality"].GetInt();
		int portalId = jsonDoc[i]["item"]["portalId"].IsNull() ? -1 : jsonDoc[i]["item"]["portalId"].GetInt();
		int objectId = jsonDoc[i]["item"]["objectId"].IsNull() ? -1 : jsonDoc[i]["item"]["objectId"].GetInt();
		bool enable = jsonDoc[i]["item"]["enable"].GetBool();

		Item* item = GetItemProvider()->spawnItemWithAmount(itemId, amount);
		item->uniqueId = pos;
		item->setQuality(quality);
		item->portalId = portalId;
		item->objectId = objectId;
		item->locked = !enable;

		int64_t sourceId = jsonDoc[i]["sourceId"].GetInt64();
		int id = jsonDoc[i]["id"].GetInt();
		uint64_t time = jsonDoc[i]["recycleTime"].GetUint64();

		data->item = item;
		data->id = id;
		data->time = time;
		data->sourceId = sourceId;
		if (recycleAll)
		{
			GetBackpack()->putAndClean(item);
			delete data;
		}
		else
		{
			GetSocializeSystem()->addRecycleItem(data);
		}
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TEAM_RECYCLE_VIEW);

}

void WSManager::processGetTeamLog(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());


	GetSocializeSystem()->clearTeamLogList();
	for (size_t i = 0; i < jsonDoc.Size(); i++) {

		TeamLog* log = new TeamLog();
		log->time = jsonDoc[i]["time"].GetUint64();
		log->targetId = jsonDoc[i]["target"].GetInt64();
		log->targetName = jsonDoc[i]["targetName"].GetString();
		std::string type = jsonDoc[i]["type"].GetString();
		log->logType = GetSocializeSystem()->checkLogType(type);

		GetSocializeSystem()->addLogList(log);
	}

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TEAM_INFORMATION_VIEW);
}

void WSManager::processRecycleSingle(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());



	int id = jsonDoc["id"].GetInt();
	Item* item = GetSocializeSystem()->getRecycleItem(id);
	GetBackpack()->putAndClean(item);
	GetSocializeSystem()->removeRecycleItem(id);

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TEAM_RECYCLE_VIEW);
}


void WSManager::processGetOwnerPermissions(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GetSocializeSystem()->clearSelfPermissionData();


	auto itr = jsonDoc.MemberBegin();
	while (itr != jsonDoc.MemberEnd()) {
		OwnerPermission* res = new OwnerPermission();
		int64_t memberId = atoi(itr->name.GetString());
		res->memberId = memberId;

		std::vector<std::string> str;
		for (size_t j = 0; j < itr->value.Size(); j++)
		{
			std::string temp = itr->value[j].GetString();
			str.push_back(temp);
		}
		res->permissions = str;
		GetSocializeSystem()->addSelfPermission(res);
		itr++;
	}
	EventMgr::getInstance()->sendEvent(GameCustomEvent::UPDATE_TEAM_SELF_PERMISSION);
}


void WSManager::processGetUnlockedScope(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	GetSocializeSystem()->clearRecycleItemList();
	for (size_t i = 0; i < jsonDoc.Size(); i++)
	{
		int id = jsonDoc[i].GetInt();
		GetMapUnlockManager()->processUnlock(id);
	}

	GetMapUnlockManager()->removeAllCloud();
	GetMapUnlockManager()->createCloud();
}

void WSManager::processUnlockScopeCallback(const std::string& data)
{
	int id = stoi(data);
	GetMapUnlockManager()->processUnlock(id);

	GetMapUnlockManager()->removeCloudByIndex(id);

	GetMissionSystem()->unlockMapId(id);
	auto list = MapUnlockManager::getInstance()->getEntryPool();
	int unLockNum = 0;



	auto info = MapUnlockManager::getInstance()->getEntryPool()[id];

	EventMgr::getInstance()->sendEvent(GameCustomEvent::UNLOCK_MAP, (void*)id, 0);


	auto lockList_ = MapUnlockManager::getInstance()->getCloudDataMap();

	std::vector<int> lockId = { -1 };
	for (auto& data : lockList_) {
		int mapId = data.first;
		for (auto& mapLockData : data.second) {
			if (!mapLockData.lock && !Contains(lockId, mapLockData.id)) {
				lockId.push_back(mapLockData.id);
				unLockNum += 1;
				break;
			}
		}
	}

	if (!GetVisitSystem()->checkIsVisiting())
	{
		int need_money = info.coin;
		Backpack* backpackInst = Backpack::getInstance();
		GetMainGame()->addMoney(-need_money, false);
		for (size_t i = 0; i < info.itemsInfo.size(); i++)
		{
			backpackInst->consumeItem(info.itemsInfo[i].itemId, info.itemsInfo[i].amount, false);
		}
		GetMainGame()->addTownExp(info.exp, false);
		GetMsgMgr()->showMsg(u8"解锁区域成功！");

		GameMap* map = GetMainGame()->getMapById(info.buildingMapId);
		if (map)
		{
			map->removeMapUnlockBuilding(info.buildingX, info.buildingY);
		}
		GetMissionSystem()->unlockMapCumulative(unLockNum);
	}
}

void WSManager::processExitShuwujia(const std::string& data)//弃用
{
	SocializeSystem::getInstance()->onLeaveGuest();
}

void WSManager::processMapAllData(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	auto mapdata = jsonDoc[0]["mapData"].GetObject();
	int mapId = mapdata["id"].GetInt();
	CCLOG(data.c_str());

	int width = mapdata["width"].GetInt();
	int height = mapdata["height"].GetInt();
	int templateId = mapdata["itemId"].IsNull() ? 0 : mapdata["itemId"].GetInt();
	auto b64data = mapdata["data"].GetString();
	auto dataSize = mapdata["data"].GetStringLength();

	//GetMainGame()->createMapThin(mapId, templateId);

	std::string decodeData = b64decode(b64data, dataSize);
	CC_ASSERT(decodeData.size() == width * height * sizeof(MAPBLOCK));
	uint8_t* decompData = (uint8_t*)decodeData.c_str();

	MAPBLOCK* blocks = (MAPBLOCK*)malloc(decodeData.size());
	mapDataServerToClient(decompData, blocks, decodeData.size() / sizeof(MAPBLOCK), width);

	char buf[256];
	if (mapId <= MAP_DYNAMIC_START)
		sprintf(buf, "maps/map_%d.tmj", mapId);
	else
		sprintf(buf, "maps/template_%d.tmj", templateId);
	GetMainGame()->getMapById(mapId)->loadTmj(buf);

	GetMainGame()->getMapById(mapId)->setMapBlock(blocks);
	GetMainGame()->getMapById(mapId)->refreshMap();
	auto map = GetMainGame()->getMapById(mapId);
	map->setIsWebDataGeted(true);
	// ----------------------------------------------------------
	auto mapScopeList = jsonDoc[0]["mapScopeList"].GetArray();
	for (size_t i = 0; i < mapScopeList.Size(); i++)
	{
		//int mapid = mapScopeList[i]["mapIndex"].GetInt();

		MapScope* scope = new MapScope();
		int scopeid = mapScopeList[i]["id"].GetInt();
		scope->startx = mapScopeList[i]["start"]["x"].GetInt();
		scope->starty = mapScopeList[i]["start"]["y"].GetInt();
		scope->endx = mapScopeList[i]["end"]["x"].GetInt();
		scope->endy = mapScopeList[i]["end"]["y"].GetInt();
		std::vector<int> animallist;
		for (size_t j = 0; j < mapScopeList[i]["animalLimitList"].Size(); j++)
		{
			int animalid = mapScopeList[i]["animalLimitList"][j].GetInt();
			animallist.push_back(animalid);
		}
		scope->wildanimallist = animallist;
		map->addMapScope(scopeid, scope);
	}


	// ---------------------------------------------------------
	auto treasureBoxList = jsonDoc[0]["treasureBoxList"].GetArray();

	bool isRemove = false;
	for (size_t i = 0; i < treasureBoxList.Size(); i++) {
		int id = treasureBoxList[i]["mapIndex"].GetInt();
		bool open = treasureBoxList[i]["open"].GetBool();
		int buildId = treasureBoxList[i]["id"].GetInt();
		uint64_t openTime = treasureBoxList[i]["openTime"].GetUint64();
		bool disposable = treasureBoxList[i]["disposable"].GetBool();

		TreasureInfo* info = new TreasureInfo();
		info->buildId = buildId;
		info->isOpen = open;
		info->openTime = openTime;
		info->disposable = disposable;


		if (!isRemove)
		{
			auto oldInfo = GetMainGame()->getMapById(id)->getTreasureInfo();
			for (auto& curInfo : oldInfo)
			{
				auto ptr = curInfo.second;
				delete ptr;
			}
			GetMainGame()->getMapById(id)->clearTreasureInfo();
			isRemove = true;
		}


		GetMainGame()->getMapById(id)->addTreasureInfo(buildId, info);
	}
	// ----------------------------------------------

	// ------------------------------------------
	auto flowerList = jsonDoc[0]["flowerList"].GetArray();
	for (size_t i = 0; i < flowerList.Size(); i++) {
		int id = flowerList[i]["id"].GetInt();
		int cropId = flowerList[i]["cropId"].GetInt();
		uint64_t growTime = flowerList[i]["growTime"].GetUint64();
		uint64_t lastUpdateTime = flowerList[i]["lastUpdateTime"].GetUint64();
		int currentStageIndex = flowerList[i]["currentStageIndex"].GetInt();
		int mapX = flowerList[i]["mapPosition"]["x"].GetInt();
		int mapY = flowerList[i]["mapPosition"]["y"].GetInt();
		long long seedTime = flowerList[i]["seedTime"].GetInt64();

		Flower* flower = map->plantFlower(mapX, mapY, cropId, nullptr, id);
		flower->setStage(currentStageIndex);
		flower->setAccGrowTime(growTime);
		flower->setLastUpdate(lastUpdateTime);
		flower->initSeason(seedTime);
		map->addFarmList(mapX, mapY, ObjectListType::OLT_FLOWER, flower->isHarvestable());  //服务端懒更新 这里的数据未必是最新.....
	}
	// ------------------------------------------
	auto treeList = jsonDoc[0]["treeList"].GetArray();
	bool updateMap = true;
	for (size_t i = 0; i < treeList.Size(); i++) {
		int mapX = treeList[i]["mapPosition"]["x"].GetInt();
		int mapY = treeList[i]["mapPosition"]["y"].GetInt();
		int def = treeList[i]["size"]["def"].GetInt();
		int type = treeList[i]["treeId"].GetInt();
		int id = treeList[i]["id"].GetInt();
		float hp = treeList[i]["hp"].GetFloat();
		int growTime = treeList[i]["growTime"].GetInt();
		int exp = treeList[i]["exp"].GetInt();
		int currentStageIndex = treeList[i]["currentStageIndex"].GetInt();
		uint64_t lastUpdateTime = treeList[i]["lastUpdateTime"].GetUint64();

		Tree* tree = map->plantTree(mapX, mapY, id, type, currentStageIndex, updateMap);
		tree->setHp(hp);
		tree->setGrowTime(growTime);
		tree->setExp(exp);
		tree->setDef(def);
		tree->setLastUpdate(lastUpdateTime);
		/*
		for (size_t j = 0; j < jsonDoc[i]["size"]["growList"].Size(); j++) {
			int hpStage = jsonDoc[i]["size"]["hpList"][j].GetInt();
			int stumpHpStage = jsonDoc[i]["size"]["stumpHpList"][j].GetInt();
			tree->clearHpList();
			tree->addGrowStageHp(hpStage);
			tree->addStumpHp(stumpHpStage);
		}*/
	}

	//char buf[256];
	bool errorFound = false;
	std::string errorStr;
	for (int y = 0; y < map->getHeight(); y++) {
		for (int x = 0; x < map->getWidth(); x++) {
			auto block = map->getMapBlock(x, y);

			if (block->tileType == TILE_TREE) {
				Tree* tree = map->getTreeById(block->index);
				if (tree == nullptr) continue;
				int treeMapX, treeMapY;
				Vec2 treePos = tree->getPos();
				tree->getMapPos(&treeMapX, &treeMapY);

				int checkMapX = (int)(treePos.x / 128.0f);
				int checkMapY = (int)(treePos.y / 128.0f);

				if (treeMapX != x || treeMapY != y) {
					sprintf(buf, "mapId=%d mapPos=%d-%d id=%d treePos=%d-%d\n", mapId, x, y, block->index, treeMapX, treeMapY);
					errorStr += buf;
					errorFound = true;
				}
			}
		}
	}

	if (errorFound) {
		sendDebugLog("TreePosError:\n" + errorStr);
	}
	// ------------------------------------------
	auto treeStump = jsonDoc[0]["treeStump"].GetArray();
	for (size_t i = 0; i < treeStump.Size(); i++) {
		int id = treeStump[i]["id"].GetInt();
		int hp = treeStump[i]["hp"].GetInt();
		int treeId = treeStump[i]["treeId"].GetInt();
		int stage = treeStump[i]["stage"].GetInt();
		int mapX = treeStump[i]["mapPosition"]["x"].GetInt();
		int mapY = treeStump[i]["mapPosition"]["y"].GetInt();
		int def = treeStump[i]["def"].GetInt();

		map->spawnStump(mapX, mapY, treeId, hp, stage, def, false, id);
	}
	// ------------------------------------------
	auto resourceList = jsonDoc[0]["resourceList"].GetArray();
	for (size_t i = 0; i < resourceList.Size(); i++) {
		int mapX = resourceList[i]["mapPosition"]["x"].GetInt();
		int mapY = resourceList[i]["mapPosition"]["y"].GetInt();
		int typeId = resourceList[i]["itemId"].GetInt();
		int id = resourceList[i]["id"].GetInt();
		int hp = resourceList[i]["hp"].GetInt();
		int width = resourceList[i]["width"].GetInt();
		int height = resourceList[i]["height"].GetInt();
		int def = resourceList[i]["def"].GetInt();
		auto type = resourceList[i]["type"].GetString();
		MultiBlockResource::MultiBlockResourceType resourceType;

		if (!strcmp(type, "Rock")) {
			resourceType = MultiBlockResource::MultiBlockResourceType::ROCK;
		}
		else if (!strcmp(type, "BrokenBuilding")) {
			continue;
		}
		else if (!strcmp(type, "Trunk")) {
			resourceType = MultiBlockResource::MultiBlockResourceType::TRUNK;
		}
		else if (!strcmp(type, "Grass")) {
			Grass* grass = map->plantGrass(mapX, mapY, id, 1, updateMap);
			if (grass)
			{
				grass->setHp((float)hp);
				grass->setSize(width);
				grass->setDef((float)def);
				grass->setItemId(typeId);
			}
			else
			{
				int i = 0;
			}
			continue;
		}
		else {
			continue;
		}

		map->spawnMultiBlockResource(mapX, mapY, resourceType, width, height, hp, typeId, def, updateMap, id);
	}

	//处理飞行装饰动物
	map->dealAirAnimal();
	// ------------------------------------------
	auto pickableItemList = jsonDoc[0]["pickableItemList"].GetArray();
	for (size_t i = 0; i < pickableItemList.Size(); i++) {
		int id = pickableItemList[i]["id"].GetInt();
		float mapX = pickableItemList[i]["position"]["x"].GetFloat();
		float mapY = pickableItemList[i]["position"]["y"].GetFloat();
		int itemId = pickableItemList[i]["item"]["itemId"].GetInt();
		int amount = pickableItemList[i]["item"]["amount"].GetInt();
		int quality = pickableItemList[i]["item"]["quality"].GetInt();
		int portalId = pickableItemList[i]["item"]["portalId"].IsNull() ? -1 : pickableItemList[i]["item"]["portalId"].GetInt();
		int objectId = pickableItemList[i]["item"]["objectId"].IsNull() ? -1 : pickableItemList[i]["item"]["objectId"].GetInt();
		bool autopick = pickableItemList[i]["autoPickUp"].GetBool();
		int64_t uid = pickableItemList[i]["userId"].GetInt64();
		uint64_t expireTime = pickableItemList[i]["expiredTime"].GetUint64();

		mapX += (rand() % 128 - 64);
		mapY += (rand() % 128 - 64);

		DropItem* item = map->popItem(mapX, mapY, itemId, amount, id);
		item->setAutopick(autopick);
		item->setIdle();
		item->setQuality(quality);
		item->setPortalId(portalId);
		item->setObjectId(objectId);
		item->setUid(uid);
		item->setExpireTime(expireTime);
	}
	// ------------------------------------------
	auto catchCrabsTaskList = jsonDoc[0]["catchCrabsTaskList"].GetArray();
	for (size_t i = 0; i < catchCrabsTaskList.Size(); i++) {
		int mapX = catchCrabsTaskList[i]["mapPosition"]["x"].GetInt();
		int mapY = catchCrabsTaskList[i]["mapPosition"]["y"].GetInt();
		int id = catchCrabsTaskList[i]["id"].GetInt();
		int mapId = catchCrabsTaskList[i]["mapIndex"].GetInt();

		GameMap* map = GetMainGame()->getMapById(mapId);

		Crabcage* cage = map->plantCrabcage(mapX, mapY);

		cage->setId(id);
		map->addCrabcage(id, cage);

		if (!catchCrabsTaskList[i]["tool"]["filler"].IsNull())
		{
			int baitid = catchCrabsTaskList[i]["tool"]["filler"]["itemId"].GetInt();
			int baitamount = catchCrabsTaskList[i]["tool"]["filler"]["amount"].GetInt();
			cage->setBait(baitid, baitamount);
		}
		int grid = catchCrabsTaskList[i]["tool"]["type"].GetInt();
		int itemId = catchCrabsTaskList[i]["tool"]["itemId"].GetInt();
		uint64_t time = catchCrabsTaskList[i]["time"].GetUint64();
		cage->setStartTime(time);
		cage->setMaxGrid(grid);
		cage->setItemId(itemId);
		if (!catchCrabsTaskList[i]["result"].IsNull())
		{
			int amount = catchCrabsTaskList[i]["result"].Size();
			cage->setResultAmount(amount);
		}
		cage->showSpr(true);
	}
	// ------------------------------------------
	auto huntingTrapsTaskList = jsonDoc[0]["huntingTrapsTaskList"].GetArray();
	for (size_t i = 0; i < huntingTrapsTaskList.Size(); i++) {
		int mapX = huntingTrapsTaskList[i]["mapPosition"]["x"].GetInt();
		int mapY = huntingTrapsTaskList[i]["mapPosition"]["y"].GetInt();
		int id = huntingTrapsTaskList[i]["id"].GetInt();
		int mapId = huntingTrapsTaskList[i]["mapIndex"].GetInt();

		GameMap* map = GetMainGame()->getMapById(mapId);

		HuntingTrap* trap = map->getHuntingTrap(id);
		if (trap == nullptr)
		{
			std::vector<wildanimal*> wildanimallist;
			for (size_t j = 0; j < huntingTrapsTaskList[i]["result"].Size(); j++)
			{
				wildanimal* animal = new wildanimal();
				animal->animalid = huntingTrapsTaskList[i]["result"][j]["animalId"].GetInt();
				animal->time = huntingTrapsTaskList[i]["result"][j]["time"].GetUint64();

				wildanimallist.push_back(animal);
			}
			int itemId = huntingTrapsTaskList[i]["tool"]["itemId"].GetInt();
			HuntingTrap* trap = map->plantHuntingTrap(mapX, mapY, itemId);
			trap->setId(id);
			trap->settrapRestult(wildanimallist);
			if (!huntingTrapsTaskList[i]["fillerAmount"].IsNull()) {
				int fillerItemId = huntingTrapsTaskList[i]["fillerAmount"]["itemId"].GetInt();
				int fillerAmount = huntingTrapsTaskList[i]["fillerAmount"]["amount"].GetInt();
				Item* filler = GetItemProvider()->spawnItemWithAmount(fillerItemId, fillerAmount);
				trap->setBait(filler);
			}
			map->addHuntingTrap(id, trap);
		}
	}
	// ------------------------------------------

	// ------------------------------------------ 普通建筑
	ItemType itemType = ItemType::BUILDING;
	auto buildingList = jsonDoc[0]["buildingList"].GetArray();
	for (size_t i = 0; i < buildingList.Size(); i++) {
		int id = buildingList[i]["id"].GetInt();
		int mapX = buildingList[i]["mapPosition"]["x"].GetInt();
		int mapY = buildingList[i]["mapPosition"]["y"].GetInt();
		int typeId = buildingList[i]["typeId"].GetInt();
		int xPos = mapX * 128;
		int yPos = (mapY + 1) * 128;
		int portalId = buildingList[i]["inPortalId"].IsNull() ? 0 : buildingList[i]["inPortalId"].GetInt();
		bool moveLock = buildingList[i]["moveLock"].GetBool();
		int beauty = buildingList[i]["beauty"].GetInt();
		int ownerId = buildingList[i]["ownerId"].GetInt();
		bool recyclable = buildingList[i]["recyclable"].GetBool();

		MapObject* obj = nullptr;

		switch (itemType) {
		case ItemType::BUILDING:
		case ItemType::INDOORBUILDING:
		case ItemType::INDOOROUTDOORBUILDING:
		{
			if (Contains(dummyBuildingIdList, typeId)) {
				map->spawnDummyBuilding(typeId, xPos, yPos, mapX, mapY, id, moveLock);
				continue;
			}

			Building* building = map->spawnBuilding(typeId, (float)xPos, (float)yPos, nullptr, id, -1, true);
			building->setPortalId(portalId);
			building->setBeauty(beauty);
			building->setOwnerId(ownerId);
			building->setRecyclable(recyclable);

			if (mapId < 100 && portalId > 0) {
				GetMainGame()->addPortalBuildingPair(portalId, building);
				auto portal = GetMainGame()->getPortal(portalId);
				if (portal)
				{
					GetMainGame()->addMapBuildingMap(portal->mapIndex, building);
				}
			}

			if (building->getBuildingId() == 22064) //矿洞
			{
				int i = building->getId();
				MineSystemController::getInstance()->setData(building, mapId, i);
			}

			obj = building;


		}
		break;

		case ItemType::WALL:
		case ItemType::INDOORWALL:
			obj = map->spawnWall(typeId, mapX, mapY, false, id, false);
			((Wall*)obj)->setBeauty(beauty);
			break;
		default:
			continue;
		}

		obj->setLock(moveLock);
	}

	if (itemType == ItemType::WALL || itemType == ItemType::INDOORWALL) {
		map->updateWallSprite();
	}
	// ------------------------------------------   墙
	itemType = ItemType::WALL;
	auto wallList = jsonDoc[0]["wallList"].GetArray();
	for (size_t i = 0; i < wallList.Size(); i++) {
		int id = wallList[i]["id"].GetInt();
		int mapX = wallList[i]["mapPosition"]["x"].GetInt();
		int mapY = wallList[i]["mapPosition"]["y"].GetInt();
		int typeId = wallList[i]["typeId"].GetInt();
		int xPos = mapX * 128;
		int yPos = (mapY + 1) * 128;
		int portalId = wallList[i]["inPortalId"].IsNull() ? 0 : wallList[i]["inPortalId"].GetInt();
		bool moveLock = wallList[i]["moveLock"].GetBool();
		int beauty = wallList[i]["beauty"].GetInt();
		int ownerId = wallList[i]["ownerId"].GetInt();

		MapObject* obj = nullptr;

		switch (itemType) {
		case ItemType::BUILDING:
		case ItemType::INDOORBUILDING:
		case ItemType::INDOOROUTDOORBUILDING:
		{
			if (Contains(dummyBuildingIdList, typeId)) {
				map->spawnDummyBuilding(typeId, xPos, yPos, mapX, mapY, id, moveLock);
				continue;
			}

			Building* building = map->spawnBuilding(typeId, (float)xPos, (float)yPos, nullptr, id, -1, true);
			building->setPortalId(portalId);
			building->setBeauty(beauty);
			building->setOwnerId(ownerId);

			if (mapId < 100 && portalId > 0) {
				GetMainGame()->addPortalBuildingPair(portalId, building);
				auto portal = GetMainGame()->getPortal(portalId);
				if (portal)
				{
					GetMainGame()->addMapBuildingMap(portal->mapIndex, building);
				}
			}

			if (building->getBuildingId() == 22064) //矿洞
			{
				int i = building->getId();
				MineSystemController::getInstance()->setData(building, mapId, i);
			}

			obj = building;


		}
		break;

		case ItemType::WALL:
		case ItemType::INDOORWALL:
			obj = map->spawnWall(typeId, mapX, mapY, false, id, false);
			((Wall*)obj)->setBeauty(beauty);
			break;
		default:
			continue;
		}

		obj->setLock(moveLock);
	}

	if (itemType == ItemType::WALL || itemType == ItemType::INDOORWALL) {
		map->updateWallSprite();
	}
	// ----------------------------------------------
	auto hangingDecorationList = jsonDoc[0]["hangingDecorationList"].GetArray();
	for (size_t i = 0; i < hangingDecorationList.Size(); i++) {
		int id = hangingDecorationList[i]["id"].GetInt();
		int itemId = hangingDecorationList[i]["itemId"].GetInt();
		int mapX = hangingDecorationList[i]["mapPosition"]["x"].GetInt();
		int mapY = hangingDecorationList[i]["mapPosition"]["y"].GetInt();
		bool recyclable = hangingDecorationList[i]["recyclable"].GetBool();
		map->spawnWallDecor(mapX, mapY, itemId, recyclable, id, itemId == 38037 ? true : false);  //TODO 灯暂时写死38037
	}
	// ----------------------------------------------
	auto coatHangerMap = jsonDoc[0]["coatHangerMap"].GetObject();
	auto itr = coatHangerMap.MemberBegin();

	while (itr != coatHangerMap.MemberEnd()) {
		int buildingId = atoi(itr->name.GetString());
		int itemId = itr->value["itemId"].GetInt();

		ClothesStand* stand = (ClothesStand*)map->getBuildingById(buildingId);
		stand->setClothes(itemId);

		itr++;
	}
	// ----------------------------------------------
	auto carpetPositionList = jsonDoc[0]["carpetPositionList"].GetArray();

	for (size_t i = 0; i < carpetPositionList.Size(); i++) {
		int mapX = carpetPositionList[i]["mapPosition"]["x"].GetInt();
		int mapY = carpetPositionList[i]["mapPosition"]["y"].GetInt();
		int itemId = carpetPositionList[i]["itemId"].GetInt();
		int id = carpetPositionList[i]["id"].GetInt();
		int beauty = 0;

		if (carpetPositionList[i].HasMember("beauty"))
			beauty = carpetPositionList[i]["beauty"].GetInt();
		else
			beauty = GetItemProvider()->getData(itemId)->values[0];

		auto carpet = map->spawnCarpet(mapX, mapY, itemId, false, id);
		carpet->setBeauty(beauty);
	}
	// ----------------------------------------------
	auto transferArrayList = jsonDoc[0]["transferArrayList"].GetArray();
	for (size_t i = 0; i < transferArrayList.Size(); i++) {
		int id = transferArrayList[i]["mapIndex"].GetInt();
		bool unlock = transferArrayList[i]["unlock"].GetBool();
		int buildId = transferArrayList[i]["id"].GetInt();

		GetMainGame()->getMapById(id)->addTpInfo(buildId, unlock);
	}
	// ----------------------------------------------
	auto mailboxList = jsonDoc[0]["mailboxList"].GetArray();
	for (size_t i = 0; i < mailboxList.Size(); i++) {
		int id = mailboxList[i]["mapIndex"].GetInt();
		bool unlock = mailboxList[i]["unlock"].GetBool();
		int buildId = mailboxList[i]["id"].GetInt();

		GetMainGame()->getMapById(id)->addMailInfo(buildId, unlock);
	}
	// ----------------------------------------------
	// 庄稼移到最后处理
	unsigned long long nowTime = time(NULL);

	auto cropList = jsonDoc[0]["cropList"].GetArray();
	for (size_t i = 0; i < cropList.Size(); i++) {
		int id = cropList[i]["id"].GetInt();
		int cropId = cropList[i]["cropId"].GetInt();
		uint64_t growTime = cropList[i]["growTime"].GetUint64();
		uint64_t lastWaterTime = cropList[i]["lastWaterTime"].GetUint64();
		uint64_t seedTime = cropList[i]["seedTime"].GetUint64();
		bool watered = cropList[i]["watered"].GetBool();
		int currentStageIndex = cropList[i]["currentStageIndex"].GetInt();

		Crop* crop = Crop::create();
		crop->setId(id);
		crop->setParentMap(map);
		crop->setData(cropId);
		crop->setCameraMask(map->getCameraMask());
		//crop->setStage(currentStageIndex);
		crop->_setStage(currentStageIndex);
		if (watered) {
			crop->water(lastWaterTime);
		}
		else
		{
			crop->setLastWaterTime(lastWaterTime);
		}
		crop->setAccGrowTime(growTime);
		GetMainGame()->addUpdate(crop);
		crop->retain();
		map->addCrop(id, crop);
		crop->setSeedTime(seedTime);
	}

	for (int mapY = 0; mapY < map->getHeight(); mapY++) {
		for (int mapX = 0; mapX < map->getWidth(); mapX++) {
			MAPBLOCK* block = map->getMapBlock(mapX, mapY);

			if (block->tileType == TILE_FARM && block->index > 0) {
				Crop* crop = map->getCrop(mapX, mapY);
				if (crop == nullptr)
				{
					continue;
				}
				Vec2 cropPos;
				cropPos.x = (mapX + 0.5f) * map->getTileWidth();
				cropPos.y = (mapY + 1) * map->getTileHeight() - 64.0f;
				crop->setPos(cropPos);
				crop->setMapPos(mapX, mapY);
				map->addFarmList(mapX, mapY, ObjectListType::OLT_CROP, crop->isHarvestable());

				int currentStageIndex = crop->getStage();
				crop->initAboutRain(crop->getSeedTime(), nowTime * 1000);
				if (currentStageIndex == crop->getStage())
				{
					crop->setStage(currentStageIndex);
				}
				crop->checkRemoveWater();
			}


		}
	}
	//map->saveToJson();
	// ------------------------------------------
	// ----------------------------------------------
	// ------------------------------------ end

	auto isMapBuilding = GetMainGame()->checkMapBuildingMap(mapId);
	if (isMapBuilding)
	{
		auto building = GetMainGame()->getBuildingByMapId(mapId);
		if (Contains(homeBuildingList, building->getBuildingId()) || Contains(houseBuildingList, building->getBuildingId()))
		{
			((House*)building)->creatAllPartner();
		}

		if (Contains(museumList, building->getBuildingId())) {

			((Museum*)building)->creatAllArtifact();
		}

		if (Contains(animalHouseTypes, building->getBuildingId())) {
			if (!((AnimalHouse*)building)->checkFirstCreateMap())
			{
				((AnimalHouse*)building)->createAllAnimal();
				((AnimalHouse*)building)->showTroughPrompt(mapId);
			}
		}
	}

	if (GetMainGame()->isInitComplete())//非登录界面时接到消息
	{
		if (mapId != 132 && Contains(minemapIdList, mapId)) //请求矿洞信息
		{
			GetWSManager()->getMineList(mapId);
			GetLightController()->getLightStateList(mapId);
			GetMineController()->getGearInfo(mapId);
			GetMineController()->getDoorInfo(mapId);
			GetMineController()->getLayerConfig(mapId);
		}

		return;//非登录界面时接到消息
	}

	int mapIdc = 0;
	if (g_MapAllDataJsonDoc_cnt >= g_mapIdVtr.size())
	{
		if (mapId != 132 && Contains(minemapIdList, mapId)) //请求矿洞信息
		{
			GetWSManager()->getMineList(mapId);
			GetLightController()->getLightStateList(mapId);
			GetMineController()->getGearInfo(mapId);
			GetMineController()->getDoorInfo(mapId);
			GetMineController()->getLayerConfig(mapId);
		}

		auto& lmvtr = MainView::getLoadingMapVtr();
		for (auto itr = lmvtr.begin(); itr != lmvtr.end(); itr++)
		{
			if (*itr == mapId)
			{
				lmvtr.erase(itr);
				break;
			}
		}

		return;
	}

	do {
		g_MapAllDataJsonDoc_cnt++;
		GetMainGame()->increateMapLoaded();

		if (g_MapAllDataJsonDoc_cnt == g_mapIdVtr.size())
		{
			GetMainGame()->completeInit();
			return;
		}

		mapIdc = g_mapIdVtr[g_MapAllDataJsonDoc_cnt];

	} while (MineSystemController::getInstance()->checkIsMineMap(mapIdc) && mapIdc != 132);

	//g_MapAllDataJsonDoc_cnt++;
	//GetMainGame()->increateMapLoaded();

	if (mapId == 131)
	{
		GetSocializeSystem()->refreshMapByMember();
	}

	if (g_MapAllDataJsonDoc_cnt == g_mapIdVtr.size())
	{
		GetMainGame()->completeInit();
	}
	else
	{
		char buf[255];
		sprintf(buf, "%04d %d", WSCommand::GET_ALL_DATA, g_mapIdVtr[g_MapAllDataJsonDoc_cnt]);
		send(buf);
		int mapId = g_mapIdVtr[g_MapAllDataJsonDoc_cnt];
		if (mapId != 132 && Contains(minemapIdList, mapId)) //请求矿洞信息
		{
			GetWSManager()->getMineList(mapId);
			GetLightController()->getLightStateList(mapId);
			GetMineController()->getGearInfo(mapId);
			GetMineController()->getDoorInfo(mapId);
			GetMineController()->getLayerConfig(mapId);
		}
	}
}

void WSManager::dealCreateMapPerFrame()
{
	return;
	if (g_MapAllDataJsonDoc_cnt == 0) return;

	if (g_MapAllDataJsonDoc_cnt > g_MapAllDataJsonDoc.Size()) return;

	g_MapAllDataJsonDoc_cnt--;

	auto mapScopeList = g_MapAllDataJsonDoc[g_MapAllDataJsonDoc_cnt]["mapScopeList"].GetArray();


	char buf[256];
	//for (int i = 0; i < g_MapAllDataJsonDoc.Size(); i++)
	//{
	//	int iii = g_MapAllDataJsonDoc[i]["id"].GetInt();
	//	int iii2 = g_MapAllDataJsonDoc[i]["mapIndex"].GetInt();
	//}


	// ---------------------------------------------------------
	auto treasureBoxList = g_MapAllDataJsonDoc[g_MapAllDataJsonDoc_cnt]["treasureBoxList"].GetArray();

	bool isRemove = false;
	for (size_t i = 0; i < treasureBoxList.Size(); i++) {
		int id = treasureBoxList[i]["mapIndex"].GetInt();
		bool open = treasureBoxList[i]["open"].GetBool();
		int buildId = treasureBoxList[i]["id"].GetInt();
		uint64_t openTime = treasureBoxList[i]["openTime"].GetUint64();
		bool disposable = treasureBoxList[i]["disposable"].GetBool();

		TreasureInfo* info = new TreasureInfo();
		info->buildId = buildId;
		info->isOpen = open;
		info->openTime = openTime;
		info->disposable = disposable;


		if (!isRemove)
		{
			auto oldInfo = GetMainGame()->getMapById(id)->getTreasureInfo();
			for (auto& curInfo : oldInfo)
			{
				auto ptr = curInfo.second;
				delete ptr;
			}
			GetMainGame()->getMapById(id)->clearTreasureInfo();
			isRemove = true;
		}


		GetMainGame()->getMapById(id)->addTreasureInfo(buildId, info);
	}


	// ------------------------------------ end
	g_MapAllDataJsonDoc_cnt++;
	g_MapAllDataJsonDoc_cnt++;
	GetMainGame()->increateMapLoaded();

	if (g_MapAllDataJsonDoc_cnt - 1 == g_MapAllDataJsonDoc.Size())
	{
		GetMainGame()->completeInit();
	}
}

void WSManager::processClearTree(const std::string& data)
{
	int commaPos = data.find(",");
	int mapId = atoi(data.substr(0, commaPos).c_str());
	string jsonStr = data.substr(commaPos + 1);

	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)jsonStr.c_str());

	GameMap* map = GetMainGame()->getMapById(mapId);

	int mapX = jsonDoc["mapPosition"]["x"].GetInt();
	int mapY = jsonDoc["mapPosition"]["y"].GetInt();
	int def = jsonDoc["size"]["def"].GetInt();
	int type = jsonDoc["treeId"].GetInt();
	int id = jsonDoc["id"].GetInt();
	float hp = jsonDoc["hp"].GetFloat();
	int growTime = jsonDoc["growTime"].GetInt();
	int exp = jsonDoc["exp"].GetInt();
	int currentStageIndex = jsonDoc["currentStageIndex"].GetInt();
	uint64_t lastUpdateTime = jsonDoc["lastUpdateTime"].GetUint64();

	Tree* tree = map->getTree(mapX, mapY);
	auto block = map->getMapBlock(mapX, mapY);
	map->removeTree(id);
	GetMainGame()->removeUpdate(tree);
	tree->removeAllChildren();
	tree->removeFromParent();
	tree->release();
	block->tileType = TileType::TILE_NONE;
	block->index = 0;
	block->inpassable = 0;
}

void WSManager::processTp(const std::string& data)
{
	if (UIViewMgr::getInstance()->isViewShow(uiType::UI_MAIN_VIEW))
	{
		auto building = GetMainGame()->getTpBuilding();
		if (building)
		{
			auto view = (MainView*)UIViewMgr::getInstance()->getView(uiType::UI_MAIN_VIEW);
			view->updateMiniMapPos(GetMainGame()->getCurrentMapId(), building, Vec2(-256.f * 1.5f, 32.f));
		}
	}
}

void WSManager::processMailInfo(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["mapIndex"].GetInt();
		bool unlock = jsonDoc[i]["unlock"].GetBool();
		int buildId = jsonDoc[i]["id"].GetInt();

		GetMainGame()->getMapById(id)->addMailInfo(buildId, unlock);
	}
}

void WSManager::processMailUnlock(const std::string& data)
{

}

void WSManager::processMissionPlace(const std::string& data)
{
}

void WSManager::processCustomRedPoint(const std::string& data)
{
	auto a = 1;

	rapidjson::Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int type = 0;
	int id = 0;
	bool isUnread = false;
	auto itr = jsonDoc.MemberBegin();
	if (itr != jsonDoc.MemberEnd()) {
		auto key = itr->name.GetString();
		isUnread = itr->value.GetInt() == 0 ? true : false;  //0 未读
		std::vector<std::string> strList = splitStringByDelimiter(key, ":");
		type = atoi(strList[0].c_str());
		id = atoi(strList[1].c_str());
	}

	if (isUnread)
	{
		if (type == 13) //好友送礼
		{
			auto fview = (FriendView*)UIViewMgr::getInstance()->getView(uiType::UI_FRIEND_VIEW);
			auto mview = (MainView*)UIViewMgr::getInstance()->getView(uiType::UI_MAIN_VIEW);

			if (mview)
			{
				mview->setTownRedPointInfo(HAOYOU_GIFT, true);
			}

			if (fview)
			{
				fview->setShouquRedPoint(true);
			}
		}
	}

}

void WSManager::processGetTreasureInfo(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	bool isRemove = false;
	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["mapIndex"].GetInt();
		bool open = jsonDoc[i]["open"].GetBool();
		int buildId = jsonDoc[i]["id"].GetInt();
		uint64_t openTime = jsonDoc[i]["openTime"].GetUint64();
		bool disposable = jsonDoc[i]["disposable"].GetBool();

		TreasureInfo* info = new TreasureInfo();
		info->buildId = buildId;
		info->isOpen = open;
		info->openTime = openTime;
		info->disposable = disposable;


		if (!isRemove)
		{
			auto oldInfo = GetMainGame()->getMapById(id)->getTreasureInfo();
			for (auto& curInfo : oldInfo)
			{
				auto ptr = curInfo.second;
				delete ptr;
			}
			GetMainGame()->getMapById(id)->clearTreasureInfo();
			isRemove = true;
		}


		GetMainGame()->getMapById(id)->addTreasureInfo(buildId, info);
	}
}

void WSManager::processGetMineMapIdList(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());
	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		minemapIdList.push_back(jsonDoc[i].GetInt());
	}
}

void WSManager::processTpInfo(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	for (size_t i = 0; i < jsonDoc.Size(); i++) {
		int id = jsonDoc[i]["mapIndex"].GetInt();
		bool unlock = jsonDoc[i]["unlock"].GetBool();
		int buildId = jsonDoc[i]["id"].GetInt();

		GetMainGame()->getMapById(id)->addTpInfo(buildId, unlock);
	}

}

void WSManager::processDialogueApprove(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	auto npclist = jsonDoc["npcApprove"].GetObject();
	auto cardlist = jsonDoc["cardApprove"].GetObject();

	char buf[256];
	for (auto iter = npclist.begin(); iter != npclist.end(); iter++)
	{
		int npcid = atoi(((*iter).name).GetString());
		int val = ((*iter).value).GetInt();

		if (npcid != 0 && npcid != -1)
		{
			auto npc = MainGame::getInstance()->getNpcById(npcid);
			npc->addFavor(val);
		}

		sprintf(buf, u8"好感度+%d", val);
		MsgMgr::getInstance()->showMsg(buf, Color4B(255, 64, 64, 255), Color4B(0, 0, 0, 255), false);
	}

	for (auto iter = cardlist.begin(); iter != cardlist.end(); iter++)
	{
		//int cardid = atoi(((*iter).name).GetString());
		//int val = ((*iter).value).GetInt();
		//
		//if (cardid != 0 && cardid != -1)
		//{
		//	auto card = CharacterSystem::getInstance()->getCardIndex();
		//	card->addFavor(val);
		//}
		//
		//sprintf(buf, u8"好感度+%d", val);
		//MsgMgr::getInstance()->showMsg(buf, Color4B(255, 64, 64, 255), Color4B(0, 0, 0, 255), true);
	}
}

void WSManager::processUnLockTpCallbakk(const std::string& data)
{
	GetMsgMgr()->showMsg(u8"解锁成功。");
}

void WSManager::processCreateMineData(const std::string& data)
{
	Document jsonDoc;
	jsonDoc.ParseInsitu((char*)data.c_str());

	int mapId = jsonDoc["id"].GetInt();

	if (GetMineController()->checkIsMineMap(mapId))
	{
		int x = jsonDoc["portalMapPosition"]["x"].GetInt();
		int y = jsonDoc["portalMapPosition"]["y"].GetInt();

		std::string data = jsonDoc["data"].GetString();
		int lockTaskId = jsonDoc["lockValueId"].GetInt();
		bool isLockMinePortal = jsonDoc["lockPortal"].GetBool();
		string decodeData = b64decode(data);
		size_t dataSize = decodeData.size();

		GameMap* map = GetMainGame()->getMapById(mapId);


		map->setUnLockTaskId(lockTaskId);
		map->setIsLockMinePortal(isLockMinePortal);
		if (map == nullptr) return;
		CCASSERT(map != nullptr, "Map not available initialization");
		map->clearMineData(); //更新前先clear旧的
		GetLightController()->getLightStateList(mapId);  //更新本地图的灯光

		map->setMinePortalPos(x, y);
		MINEMAPBLOCK* blocks = (MINEMAPBLOCK*)malloc(dataSize);
		memcpy(blocks, decodeData.data(), dataSize);


		map->setMineMapBlock(blocks);
		map->refreshMine();

		CCLOG("*******************portalInfo: mapId: %d, x: %d, y: %d", mapId, x, y);
	}
}



